<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="pom-relationships">
  <title>项目对象模型</title>

  <section>
    <title>简介</title>

    <para>本章讨论Maven的核心概念——<indexterm class="startofrange" id="pom1">
        <primary>POM (Project Object Model)</primary>
      </indexterm>项目对象模型。在<acronym>POM</acronym>中，项目的坐标和结构被声明，构建被配置，与其它项目的关联也被定义。<filename
    moreinfo="none">pom.xml</filename>文件定义了一个Maven项目。</para>
  </section>

  <section id="pom-relationships-pom">
    <title>POM</title>

    <para>Maven项目，依赖，构建配置，以及构件：所有这些都是要建模和表述的对象。这些对象通过一个名为项目对象模型(Project Object
    Model,
    <acronym>POM</acronym>)的<acronym>XML</acronym>文件描述。这个<acronym>POM</acronym>告诉Maven它正处理什么类型的项目，如何修改默认的行为来从源码生成输出。同样的方式，一个Java
    Web应用有一个<filename
    moreinfo="none">web.xml</filename>文件来描述，配置，及自定义该应用，一个Maven项目则通过一个<indexterm>
        <primary>pom.xml file</primary>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>

        <seealso>POM</seealso>
      </indexterm> <filename
    moreinfo="none">pom.xml</filename>文件定义。该文件是Maven中一个项目的描述性陈述；也是一个当Maven构建项目的时候需要理解的一份“地图”。</para>

    <para>你可以将<filename moreinfo="none">pom.xml</filename>看成是类似于<filename
    moreinfo="none">Makefile</filename>或者Ant中的<filename
    moreinfo="none">build.xml</filename>。当你使用<acronym>GNU</acronym>
    <emphasis>make</emphasis> 来构建诸如MySQL软件的时候，你通常会有一个名为<filename
    moreinfo="none">Makefile</filename>的文件，它包含了显式的指令来清理，编译，打包以及部署一个而应用。在这一点上，Make，Ant，和Maven是相似的，它们都依赖于一个同一命名的文件如<filename
    moreinfo="none">Makefile</filename>，<filename
    moreinfo="none">build.xml</filename>，或者<filename
    moreinfo="none">pom.xml</filename>，但相似的地方也仅此而已。如果你看一下Maven的<filename
    moreinfo="none">pom.xml</filename>，<acronym>POM</acronym>的主要内容是处理描述信息：哪里存放源代码？哪里存放资源文件？打包方式是什么？如果你看一下Ant的<filename
    moreinfo="none">build.xml</filename>文件，你会看到完全不同的东西。那里有显示的指令来执行一些任务，如编译一组Java类。Maven的<acronym>POM</acronym>是声明性的，虽然你可以通过Maven
    Ant插件来引入一些过程式的自定义指令，但大部分时间里，你不需要去了解项目构建的过程细节。</para>

    <para>POM也不只是仅仅针对于构建Java项目。虽然本书的大部分样例都是Java应用，但是在Maven的项目对象模型定义中没有任何Java特定的东西。虽然Maven默认的插件是从一组源码，测试，和资源来构建一个<acronym>JAR</acronym>文件。但你同样可以为一个包含C#源码，使用微软工具处理一些微软私有的二进制文件的项目来定义一个<acronym>POM</acronym>。类似的，你也可以为一本技术书籍定义一个<acronym>POM</acronym>。事实上，本书的源码和本书的样例正式以一个Maven多模块项目组织的，我们使用一个Maven
    Docbook插件，将标准的Docbook
    <acronym>XSL</acronym>应用到一系列章节的<acronym>XML</acronym>文件上。还有人编写了Maven插件来将Adobe
    Flex代码构建成<acronym>SWC</acronym>和<acronym>SWF</acronym>，也还有人使用了Maven来构建C编写的项目。</para>

    <para>我们已经确定了<acronym>POM</acronym>是描述性和声明性的，它不像Ant或者Make那样提供显式的指令，我们也注意到<acronym>POM</acronym>的概念不是特定于Java的。让我们深入更多的细节，看一下<xref
    linkend="fig-pom" />，纵览一下<acronym>POM</acronym>的内容。</para>

    <para><figure id="fig-pom">
        <title>项目对象模型</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom-relationships_pom-small.png" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para><acronym>POM</acronym>包含了四类描述和配置：</para>

    <variablelist>
      <varlistentry>
        <term>项目总体信息</term>

        <listitem>
          <para>它包含了一个项目的而名称，项目<indexterm>
              <primary>project information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>licensing information (project information)</primary>
            </indexterm><indexterm>
              <primary>organizational information (project
              information)</primary>
            </indexterm><indexterm>
              <primary>developer information (project information)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>project information in</secondary>
            </indexterm>的<acronym>URL</acronym>，发起组织，以及项目的开发者贡献者列表和许可证。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>构建设置</term>

        <listitem>
          <para>在这一部分，我们自定义<indexterm>
              <primary>build information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build information in</secondary>
            </indexterm>Maven构建的默认行为。我们可以更改源码和测试代码的位置，可以添加新的插件，可以将插件目标绑定到生命周期，我们还可以自定义站点生成参数。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>构建环境</term>

        <listitem>
          <para>构建环境包含了一些能在不同使用环境中<indexterm>
              <primary>build environment</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build environment</secondary>
            </indexterm>
          激活的profile。例如，在开发过程中你可能会想要将应用部署到一个而开发服务器上，而在产品环境中你会需要将应用部署到产品服务器上。构建环境为特定的环境定制了构建设置，通常它还会由<filename
          moreinfo="none">~/.m2</filename>中的自定义<indexterm>
              <primary>settings.xml file</primary>
            </indexterm><filename
          moreinfo="none">settings.xml</filename>补充。这个settings文件将会在<xref
          linkend="profiles" />中，以及<xref
          linkend="appendix-settings-details" />中的<xref
          linkend="settings-details" />小结中讨论。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>POM关系</term>

        <listitem>
          <para>一个项目很少孤立存在；它会依赖于其它项目，可能从父项目继承<acronym>POM</acronym>设置，它要定义自身的坐标，可能还会包含子模块。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="section-super-pom">
      <title>超级POM</title>

      <para>在我们深入钻研一些样例<acronym>POM</acronym>之前，让我们先快速看一下超级<acronym>POM</acronym>。所有的Maven项目的<acronym>POM</acronym>都扩展自超级<acronym>POM</acronym>。超级<acronym>POM</acronym>定义了一组被所有项目共享的默认设置。它是Maven安装的一部分，可以在<filename>${M2_HOME}/lib</filename>中的<filename>maven-2.0.9-uber.jar</filename>文件中找到。如果你看一下这个<acronym>JAR</acronym>文件，你会看到在包<package>org.apache.maven.project</package>下看到一个名为<filename>pom-4.0.0.xml</filename>的文件。这个Maven的超级<acronym>POM</acronym>如<xref
      linkend="ex-super-pom" />所示。</para>

      <example id="ex-super-pom">
        <title>超级POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Maven Default Project&lt;/name&gt;

  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-1"
            linkends="coRef-super-1" />
      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-2"
            linkends="coRef-super-2" />
      &lt;name&gt;Maven Plugin Repository&lt;/name&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;build&gt; <co id="coDef-super-3" linkends="coRef-super-3" />
    &lt;directory&gt;target&lt;/directory&gt;
    &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
    &lt;finalName&gt;${pom.artifactId}-${pom.version}&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;target/test-classes&lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
  &lt;/build&gt;

      &lt;pluginManagement&gt;<co id="coDef-super-4" linkends="coRef-super-4" />
       &lt;plugins&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.1&lt;/version&gt;
         &lt;/plugin&gt;       
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2-beta-1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-rar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-7&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-6&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.4&lt;/version&gt;
         &lt;/plugin&gt;         
         &lt;plugin&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1-alpha-1&lt;/version&gt;
         &lt;/plugin&gt;
       &lt;/plugins&gt;
     &lt;/pluginManagement&gt;
  
  &lt;reporting&gt;
    &lt;outputDirectory&gt;target/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>这个超级<acronym>POM</acronym>定义了一些由所有项目继承的标准的配置变量。对这些变量的简单解释如下：</para>

      <calloutlist>
        <callout arearefs="coDef-super-1" id="coRef-super-1">
          <para>默认的超级<acronym>POM</acronym>定义了一个单独的远程Maven仓库，ID为<literal>central</literal>。这是所有Maven客户端默认配置访问的中央Maven仓库。该配置可以通过一个自定义的<filename
          moreinfo="none">settings.xml</filename>文件来覆盖。注意这个默认的超级<acronym>POM</acronym>关闭了从中央Maven仓库下载snapshot构件的功能。如果你需要使用一个snapshot仓库，你就要在你的<filename
          moreinfo="none">pom.xml</filename>或者<filename
          moreinfo="none">settings.xml</filename>中自定义仓库设置。Settings和profile将会在<xref
          linkend="profiles" />中和<xref
          linkend="appendix-settings-details" />中的<xref
          linkend="settings-details" />小节中具体介绍。</para>
        </callout>

        <callout arearefs="coDef-super-2" id="coRef-super-2">
          <para>中央Maven仓库同时也包含Maven插件。默认的插件仓库就是这个中央仓库。Snapshot被关闭了，而且更新策略被设置成了“从不”，这意味着Maven将永远不会自动更新一个插件，即使新版本的插件发布了。</para>
        </callout>

        <callout arearefs="coDef-super-3" id="coRef-super-3">
          <para><sgmltag>build</sgmltag>元素设置Maven标准目录布局中那些目录的默认值。</para>
        </callout>

        <callout arearefs="coDef-super-4" id="coRef-super-4">
          <para>从Maven
          2.0.9开始，超级<acronym>POM</acronym>为核心插件提供了默认版本。这么做是为那些没有在它们<acronym>POM</acronym>中指定插件版本的用户提供一些稳定性。</para>
        </callout>
      </calloutlist>

      <figure>
        <title>超级POM永远是最基础的父POM</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom-relationships_pom-inherit-simple-super.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>最简单的POM</title>

      <para>所有的Maven
      <acronym>POM</acronym>都继承自超级<acronym>POM</acronym>（在前面的小节<xref
      linkend="section-super-pom" />中介绍）。如果你只是编写一个简单的项目，从<filename
      moreinfo="none">src/main/java</filename>目录的源码生成一个<acronym>JAR</acronym>，想要运行<filename
      moreinfo="none">src/test/java</filename>中的JUnit测试，想要使用<command
      moreinfo="none">mvn
      site</command>构建一个项目站点，你不需要自定义任何东西。在这种情况下，你所需要的，是如<xref
      linkend="ex-simplest-pom" />所示的一个最简单的<acronym>POM</acronym>。这个<acronym>POM</acronym>定义了<varname>groupId</varname>，<varname>artifactId</varname>和<varname>version</varname>：这三项是所有项目都需要的坐标。</para>

      <example id="ex-simplest-pom">
        <title>最简单的POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch08&lt;/groupId&gt;
  &lt;artifactId&gt;simplest-project&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>对一个简单的项目来说，这样一个简单的<acronym>POM</acronym>已经足够了——例如，一个生成一个<acronym>JAR</acronym>文件的Java类库。它不需要和任何其它项目关联，没有任何依赖，也缺少基本的信息如名字和<acronym>URL</acronym>。如果创建了这个文件，然后创建了一个子目录<filename
      moreinfo="none">src/main/java</filename>，并且放入了一些源代码，运行<command
      moreinfo="none">mvn package</command>将会生成一个名为<filename
      moreinfo="none">target/simple-project-1.jar</filename>的<acronym>JAR</acronym>文件。</para>
    </section>

    <section>
      <title>有效POM</title>

      <para>最简单的<acronym>POM</acronym>带给了我们“有效<acronym>POM</acronym>”的概念。由于<acronym>POM</acronym>可以从其它<acronym>POM</acronym>继承配置，你就需要一直考虑超级<acronym>POM</acronym>，再加上任何父<acronym>POM</acronym>，以及最后当前项目的<acronym>POM</acronym>这些所有配置的结合。Maven开始于超级<acronym>POM</acronym>，然后使用一个或多个父<acronym>POM</acronym>覆盖默认配置，最后使用当前项目的<acronym>POM</acronym>来覆盖之前生成的配置结果。最后你得到了一个混合了各个<acronym>POM</acronym>配置的有效<acronym>POM</acronym>。如果你想要查看项目的有效<acronym>POM</acronym>，你需要运行Maven
      Help插件的<varname>effective-pom</varname>目标，该插件已经之前在小节<xref
      linkend="sect-help-plugin-install" />中介绍。在<filename
      moreinfo="none">pom.xml</filename>文件所在的目录执行以下的命令以运行<varname>effective-pom</varname>目标：</para>

      <screen>$ <command>mvn help:effective-pom</command></screen>

      <para>执行<varname>effective-pom</varname>目标应该会打印出一个<acronym>XML</acronym>文档，该文档的内容是超级<acronym>POM</acronym>和<xref
      linkend="ex-simplest-pom" />中<acronym>POM</acronym>内容的合并。</para>
    </section>

    <section>
      <title>真正的POM</title>

      <para>这里我们就不再设计一组<acronym>POM</acronym>，<indexterm>
          <primary>real POMs</primary>
        </indexterm>一步步的来看了，你可以自己查看一下<xref
      linkend="part-example" />中的样例。Maven就像是变色龙，你可以挑选你想要使用的特性。对于一些开源项目来说，列出开发者和贡献者，生成整洁的项目文档，使用Maven
      Release插件来自动管理版本发布可能很有价值。另一方面，一些在大公司环境下的小型团队中工作的人可能对Maven的分发管理功能或者开发成员列表功能不感兴趣。本章的剩余部分将会单独的讨论<acronym>POM</acronym>的特性。我们不会用数十页的一组相关<acronym>POM</acronym>来炮轰你，而会关注为<acronym>POM</acronym>中的某个特定的部分创建良好的参考。本章，我们也会讨论<acronym>POM</acronym>之间的关系，但不会在这里展示这样一个项目。如果你想要看这样一个示例，请参考<xref
      linkend="multimodule-web-spring" />。</para>
    </section>
  </section>

  <section>
    <title>POM语法</title>

    <para>Maven项目<indexterm class="startofrange" id="pom2">
        <primary>POM (Project Object Model)</primary>

        <secondary>syntax</secondary>
      </indexterm>中<acronym>POM</acronym>的永远都是基础目录下的一个名为<filename
    moreinfo="none">pom.xml</filename>的文件。这个<acronym>XML</acronym>文档可以以<acronym>XML</acronym>声明开头，或者你也可以选择忽略它。所有的<acronym>POM</acronym>的值都通过<acronym>XML</acronym>元素的形式体现。</para>

    <section id="sect-versions">
      <title>项目版本</title>

      <para>一个Maven项目的<sgmltag>version</sgmltag><indexterm>
          <primary>major versions (projects)</primary>
        </indexterm><indexterm>
          <primary>minor versions (projects)</primary>
        </indexterm><indexterm>
          <primary>incremental versions (projects)</primary>
        </indexterm><indexterm>
          <primary>qualifiers for project versions</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <seealso>version attribute</seealso>
        </indexterm><indexterm>
          <primary>version attribute (pom.xml)</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>
        </indexterm>对一个用来分组和排序发布的发布版本号编码。Maven中的版本包含了一下部分：主版本，次版本，增量版本，和限定版本号。一个版本中，这些部分对应如下的格式：</para>

      <screen>&lt;major version&gt;.&lt;minor version&gt;.&lt;incremental version&gt;-&lt;qualifier&gt;
</screen>

      <para>例如：版本“1.3.5”由一个主版本1，一个次版本3，和一个增量版本5。而一个版本“5”只有主版本5，没有次版本和增量版本。限定版本用来标识里程碑构建：alpha和beta发布，限定版本通过连字符与主版本，次版本或增量版本隔离。例如，版本“1.3-beta-01”有一个主版本1，次版本3，和一个限定版本“beta-01”。</para>

      <para>当你想要在你的<acronym>POM</acronym>中使用版本界限的时候，保持你的版本号与标准一致十分重要。在<xref
      linkend="section-version-ranges" />中介绍的版本界限，允许你声明一个带有版本界限的依赖，只有你遵循标准的时候该功能才被支持。因为Maven根据本节中介绍的版本号格式来对版本进行排序。</para>

      <para>如果你的版本号与格式&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;限定版本&gt;相匹配，它就能被正确的比较；“1.2.3”将被评价成是一个比“1.0.2”更新的构件，这种比较基于主版本，次版本，和增量版本的数值。如果你的版本发布号没有符合本节介绍的标准，那么你的版本号只会根据字符串被比较；“1.0.1b”和“1.2.0b”会使用字符串比较。</para>

      <section>
        <title>版本构建号</title>

        <para>我们还需要对版本号的<indexterm>
            <primary>ordering of version qualifiers</primary>
          </indexterm><indexterm>
            <primary>qualifiers for project versions</primary>

            <secondary>ordering of</secondary>
          </indexterm>限定版本进行排序。以版本号“1.2.3-alpha-2”和“1.2.3-alpha-10”为例，这里“alpha-2”对应了第二次alpha构建，而“alpha-10”对应了第十次alpha构建。虽然“alpha-10”应该被认为是比“alpha-2”更新的构建，但Maven排序的结果是“alpha-10”比“alpha-2”更旧，问题的原因就是我们刚才讨论的Maven处理版本号的方式。</para>

        <para>Maven会将限定版本后面的数字认作一个构建版本。换句话说，这里限定版本是“alpha”，而构建版本是2。虽然Maven被设计成将构建版本和限定版本分离，但目前这种解析还是失效的。因此，“alpha-2”和“alpha-10”是使用字符串进行比较的，而根据字母和数字“alpha-10”在“alpha-2”前面。要避开这种限制，你需要对你的限定版本使用一些技巧。如果你使用“alpha”和“alpha-10”，这个问题就消除了，一旦Maven能正确的解析版本构建号之后，这种工作方式也还是能用。</para>
      </section>

      <section>
        <title>SNAPSHOT版本</title>

        <para>Maven版本可以包含一个字符串字面量来表示项目<indexterm>
            <primary>snapshot versions</primary>
          </indexterm>正处于活动的开发状态。如果一个版本包含字符串“SNAPSHOT”，Maven就会在安装或发布这个组件的时候将该符号展开为一个日期和时间值，转换为<acronym>UTC</acronym>（协调世界时）。例如，如果你的项目有个版本为“1.0-SNAPSHOT”并且你将这个项目的构件部署到了一个Maven仓库，如果你在<acronym>UTC</acronym>2008年2月7号下午11:08部署了这个版本，Maven就会将这个版本展开成“1.0-20080207-230803-1”。换句话说，当你打不一个snapshot，你没有发布一个软件模块，你只是发布了一个特定时间的快照版本。</para>

        <para>那么为什么要使用这种方式呢？SNAPSHOT版本在项目活动的开发过程中使用。如果你的项目依赖的一个组件正处于开发过程中，你可以依赖于一个SNAPSHOT版本，在你运行构建的时候Maven会定期的从仓库下载最新的snapshot。类似的，如果你系统的下一个发布版本是“1.4”你的项目需要拥有一个“1.4-SNAPSHOT”的版本，之后它被正式发布。</para>

        <para>作为一个默认设置，Maven不会从远程仓库检查SNAPSHOT版本，要依赖于SNAPSHOT版本，用户必须在<acronym>POM</acronym>中使用<sgmltag>repository</sgmltag>和<sgmltag>pluginRepository</sgmltag>元素显式的开启下载snapshot的功能。</para>

        <para>当发布一个项目的时候，你需要解析所有对SNAPSHOT版本的依赖至正式发布的版本。如果一个项目依赖于SNAPSHOT，那么这个依赖很不稳定，它随时可能变化。发布到非snapshot的Maven仓库（如<ulink
        url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>）的构件不能依赖于任何SNAPSHOT版本，因为Maven的超级<acronym>POM</acronym>对于中央仓库关闭了snapshot。SNAPSHOT版本只用于开发过程。</para>
      </section>

      <section>
        <title>LATEST 和 RELEASE 版本</title>

        <para>当你依赖于一个插件或一个依赖，你可以使用特殊的版本值LATEST或者RELEASE。LATEST是指某个特定构件最新的发布版或者快照版(snapshot)，最近被部署到某个特定仓库的构件。RELEASE是指仓库中最后的一个非快照版本。总得来说，设计软件去依赖于一个构件的不明确的版本，并不是一个好的实践。如果你正在开发软件，你可能想要使用RELEASE或者LATEST，这么做十分方便，你也不用为每次一个第三方类库新版本的发布而去更新你配置的版本号。当你发布软件的时候，你总是应该确定你的项目依赖于某个特定的版本，以减少构建的不确定性，免得被其它不受你控制的软件版本影响。如果无论如何你都要使用LATEST和RELEASE，那么要小心使用。</para>

        <para>Maven
        2.0.9之后，Maven在超级POM中锁住了一些通用及核心Maven插件的版本号，以将某个特定版本Maven的核心Maven插件组标准化。这个变化在Maven
        2.0.9中被引入，为Maven构建带来了稳定性和重现性。在Maven
        2.0.9之前，Maven会自动将核心插件更新至LATEST版本。这种行为导致了很多奇怪现象，因为新版本的插件可能会有一些bug，甚至是行为变更，这往往使得原来的构建失败。当Maven自动更新核心插件的时候，我们就不能保证构件的重现性，因为插件随时都可能从中央仓库更新至一个新的版本。从Maven
        2.0.9开始，Maven从根本上锁住了一组核心插件的版本。非核心插件，或者说没有在超级POM中指定版本的插件仍然会使用LATEST版本去从仓库获取构件。由于这个原因，你在构件中使用任何一个自定义非核心插件的时候，都应该显式的指定版本号。</para>
      </section>
    </section>

    <section>
      <title>属性引用</title>

      <para>一个<acronym>POM</acronym>可以通过一对大括弧和前面一个美元符号来包含 <indexterm>
          <primary>properties</primary>

          <secondary>referencing in pom.xml</secondary>
        </indexterm><indexterm>
          <primary>references to properties, in pom.xml</primary>
        </indexterm>对属性的引用。例如，考虑如下的<acronym>POM</acronym>：</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;build&gt;
    &lt;finalName&gt;${project.groupId}-${project.artifactId}&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>如果你将这段<acronym>XML</acronym>放入<filename>pom.xml</filename>，然后运行<command>mvn
      help:effective-pom</command>，你会看到输出包含这一行：</para>

      <programlisting language="xml">...
&lt;finalName&gt;org.sonatype.mavenbook-project-a&lt;/finalName&gt;
...</programlisting>

      <para>在Maven读取一个<acronym>POM</acronym>的时候，它会在载入<acronym>POM</acronym>
      <acronym>XML</acronym>的时候替换这些属性的引用。在Maven的高级使用中Maven属性经常出现，这些属性和其它系统中的属性如Ant或者Velocity类似。它们是一些由<varname>${...}</varname>划界的变量。Maven提供了三个隐式的变量，可以用来访问环境变量，<acronym>POM</acronym>信息，和Maven
      Settings：</para>

      <variablelist>
        <varlistentry>
          <term>env</term>

          <listitem>
            <para><varname>env</varname>变量 <indexterm>
                <primary>env variable</primary>
              </indexterm><indexterm>
                <primary>implicit variables, list of</primary>
              </indexterm>暴露了你操作系统或者shell的环境变量。例如，在Maven
            POM中一个对<varname>${env.PATH}</varname>的引用将会被<varname>${PATH}</varname>环境变量替换（或者Windows中的<varname>%PATH%</varname>）。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>project</term>

          <listitem>
            <para><varname>project</varname>变量暴露了<acronym><indexterm>
                <primary>project variable</primary>
              </indexterm>POM</acronym>。你可以使用点标记（.）的路径来引用<acronym>POM</acronym>元素的值。例如，在本节中我们使用过<varname>groupId</varname>和<varname>artifactId</varname>来设置构建配置中的<sgmltag>finalName</sgmltag>元素。这个属性引用的语法是：<code>${project.groupId}-${project.</code><code>artifactId}</code>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>settings</term>

          <listitem>
            <para><varname>settings</varname>变量暴露了Maven
            settings信息。可以使用点标记（.）的路径来引用<filename
            moreinfo="none">settings.xml</filename>文件中元素的值。例如，<varname>${settings.offline}</varname>会引用<filename
            moreinfo="none">~/.m2/settings.xml</filename>文件中<sgmltag>offline</sgmltag>元素的值。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>你可能在老的构建中看到使用<varname>${pom.xxx}</varname>或者仅仅<varname>${xxx}</varname>来引用<acronym>POM</acronym>属性。这些方法已被弃用，我们只应该使用<varname>${project.xxx}</varname>。</para>
      </note>

      <para>除了这三个隐式的变量，你还可以<indexterm>
          <primary>system properties, referencing</primary>
        </indexterm>引用系统属性，以及任何在Maven
      <acronym>POM</acronym>中和构建profile中自定义的属性组。</para>

      <variablelist>
        <varlistentry>
          <term>Java系统属性</term>

          <listitem>
            <para>所有可以通过<classname>java.lang.System</classname>中<methodname>getProperties()</methodname>方法访问的属性<indexterm>
                <primary>Java system properties, referencing</primary>
              </indexterm>都被暴露成<acronym>POM</acronym>属性。一些系统属性的例子是：<varname>${user.name}</varname>，<varname
            role="keep-together">${user.home}</varname>，<varname>${java.home}</varname>，和<varname>${os.name}</varname>。一个完整的系统属性列表可以在<classname>java.lang.System</classname>类的Javadoc中找到。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para>我们还可以通过<filename
            moreinfo="none">pom.xml</filename>或者<filename moreinfo="none"
            role="keep-together">settings.xml</filename>中的<varname>properties</varname>元素设置自己的属性，或者还可以使用外部载入的文件中属性。如果你在<filename
            moreinfo="none">pom.xml</filename>中设置了一个名为<varname>fooBar</varname>的属性，该属性就可以通过<varname>${fooBar}</varname>引用。当你构建一个系统，它针对不同的部署环境过滤资源，那么自定义属性就变得十分有用。这里是在<acronym>POM</acronym>中设置<literal>${foo}=bar</literal>的语法：</para>

            <programlisting language="xml">&lt;properties&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
&lt;/properties&gt;</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>要了解更复杂的可用属性列表，查看<xref linkend="resource-filtering" />。</para>
    </section>
  </section>

  <section>
    <title>项目依赖</title>

    <para>Maven可以管理内部和外部依赖。<indexterm class="startofrange" id="pom3a">
        <primary>dependencies</primary>
      </indexterm><indexterm>
        <primary>POM (Project Object Model)</primary>

        <secondary>project dependencies</secondary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>project dependencies</primary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>external dependencies</primary>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm>一个Java项目的外部依赖可能是如Plexus，Spring
    Framework，或者Log4J的类库。一个内部的依赖就像在“一个简单的web应用”中描述的那样，web项目依赖于另外一个包含服务类，模型类，或者持久化逻辑的项目。<xref
    linkend="ex-dependency" />展示了一些项目依赖的例子。</para>

    <para><example id="ex-dependency">
        <title>项目依赖</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.xfire&lt;/groupId&gt;
      &lt;artifactId&gt;xfire-java5&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-servlet_2.4_spec&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example></para>

    <para>这里的第一个依赖是一对对于来自Codehaus的XFire
    <acronym>SOAP</acronym>库的编译范围（compile）依赖。如果你的项目在编译，测试，和运行中都依赖于一个类库，你就要使用这种依赖。第二种依赖是一个对于JUnit测试范围（test）的依赖。当你只有在测试的时候才引用类库的时候，你就要使用测试范围依赖。<xref
    linkend="ex-dependency" />中最后一个依赖是对于由Apache Geronimo项目实现的Servlet 2.4
    <acronym>API</acronym>的依赖。最后一项依赖的范围是已提供的（provided）依赖。当你的开发过程只有在编译和测试时需要一个类库，而该类库在运行的时候由容器提供，那么你就需要使用已提供范围的依赖。</para>

    <section id="section-dependency-scope">
      <title>依赖范围</title>

      <para><xref
      linkend="ex-dependency" />简要介绍了三种测试范围：<literal>compile</literal>，<literal>test</literal>，和<literal>provided</literal>。范围控制哪些依赖在哪些classpath中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：</para>

      <variablelist>
        <varlistentry>
          <term>compile（编译范围）</term>

          <listitem>
            <para><literal>compile</literal>是默认的范围；如果没有提供一个范围，那该依赖的范围就是<indexterm>
                <primary>compile dependencies</primary>
              </indexterm>编译范围。编译范围依赖在所有的classpath中可用，同时它们也会被打包。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>provided（已提供范围）</term>

          <listitem>
            <para><literal>provided</literal>依赖只有在当<acronym>JDK</acronym>或者一个容器已提供该依赖之后才使用。例如，如果你开发了一个web应用，你可能在编译classpath中需要可用的Servlet
            <acronym>API</acronym>来编译一个servlet，但是你不会想要在打包好的<acronym>WAR</acronym>中包含这个Servlet
            <acronym>API</acronym>；这个Servlet <acronym>API</acronym>
            <acronym>JAR</acronym>由你的应用服务器或者servlet容器提供。已提供范围的依赖在编译classpath（不是运行时）可用。它们不是传递性的，也不会被打包。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>runtime（运行时范围）</term>

          <listitem>
            <para><literal>runtime</literal>依赖<indexterm>
                <primary>runtime dependencies</primary>
              </indexterm>在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要<acronym>JDBC</acronym>
            <acronym>API</acronym>
            <acronym>JAR</acronym>，而只有在运行的时候才需要<acronym>JDBC</acronym>驱动实现。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>test（测试范围）</term>

          <listitem>
            <para><literal>test</literal>范围依赖<indexterm>
                <primary>dependencies</primary>

                <secondary>test-scoped</secondary>
              </indexterm><indexterm>
                <primary>test-scoped dependencies</primary>
              </indexterm><indexterm>
                <primary>unit tests</primary>

                <secondary>test-scoped dependencies</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>using test-scoped dependencies</secondary>
              </indexterm> 在一般的 编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。测试范围依赖在之前的<xref
            linkend="section-test-scope" />中介绍过。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>system（系统范围）</term>

          <listitem>
            <para><literal>system</literal>范围依赖与<literal>provided</literal>类似，但是你必须显式的提供一个对于本地系统中<acronym>JAR</acronym>文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个<sgmltag>systemPath</sgmltag>元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的Maven仓库中引用依赖）。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>可选依赖</title>

      <para>假定你正在开发一个类库 <indexterm>
          <primary>optional dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>optional</secondary>
        </indexterm>，该类库提供高速缓存行为。你想要使用一些已存在的能够提供文件系统快速缓存和分布式快速缓存的类库，而非从空白开始写自己的快速缓存系统。再假定你想要给最终用户选择使用文件系统告诉缓存或者而是用内存分布式高速缓存。为了缓存文件系统，你会要使用免费的类库如EHCache（<ulink
      url="http://ehcache.sourceforge.net/">http://ehcache.sourceforge.net/</ulink>），为了分布式内存缓存，你想要使用免费的类库如SwarmCache（<ulink
      url="http://swarmcache.sourceforge.net/">http://swarmcache.sourceforge.net/</ulink>）。你将编写一个接口，并且创建一个可以被配置成使用EHCache或者SwarmCache的类库，但是你想要避免为所有依赖于你类库的项目添加全部这两个缓存类库的的依赖。</para>

      <para>换句话说，编译这个项目的时候你需要两个依赖类库，但是你不希望在使用你类库的项目中，这两个依赖类库同时作为传递性运行时依赖出现。你可以使用如<xref
      linkend="ex-optional-depend" />中的可选依赖来完成这个任务。</para>

      <example id="ex-optional-depend">
        <title>声明可选依赖</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;swarmcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.0RC2&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.13&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>在你将这些依赖声明为可选之后，你就需要在依赖于<varname>my-project</varname>的项目中显式的引用对应的依赖。例如，如果你正编写一个应用，它依赖于<varname>my-project</varname>，并且想要使用EHCache实现，你就需要在你项目添加如下的<sgmltag>dependency</sgmltag>元素。</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-application&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

      <para>在理想的世界中，你不需要使用可选依赖。你可以将EHCache相关的代码放到<varname>my-project-ehcache</varname>子模块中，将SwarmCache相关的代码放到<varname>my-project-swarmcache</varname>子模块中，而非创建一个带有一系列可选依赖的大项目。这样，其它项目就可以只引用特定实现的项目，发挥传递性依赖的功效，而不用去引用<varname>my-project</varname>项目，再自己声明特定的依赖。</para>
    </section>

    <section id="section-version-ranges">
      <title>依赖版本界限</title>

      <para>You don’t just have to depend on a specific version of a<indexterm>
          <primary>version attribute (pom.xml)</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>ranges for dependency versions</primary>
        </indexterm> dependency; you can specify a range of versions that
      would satisfy a given dependency. For example, you can specify that your
      project depends on version 3.8 or greater of JUnit, or anything between
      versions 1.2.10 and 1.2.14 of JUnit. You do this by surrounding one or
      more version numbers with the following characters:</para>

      <variablelist>
        <varlistentry>
          <term role="plain">(, )</term>

          <listitem>
            <para>Exclusive quantifiers</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term role="plain">[, ]</term>

          <listitem>
            <para>Inclusive quantifiers</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For example, if you wished to access any <code>JUnit</code>
      version greater than or equal to 3.8 but less than 4.0, your dependency
      would be as shown in <xref linkend="ex-dep-range" />.</para>

      <para><example id="ex-dep-range">
          <title>Specifying a Dependency Range: JUnit 3.8 - JUnit 4.0</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[3.8,4.0)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
        </example></para>

      <para>If you want to depend on any version of JUnit no higher
      than<indexterm>
          <primary>upper boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>inclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>lower boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>exclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>boundaries for version ranges, specifying</primary>
        </indexterm> 3.8.1, you would specify only an upper inclusive
      boundary, as shown in <xref linkend="ex-dep-range-2" />.</para>

      <example id="ex-dep-range-2">
        <title>Specifying a Dependency Range: JUnit &lt;= 3.8.1</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[,3.8.1]&lt;/version&gt;ex-de
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>A version before or after the comma is not required, and means +/-
      infinity. For example, "[4.0,)" means any version greater than or equal
      to 4.0. "(,2.0)" is any version less than 2.0. "[1.2]" means only
      version 1.2, and nothing else.</para>

      <note>
        <para>When declaring a "normal" version such as 3.8.2 for Junit,
        internally this is represented as "allow anything, but prefer 3.8.2."
        This means that when a conflict is detected, Maven is allowed to use
        the conflict algorithms to choose the best version. If you specify
        [3.8.2], it means that only 3.8.2 will be used and nothing else. If
        somewhere else there is a dependency that specifies [3.8.1], you would
        get a build failure telling you of the conflict. We point this out to
        make you aware of the option, but use it sparingly and only when
        really needed. The preferred way to resolve this is via
        <sgmltag>dependencyManagement</sgmltag>.</para>
      </note>
    </section>

    <section>
      <title>传递性依赖</title>

      <para>A transitive dependency is a dependency of a dependency.
      If<indexterm>
          <primary>transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>transitive</secondary>

          <see>transitive dependencies</see>
        </indexterm> <varname>project-a</varname> depends on
      <varname>project-b</varname>, which in turn depends on
      <varname>project-c</varname>, then <varname>project-c</varname> is
      considered a transitive dependency of <varname>project-a</varname>. If
      <varname>project-c</varname> depended on <varname>project-d</varname>,
      then <varname>project-d</varname> would also be considered a transitive
      dependency of <varname>project-a</varname>. Part of Maven’s appeal is
      that it can manage transitive dependencies and shield the developer from
      having to keep track of all of the dependencies required to compile and
      run an application. You can just depend on something like the Spring
      Framework and not have to worry about tracking down every last
      dependency of the Spring Framework.</para>

      <para>Maven accomplishes this by building a graph of dependencies and
      dealing with any conflicts and overlaps that might occur. For example,
      if Maven sees that two projects depend on the same
      <varname>groupId</varname> and <varname>artifactId</varname>, it will
      sort out which dependency to use automatically, always favoring the more
      recent version of a dependency. Although this sounds convenient, there
      are some edge cases where transitive dependencies can cause some
      configuration issues. For these scenarios, you can use a dependency
      exclusion.</para>

      <section>
        <title>传递性依赖和范围</title>

        <para>Each of the scopes outlined earlier in the section <xref
        linkend="section-dependency-scope" />” affects not just the scope of
        <indexterm>
            <primary>scope, dependency</primary>

            <secondary>transitive dependencies and</secondary>
          </indexterm>the dependency in the declaring project, but also how it
        acts as a transitive dependency. The easiest way to convey this
        information is through a table, as in <xref
        linkend="table-transitive-dep-and-scope" />. Scopes in the top row
        represent the scope of a transitive dependency. Scopes in the leftmost
        column represent the scope of a direct dependency. The intersection of
        the row and column is the scope that is assigned to a transitive
        dependency. A blank cell in this table means that the transitive
        dependency will be omitted.</para>

        <para><table id="table-transitive-dep-and-scope">
            <title>How Scope Affects Transitive Dependencies</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry>Direct Scope</entry>

                  <entry>Transitive Scope</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry></entry>

                  <entry><emphasis>compile</emphasis></entry>

                  <entry><emphasis>provided</emphasis></entry>

                  <entry><emphasis>runtime</emphasis></entry>

                  <entry><emphasis>test</emphasis></entry>
                </row>

                <row>
                  <entry><emphasis>compile</emphasis></entry>

                  <entry>compile</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>provided</emphasis></entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>runtime</emphasis></entry>

                  <entry>runtime</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>test</emphasis></entry>

                  <entry>test</entry>

                  <entry>-</entry>

                  <entry>test</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>To illustrate the relationship of transitive dependency scope to
        direct dependency scope, consider the following example. If
        <varname>project-a</varname> contains a test scoped dependency on
        <varname>project-b</varname> which contains a compile scoped
        dependency on <varname>project-c</varname>.
        <varname>project-c</varname> would be a test-scoped transitive
        dependency of <varname>project-a</varname>.</para>

        <para>You can think of this as a transitive boundary which acts as a
        filter on dependency scope. Transitive dependencies which are provided
        and test scope usually do not affect a project. The exception to this
        rule is that a provided scoped transitive dependency to a provided
        scope direct dependency is still a provided dependency of a project.
        Transitive dependencies which are compile and runtime scoped usually
        affect a project regardless of the scope of a direct dependency.
        Transitive dependencies which are compile scoped will have the same
        scope irregardless of the scope of the direct dependency. Transitive
        dependencies which are runtime scoped will generally have the same
        scope of the direct dependency except when the direct dependency has a
        scope of compile. When a transitive dependency is runtime scoped and a
        direct is compile scoped the direct dependency the transitive
        dependency will have an effective scope of runtime.</para>
      </section>
    </section>

    <section>
      <title>冲突解决</title>

      <para>There will be times when you need to exclude a
      transitive<indexterm>
          <primary>conflict, dependency</primary>
        </indexterm><indexterm>
          <primary>resolving dependency conflicts</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>conflicts with, resolving</secondary>
        </indexterm><indexterm>
          <primary>transitive dependencies</primary>

          <secondary>resolving conflicts with</secondary>
        </indexterm><indexterm>
          <primary>excluding transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>replacing transitive dependencies</primary>
        </indexterm> dependency, such as when you are depending on a project
      that depends on another project, but you would like to either exclude
      the dependency altogether or replace the transitive dependency with
      another dependency that provides the same functionality. <xref
      linkend="ex-exclude" /> shows an example of a dependency element that
      adds a dependency on <varname>project-a</varname>, but excludes the
      transitive dependency <varname>project-b</varname>.</para>

      <para><example id="ex-exclude">
          <title>Excluding a Transitive Dependency</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;project-b&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
        </example></para>

      <para>Often, you will want to replace a transitive dependency with
      another implementation. For example, if you are depending on a library
      that depends on the Sun <acronym>JTA</acronym> <acronym>API</acronym>,
      you may want to replace the declared transitive dependency. Hibernate is
      one example. Hibernate depends on the Sun <acronym>JTA</acronym>
      <acronym>API</acronym> <acronym>JAR</acronym>, which is not available in
      the central Maven repository because it cannot be freely redistributed.
      Fortunately, the Apache Geronimo project has created an independent
      implementation of this library that can be freely redistributed. To
      replace a transitive dependency with another dependency, you would
      exclude the transitive dependency and declare a dependency on the
      project you wanted instead. <xref linkend="ex-exclude-replace" /> shows
      an example of a such replacement.</para>

      <example id="ex-exclude-replace">
        <title>Excluding and Replacing a Transitive Dependency</title>

        <programlisting language="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
    &lt;version&gt;3.2.5.ga&lt;/version&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </example>

      <para>In <xref linkend="ex-exclude-replace" />, there is nothing marking
      the dependency on <varname>geronimo-jta_1.1_spec</varname> as a
      replacement, it just happens to be a library which provides the same
      <acronym>API</acronym> as the original <acronym>JTA</acronym>
      dependency. Here are some other reasons you might want to exclude or
      replace transitive dependencies:</para>

      <orderedlist>
        <listitem>
          <para>The <varname>groupId</varname> or
          <varname>artifactId</varname> of the artifact has changed, where the
          current project requires an alternately named version from a
          dependency's version - resulting in 2 copies of the same project in
          the classpath. Normally Maven would capture this conflict and use a
          single version of the project, but when <varname>groupId</varname>
          or <varname>artifactId</varname> are different, Maven will consider
          this to be two different libraries.</para>
        </listitem>

        <listitem>
          <para>An artifact is not used in your project and the transitive
          dependency has not been marked as an optional dependency. In this
          case, you might want to exclude a dependency because it isn't
          something your system needs and you are trying to cut down on the
          number of libraries distributed with an application.</para>
        </listitem>

        <listitem>
          <para>An artifact which is provided by your runtime container thus
          should not be included with your build. An example of this is if a
          dependency depends on something like the Servlet API and you want to
          make sure that the dependency is not included in a web application's
          <filename>WEB-INF/lib</filename> directory.</para>
        </listitem>

        <listitem>
          <para>To exclude a dependency which might be an
          <acronym>API</acronym> with multiple implementations. This is the
          situation illustrated by <xref linkend="ex-exclude-replace" />;
          there is a Sun <acronym>API</acronym> which requires click-wrap
          licensing and a time-consuming manual install into a custom
          repository (Sun's <acronym>JTA</acronym> <acronym>JAR</acronym>)
          versus a freely distributed version of the same
          <acronym>API</acronym> available in the central Maven repository
          (Geronimo's <acronym>JTA</acronym> implementation).</para>
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>依赖管理</title>

      <para>Once you've adopted Maven at your super complex enterprise and you
      have two hundred and twenty inter-related Maven projects, you are going
      to start wondering if there is a better way to get a handle on
      dependency versions. If every single project that uses a dependency like
      the MySQL Java connector needs to independently list the version number
      of the dependency, you are going to run into problems when you need to
      upgrade to a new version. Because the version numbers are distributed
      throughout your project tree, you are going to have to manually edit
      each of the <filename>pom.xml</filename> files that reference a
      dependency to make sure that you are changing the version number
      everywhere. Even with <command>find</command>, <command>xargs</command>,
      and <command>awk</command>, you are still running the risk of missing a
      single <acronym>POM</acronym>.</para>

      <para>Luckily, Maven provides a way for you to consolidate dependency
      version numbers in the <sgmltag>dependencyManagement</sgmltag> element.
      You'll usually see the <sgmltag>dependencyManagement</sgmltag> element
      in a top-level parent <acronym>POM</acronym> for an organization or
      project. Using the <sgmltag>dependencyManagement</sgmltag> element in a
      <filename>pom.xml</filename> allows you to reference a dependency in a
      child project without having to explicitly list the version. Maven will
      walk up the parent-child hierarchy until it finds a project with a
      <sgmltag>dependencyManagement</sgmltag> element, it will then use the
      version specified in this <sgmltag>dependencyManagement</sgmltag>
      element.</para>

      <para>For example, if you have a large set of projects which make use of
      the MySQL Java connector version 5.1.2, you could define the following
      <sgmltag>dependencyManagement</sgmltag> element in your multi-module
      project's top-level <acronym>POM</acronym>.</para>

      <para><example>
          <title>Defining Dependency Versions in a Top-level POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  ...
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.2&lt;/version&gt;
      &lt;/dependency&gt;
      ...
    &lt;dependencies&gt;
  &lt;/dependencyManagement&gt;
</programlisting>

          <para>Then, in a child project, you can add a dependency to the
          MySQL Java Connector using the following dependency
          <acronym>XML</acronym>:</para>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

          <para>You should notice that the child project did not have to
          explicitly list the version of the
          <varname>mysql-connector-java</varname> dependency. Because this
          dependency was defined in the top-level <acronym>POM</acronym>'s
          <sgmltag>dependencyManagement</sgmltag> element, the version number
          is going to propagate to the child project's dependency on
          <varname>mysql-connector-java</varname>. Note that if this child
          project did define a version, it would override the version listed
          in the top-level <acronym>POM</acronym>'s
          <sgmltag>dependencyManagement</sgmltag> section. That is, the
          <sgmltag>dependencyManagement</sgmltag> version is only used when
          the child does not declare a version directly.</para>

          <para>Dependency management in a top-level <acronym>POM</acronym> is
          different from just defining a dependency on a widely shared parent
          <acronym>POM</acronym>. For starters, all dependencies are
          inherited. If <varname>mysql-connector-java</varname> were listed as
          a dependency of the top-level parent project, every single project
          in the hierarchy would have a reference to this dependency. Instead
          of adding in unnecessary dependencies, using
          <sgmltag>dependencyManagement</sgmltag> allows you to consolidate
          and centralize the management of dependency versions without adding
          dependencies which are inherited by all children. In other words,
          the <sgmltag>dependencyManagement</sgmltag> element is equivalent to
          an environment variable which allows you to declare a dependency
          anywhere below a project without specifying a version number.</para>
        </example></para>
    </section>
  </section>

  <section>
    <title>项目关系</title>

    <para>One of the compelling reasons to use Maven is that it makes the
    process of tracking down dependencies (and dependencies of dependencies)
    very easy. When a project depends on an artifact produced by another
    project we say that this artifact is a dependency. In the case of a Java
    project, this can be as simple as a project depending on an external
    dependency like Log4J or JUnit. While dependencies can model external
    dependencies, they can also manage the dependencies between a set of
    related projects, if <varname>project-a</varname> depends on
    <varname>project-b</varname>, Maven is smart enough to know that
    <varname>project-b</varname> must be built before
    <varname>project-a</varname>.</para>

    <para>Relationships are not only about dependencies and figuring out what
    one project needs to be able to build an artifact. Maven can model the
    relationship of a project to a parent, and the relationship of a project
    to submodules. This section gives an overview of the various relationships
    between projects and how such relationships are configured.</para>

    <section id="sect-more-coordinates">
      <title>坐标详解</title>

      <para>Coordinates define a unique location for a project, they were
      first introduced in <xref linkend="simple-project" />. Projects are
      related to one another using Maven Coordinates. project-a doesn't just
      depend on project-b; a project with a groupId, artifactId, and version
      depends on another project with a groupId, artifactId, and version. To
      review, a Maven Coordinate is made up of three components:</para>

      <variablelist>
        <varlistentry>
          <term>groupId</term>

          <listitem>
            <para>A <varname>groupId</varname> groups a set of related
            artifacts. Group identifiers generally resemble a Java package
            name. For example, the <varname>groupId</varname>
            <varname>org.apache.maven</varname> is the base groupId for all
            artifacts produced by the Apache Maven project. Group identifiers
            are translated into paths in the Maven Repository; for example,
            the org.apache.maven groupId can be found in
            <filename>/maven2/org/apache/maven</filename> on <ulink
            url="http://repo1.maven.org/maven2/org/apache/maven">repo1.maven.org</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>artifactId</term>

          <listitem>
            <para>The <varname>artifactId</varname> is the project's main
            identifier. When you generate an artifact, this artifact is going
            to be named with the <varname>artifactId</varname>. When you refer
            to a project, you are going to refer to it using the
            <varname>artifactId</varname>. The <varname>artifactId</varname>,
            <varname>groupId</varname> combination must be unique. In other
            words, you can't have two separate projects with the same
            <varname>artifactId</varname> and <varname>groupId</varname>;
            <varname>artifactId</varname>s are unique within a particular
            <varname>groupId</varname>.</para>

            <note>
              <para>While '.'s are commonly used in
              <varname>groupId</varname>s, you should try to avoid using them
              in <varname>artifactId</varname>s. This can cause issues when
              trying to parse a fully qualified name down into the
              subcomponents.</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>version</term>

          <listitem>
            <para>When an artifact is released, it is released with a version
            number. This version number is a numeric identifier such as "1.0",
            "1.1.1", or "1.1.2-alpha-01". You can also use what is known as a
            snapshot version. A snapshot version is a version for a component
            which is under development, snapshot version numbers always end in
            SNAPSHOT; for example, "1.0-SNAPSHOT", "1.1.1-SNAPSHOT", and
            "1-SNAPSHOT". <xref linkend="sect-versions" /> introduces versions
            and version ranges.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>There is a fourth, less-used qualifier:</para>

      <variablelist>
        <varlistentry>
          <term>classifier</term>

          <listitem>
            <para>You would use a classifier if you were releasing the same
            code but needed to produce two separate artifacts for technical
            reasons. For example, if you wanted to build two separate
            artifacts of a <acronym>JAR</acronym>, one compiled with the Java
            1.4 compiler and another compiled with the Java 6 compiler, you
            might use the classifier to produce two separate
            <acronym>JAR</acronym> artifacts under the same
            groupId:artifactId:version combination. If your project uses
            native extensions, you might use the classifier to produce an
            artifact for each target platform. Classifiers are commonly used
            to package up an artifact's sources, JavaDocs or binary
            assemblies.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>When we talk of dependencies in this book, we often use the
      following shorthand notation to describe a dependency:
      <varname>groupId</varname>:<varname>artifactId</varname>:<varname>version</varname>.
      To refer to the 2.5 release of the Spring Framework, we would refer to
      it as <varname>org.springframework:spring:2.5</varname>. When you ask
      Maven to print out a list of dependencies with the Maven Dependency
      plugin, you will also see that Maven tends to print out log messages
      with this shorthand dependency notation.</para>
    </section>

    <section>
      <title>多模块项目</title>

      <para>Multi-module projects are projects which contain a list of modules
      to build. A multi-module project always has a packaging of pom, and
      rarely produces an artifact. A multi-module project exists only to group
      projects together in a build. <xref linkend="fig-multiproject" /> shows
      a project hierarchy which includes two parent projects with packaging of
      <varname>pom</varname>, and three projects with packaging of
      <varname>jar</varname>.</para>

      <para><figure id="fig-multiproject">
          <title>Multi-module Project Relationships</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_multimodule.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The directory structure on the file system would also mirror the
      module relationships. A set of projects illustrated by <xref
      linkend="fig-multiproject" /> would have the following directory
      structure:</para>

      <programlisting>top-group/pom.xml
top-group/sub-group/pom.xml
top-group/sub-group/project-a/pom.xml
top-group/sub-group/project-b/pom.xml
top-group/project-c/pom.xml</programlisting>

      <para>The projects are related to one another because
      <varname>top-group</varname> and <varname>sub-group</varname> are
      referencing <varname>sub-modules</varname> in a <acronym>POM</acronym>.
      For example, the <varname>org.sonatype.mavenbook:top-group</varname>
      project is a multi-module project with packaging of type
      <varname>pom</varname>. <varname>top-group</varname>'s
      <filename>pom.xml</filename> would include the following modules
      element:</para>

      <example>
        <title>top-group modules element</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;top-group&lt;/artifactId&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;sub-group&lt;/module&gt;
    &lt;module&gt;project-c&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>When Maven is reading <varname>top-group</varname>
      <acronym>POM</acronym> it will look at the modules element and see that
      <varname>top-group</varname> references the projects
      <varname>sub-group</varname> and <varname>project-c</varname>. Maven
      will then look for a <filename>pom.xml</filename> in each of these
      subdirectories. Maven repeats this process for each of the submodules:
      it will read the <filename>sub-group/pom.xml</filename> and see that the
      <varname>sub-group</varname> project references two projects with the
      following modules element:</para>

      <example>
        <title>sub-group modules element</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;project-a&lt;/module&gt;
    &lt;module&gt;project-b&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Note that we call the projects under the multi-module projects
      "modules" and not "children" or "child projects". This is purposeful, so
      as not to confuse projects grouped by multi-module projects with
      projects that inherit <acronym>POM</acronym> information from each
      other.</para>
    </section>

    <section>
      <title>项目继承</title>

      <para>There are going to be times when you want a project to inherit
      values from a parent POM. You might be building a large system, and you
      don't want to have to repeat the same dependency elements over and over
      again. You can avoid repeating yourself if your projects make use of
      inheritance via the parent element. When a project specifies a parent,
      it inherits the information in the parent project's POM. It can then
      override and add to the values specified in this parent POM.</para>

      <para>All Maven <acronym>POM</acronym>s inherit values from a parent
      <acronym>POM</acronym>. If a <acronym>POM</acronym> does not specify a
      direct parent using the <sgmltag>parent</sgmltag> element, that
      <acronym>POM</acronym> will inherit values from the Super
      <acronym>POM</acronym>. <xref linkend="ex-inheritance" /> shows the
      <sgmltag>parent</sgmltag> element of <varname>project-a</varname> which
      inherits the <acronym>POM</acronym> defined by the
      <varname>a-parent</varname> project.</para>

      <example id="ex-inheritance">
        <title>Project Inheritance</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.training.killerapp&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example>

      <para>Running <command>mvn help:effective-pom</command> in
      <varname>project-a</varname> would show a <acronym>POM</acronym> that is
      the result of merging the Super <acronym>POM</acronym> with the
      <acronym>POM</acronym> defined by <varname>a-parent</varname> and the
      <acronym>POM</acronym> defined in <varname>project-a</varname>. The
      implicit and explicit inheritance relationships for
      <varname>project-a</varname> are shown in <xref
      linkend="fig-inheritance" />.<figure id="fig-inheritance">
          <title>Project Inheritance for a-parent and project-a</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_inheritance.png" />
            </imageobject>
          </mediaobject>
        </figure>When a project specifies a parent project, Maven uses that
      parent <acronym>POM</acronym> as a starting point before it reads the
      current project's <acronym>POM</acronym>. It inherits everything,
      including the <varname>groupId</varname> and <varname>version</varname>
      number. You'll notice that <varname>project-a</varname> does not specify
      either, both <varname>groupId</varname> and <varname>version</varname>
      are inherited from <varname>a-parent</varname>. With a parent element,
      all a <acronym>POM</acronym> really needs to define is an
      <varname>artifactId</varname>. This isn't mandatory,
      <varname>project-a</varname> could have a different
      <varname>groupId</varname> and <varname>version</varname>, but by not
      providing values, Maven will use the values specified in the parent
      <acronym>POM</acronym>. If you start using Maven to manage and build
      large multi-module projects, you will often be creating many projects
      which share a common <varname>groupId</varname> and
      <varname>version</varname>.</para>

      <para>When you inherit a <acronym>POM</acronym>, you can choose to live
      with the inherited <acronym>POM</acronym> information or to selectively
      override it. The following is a list of items a Maven
      <acronym>POM</acronym> inherits from its parent
      <acronym>POM</acronym>:</para>

      <itemizedlist>
        <listitem>
          <para>identifiers (at least one of <varname>groupId</varname> or
          <varname>artifactId</varname> must be overridden.)</para>
        </listitem>

        <listitem>
          <para>dependencies</para>
        </listitem>

        <listitem>
          <para>developers and contributors</para>
        </listitem>

        <listitem>
          <para>plugin lists</para>
        </listitem>

        <listitem>
          <para>reports lists</para>
        </listitem>

        <listitem>
          <para>plugin executions (executions with matching ids are
          merged)</para>
        </listitem>

        <listitem>
          <para>plugin configuration</para>
        </listitem>
      </itemizedlist>

      <para>When Maven inherits dependencies, it will add dependencies of
      child projects to the dependencies defined in parent projects. You can
      use this feature of Maven to specify widely used dependencies across all
      projects which inherit from a top-level <acronym>POM</acronym>. For
      example, if your system makes universal use of the Log4J logging
      framework, you can list this dependency in your top-level
      <acronym>POM</acronym>. Any projects which inherit
      <acronym>POM</acronym> information from this project will automatically
      have Log4J as a dependency. Similarly, if you need to make sure that
      every project is using the same version of a Maven plugin, you can list
      this Maven plugin version explicitly in a top-level parent
      <acronym>POM</acronym>'s <sgmltag>pluginManagement</sgmltag>
      section.</para>

      <para>Maven assumes that the parent <acronym>POM</acronym> is available
      from the local repository, or available in the parent directory
      (<filename>../pom.xml</filename>) of the current project. If neither
      location is valid this default behavior may be overridden via the
      <sgmltag>relativePath</sgmltag> element. For example, some organizations
      prefer a flat project structure where a parent project's
      <filename>pom.xml</filename> isn't in the parent directory of a child
      project. It might be in a sibling directory to the project. If your
      child project were in a directory <filename>./project-a</filename> and
      the parent project were in a directory named
      <filename>./a-parent</filename>, you could specify the relative location
      of <varname>parent-a</varname>'s <acronym>POM</acronym> with the
      following configuration:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../a-parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
&lt;/project&gt;</programlisting>
    </section>
  </section>

  <section>
    <title>POM最佳实践</title>

    <para>Maven can be used to manage everything from simple, single-project
    systems to builds that involve hundreds of inter-related submodules. Part
    of the learning process with Maven isn't just figuring out the syntax for
    configuring Maven, it is learning the "Maven Way"—the current set of best
    practices for organizing and building projects using Maven. This section
    attempts to distill some of this knowledge to help you adopt best
    practices from the start without having to wade through years of
    discussions on the Maven mailing lists.</para>

    <section>
      <title>依赖分组</title>

      <para>If you have a set of dependencies which are logically grouped
      together. You can create a project with pom packaging that groups
      dependencies together. For example, let's assume that your application
      uses Hibernate, a popular Object-Relational mapping framework. Every
      project which uses Hibernate might also have a dependency on the Spring
      Framework and a MySQL <acronym>JDBC</acronym> driver. Instead of having
      to include these dependencies in every project that uses Hibernate,
      Spring, and MySQL you could create a special <acronym>POM</acronym> that
      does nothing more than declare a set of common dependencies. You could
      create a project called <varname>persistence-deps</varname> (short for
      Persistence Dependencies), and have every project that needs to do
      persistence depend on this convenience project:</para>

      <para><example>
          <title>Consolidating Dependencies in a Single POM Project</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;${hibernateVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;${hibernateAnnotationsVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hibernate3&lt;/artifactId&gt;
      &lt;version&gt;${springVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;${mysqlVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;mysqlVersion&gt;(5.1,)&lt;/mysqlVersion&gt;
    &lt;springVersion&gt;(2.0.6,)&lt;/springVersion&gt;
    &lt;hibernateVersion&gt;3.2.5.ga&lt;/hibernateVersion&gt;
    &lt;hibernateAnnotationsVersion&gt;3.3.0.ga&lt;/hibernateAnnotationsVersion&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you create this project in a directory named
      <varname>persistence-deps</varname>, all you need to do is create this
      <filename>pom.xml</filename> and run <command>mvn install</command>.
      Since the packaging type is <varname>pom</varname>, this POM is
      installed in your local repository. You can now add this project as a
      dependency and all of its dependencies will be added to your project.
      When you declare a dependency on this persistence-deps project, don't
      forget to specify the dependency type as pom.</para>

      <para><example>
          <title>Declaring a Dependency on a POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;description&gt;This is a project requiring JDBC&lt;/description&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you later decide to switch to a different
      <acronym>JDBC</acronym> driver (for example, <acronym>JTDS</acronym>),
      just replace the dependencies in the <varname>persistence-deps</varname>
      project to use
      <varname>net.</varname><varname>sourceforge.jtds:jtds</varname> instead
      of <varname>mysql:mysql-java-connector</varname> and update the version
      number. All projects depending on <varname>persistence-deps</varname>
      will use <acronym>JTDS</acronym> if they decide to update to the newer
      version. Consolidating related dependencies is a good way to cut down on
      the length of <filename>pom.xml</filename> files that start having to
      depend on a large number of dependencies. If you need to share a large
      number of dependencies between projects, you could also just establish
      parent-child relationships between projects and refactor all common
      dependencies to the parent project, but the disadvantage of the
      parent-child approach is that a project can have only one parent.
      Sometimes it makes more sense to group similar dependencies together and
      reference a <literal>pom</literal> dependency. This way, your project
      can reference as many of these consolidated dependency
      <acronym>POM</acronym>s as it needs.</para>

      <note>
        <para>Maven uses the depth of a dependency in the tree when resolving
        conflicts using a nearest-wins approach. Using the dependency grouping
        technique above pushes those dependencies one level down in the tree.
        Keep this in mind when choosing between grouping in a pom or using
        <sgmltag>dependenctManagement</sgmltag> in a parent
        <acronym>POM</acronym></para>
      </note>
    </section>

    <section id="sect-multi-vs-inherit">
      <title>多模块 vs. 继承</title>

      <para>There is a difference between inheriting from a parent project
      and<indexterm>
          <primary>multimodule projects, in general</primary>

          <secondary>inheritance versus</secondary>
        </indexterm><indexterm>
          <primary>project inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>inheritance between projects or modules</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>module inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm> being managed by a multimodule project. A parent project
      is one that passes its values to its children. A multimodule project
      simply manages a group of other subprojects or modules. The multimodule
      relationship is defined from the topmost level downwards. When setting
      up a multimodule project, you are simply telling a project that its
      build should include the specified modules. Multimodule builds are to be
      used to group modules together in a single build. The parent-child
      relationship is defined from the leaf node upwards. The parent-child
      relationship deals more with the definition of a particular project.
      When you associate a child with its parent, you are telling Maven that a
      project’s <acronym>POM</acronym> is derived from another.</para>

      <para>To illustrate the decision process that goes into choosing a
      design that uses inheritance vs. multi-module or both approaches
      consider the following two examples: the Maven project used to generate
      this book and a hypothetical project that contains a number of logically
      grouped modules.</para>

      <section>
        <title>简单项目</title>

        <para>First, let's take a look at the maven-book project. The
        inheritance and multi-module relationships are shown in <xref
        linkend="fig-maven-book" />.</para>

        <figure id="fig-maven-book">
          <title>maven-book Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_book-example.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>When we build this Maven book you are reading, we run
        <command>mvn package</command> in a multi-module project named
        <varname>maven-book</varname>. This multi-module project includes two
        submodules: <varname>book-examples</varname> and
        <varname>book-chapters</varname>. Neither of these projects share the
        same parent, they are related only in that they are modules in the
        <varname>maven-book</varname> project.
        <varname>book-examples</varname> builds the <acronym>ZIP</acronym> and
        <acronym>TGZ</acronym> archives you downloaded to get this book's
        example. When we run the <varname>book-examples</varname> build from
        <filename>book-examples/</filename> directory with <command>mvn
        package</command>, it has no knowledge that it is a part of the larger
        <varname>maven-book</varname> project.
        <varname>book-examples</varname> doesn't really care about
        <varname>maven-book</varname>, all it knows in life is that its parent
        is the top-most <varname>sonatype</varname> <acronym>POM</acronym> and
        that it creates an archive of examples. In this case, the
        <varname>maven-book</varname> project exists only as a convenience and
        as a aggregator of modules.</para>

        <para>The book projects do all define a parent. Each of the three
        projects: <varname>maven-book</varname>,
        <varname>book-examples</varname>, and <varname>book-chapters</varname>
        all list a shared "corporate" parent — <varname>sonatype</varname>.
        This is a common practice in organizations which have adopted Maven,
        instead of having every project extend the Super
        <acronym>POM</acronym> by default, some organizations define a
        top-level corporate <acronym>POM</acronym> that serves as the default
        parent when a project doesn't have any good reason to depend on
        another. In this book example, there is no compelling reason to have
        <varname>book-examples</varname> and <varname>book-chapters</varname>
        share the same parent <acronym>POM</acronym>, they are entirely
        different projects which have a different set of dependencies, a
        different build configuration, and use drastically different plugins
        to create the content you are now reading. The
        <varname>sonatype</varname> <acronym>POM</acronym> gives the
        organization a change to customize the default behavior of Maven and
        supply some organization-specific information to configure deployment
        settings and build profiles.</para>
      </section>

      <section>
        <title>多模块企业级项目</title>

        <para>Let's take a look at an example that provides a more accurate
        picture of a real-world project where inheritance and multi-module
        relationships exist side by side. <xref linkend="fig-multi-module" />
        shows a collection of projects that resemble a typical set of projects
        in an enterprise application. There is a top-level
        <acronym>POM</acronym> for the corporation with an
        <varname>artifactId</varname> of <varname>sonatype</varname>. There is
        a multi-module project named <varname>big-system</varname> which
        references sub-modules <varname>server-side</varname> and
        <varname>client-side</varname>.</para>

        <figure id="fig-multi-module">
          <title>Enterprise Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_real_multi.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>What's going on here? Let's try to deconstruct this confusing
        set of arrows. First, let's take a look at
        <varname>big-system</varname>. The <varname>big-system</varname> might
        be the project that you would run <command>mvn package</command> on to
        build and test the entire system. <varname>big-system</varname>
        references submodules <varname>client-side</varname> and
        <varname>server-side</varname>. Each of these projects effectively
        rolls up all of the code that runs on either the server or on the
        client. Let's focus on the <varname>server-side</varname> project.
        Under the <varname>server-side</varname> project we have a project
        called <varname>server-lib</varname> and a multi-module project named
        <varname>web-apps</varname>. Under <varname>web-apps</varname> we have
        two Java web applications: <varname>client-web</varname> and
        <varname>admin-web</varname>.</para>

        <para>Let's start with the parent/child relationships from
        <varname>client-web</varname> and <varname>admin-web</varname> to
        <varname>web-apps</varname>. Since both of the web applications are
        implemented in the same web application framework (let's say Wicket),
        both projects would share the same set of core dependencies. The
        dependencies on the Servlet <acronym>API</acronym>, the
        <acronym>JSP</acronym> <acronym>API</acronym>, and Wicket would all be
        captured in the <varname>web-apps</varname> project. Both
        <varname>client-web</varname> and <varname>admin-web</varname> also
        need to depend on <varname>server-lib</varname>, this dependency would
        be defined as a dependency between <varname>web-apps</varname> and
        <varname>server-lib</varname>. Because <varname>client-web</varname>
        and <varname>admin-web</varname> share so much configuration by
        inheriting from <varname>web-apps</varname>, both
        <varname>client-web</varname> and <varname>admin-web</varname> will
        have very small <acronym>POM</acronym>s containing little more than
        identifiers, a parent declaration, and a final build name.</para>

        <para>Next we focus on the parent/child relationship from
        <varname>web-apps</varname> and <varname>server-lib</varname> to
        <varname>server-side</varname>. In this case, let's just assume that
        there is a separate working group of developers which work on the
        server-side code and another group of developers that work on the
        client-side code. The list of developers would be configured in the
        <varname>server-side</varname> POM and inherited by all of the child
        projects underneath it: <varname>web-apps</varname>,
        <varname>server-lib</varname>, <varname>client-web</varname>, and
        <varname>admin-web</varname>. We could also imagine that the
        <varname>server-side</varname> project might have different build and
        deployment settings which are unique to the development for the server
        side. The <varname>server-side</varname> project might define a build
        profile that only makes sense for all of the
        <varname>server-side</varname> projects. This build profile might
        contain the database host and credentials, or the
        <varname>server-side</varname> project's <acronym>POM</acronym> might
        configure a specific version of the Maven Jetty plugin which should be
        universal across all projects that inherit the
        <varname>server-side</varname> <acronym>POM</acronym>.</para>

        <para>In this example, the main reason to use parent/child
        relationships is shared dependencies and common configuration for a
        group of projects which are logically related. All of the projects
        below <varname>big-system</varname> are related to one another as
        submodules, but not all submodules are configured to point back to
        parent project that included it as a submodule. Everything is a
        submodule for reasons of convenience, to build the entire system just
        go to the <varname>big-system</varname> project directory and run
        <command>mvn package</command>. Look more closely at the figure and
        you'll see that there is no parent/child relationship between
        <varname>server-side</varname> and <varname>big-system</varname>. Why
        is this? <acronym>POM</acronym> inheritance is very powerful, but it
        can be overused. When it makes sense to share dependencies and build
        configuration, a parent/child relationship should be used. When it
        doesn't make sense is when there are distinct differences between two
        projects. Take, for example, the <varname>server-side</varname> and
        <varname>client-side</varname> projects. It is possible to create a
        system where <varname>client-side</varname> and
        <varname>server-side</varname> inherited a common
        <acronym>POM</acronym> from <varname>big-system</varname>, but as soon
        as a significant divergence between the two child projects develops,
        you then have to figure out creative ways to factor out common build
        configuration to <varname>big-system</varname> without affecting all
        of the children. Even though <varname>client-side</varname> and
        <varname>server-side</varname> might both depend on Log4J, they also
        might have distinct plugin configurations.</para>

        <para>There's a certain point defined more by style and experience
        where you decide that minimal duplication of configuration is a small
        price to pay for allowing projects like <varname>client-side</varname>
        and <varname>server-side</varname> to remain completely independent.
        Designing a huge set of thirty plus projects which all inherit five
        levels of POM configuration isn't always the best idea. In such a
        setup, you might not have to duplicate your Log4J dependency more than
        once, but you'll also end up having to wade through five levels of POM
        just figure out how Maven calculated your effective POM. All of this
        complexity to avoid duplicating five lines of dependency declaration.
        In Maven, there is a "Maven Way", but there are also many ways to
        accomplish the same thing. It all boils down to preference and style.
        For the most part, you won't go wrong if all of your submodules turn
        out to define back-references to the same project as a parent, but
        your use of Maven may evolve over time.</para>
      </section>

      <section>
        <title>Prototype Parent Projects</title>

        <para>Take the following example shown in <xref
        linkend="fig-multi-proto" /> as another hypothetical and creative way
        to use inheritance and multi-modules builds to reuse
        dependencies.<figure id="fig-multi-proto">
            <title>Using parent projects as "prototypes" for specialized
            projects</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="figs/web/pom_protos.png" />
              </imageobject>
            </mediaobject>
          </figure><xref linkend="fig-multi-proto" /> is yet another way to
        think about inheritance and multi-module projects. In this example,
        you have two distinct systems. <varname>system-a</varname> and
        <varname>system-b</varname> each define independent applications.
        <varname>system-a</varname> defines two modules
        <varname>a-lib</varname> and <varname>a-swing</varname>.
        <varname>system-a</varname> and <varname>a-lib</varname> both define
        the top-level <varname>sonatype</varname> <acronym>POM</acronym> as a
        parent project, but the <varname>a-swing</varname> project defines
        <varname>swing-proto</varname> as a parent project. In this system,
        <varname>swing-proto</varname> supplies a foundational
        <acronym>POM</acronym> for Swing applications and the
        <varname>struts-proto</varname> project provides a foundational
        <acronym>POM</acronym> for Struts 2 web applications. While the
        <varname>sonatype</varname> POM provides high level information such
        as the <varname>groupId</varname>, organization information, and build
        profiles, <varname>struts-proto</varname> defines all of the
        dependencies that you need to create a struts application. This
        approach would work well if your development is characterized by many
        independent applications which each have to follow the same set of
        rules. If you are creating a lot of struts applications but they are
        not really related to one another, you might just define everything
        you need in <varname>struts-proto</varname>. The downside to this
        approach is that you won't be able to use parent/child relationships
        within the <varname>system-a</varname> and <varname>system-b</varname>
        project hierarchies to share information like developers and other
        build configuration. A project can only have one parent.</para>

        <para>The other downside of this approach is that as soon as you have
        one project that "breaks the mold" you'll either have to override the
        prototype parent <acronym>POM</acronym> or find a way to factor
        customizations into the shared parent without those customizations
        affecting all the children. In general, using POMs as prototypes for
        specialized project "types" isn't a recommended practice.</para>
      </section>
    </section>
  </section>
</chapter>