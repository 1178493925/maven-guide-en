<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="lifecycle">
  <title>构建生命周期</title>

  <section id="lifecycle-structure">
    <title>简介</title>

    <para>Maven使用<acronym>POM</acronym>描述项目，将其建模成一些名词。<acronym>POM</acronym>记录了一个项目的定义：项目包含什么？需要怎样的打包类型？是否包含一个父项目？它的依赖是什么？我们已经在前面的章节展示了如何描述一个项目，但还没有介绍一种允许Maven针对这些对象进行操作的机制。在Maven中这些“动词”是由Maven插件包装的一些目标，它们绑定到一个构建生命周期的阶段中。一个Maven生命周期包含了一些有序的命名阶段：prepare-resources，compile，package，和install以及其它。有一个阶段抽象了编译过程，一个阶段抽象了打包过程。而那些pre-和post-阶段可以用来注册一些必须在某些特定阶段之前或之后运行的目标。当你让Maven构建一个项目的时候，你其实是让它一步步通过那些定义好的有序的阶段，并且运行所有注册到某个特定阶段的目标。</para>

    <para>一个构建生命周期是一组精心组织的有序的阶段，它的存在能使所有注册的目标变得有序。这些目标根据项目的打包类型被选择并绑定。Maven中有三种标准的生命周期：清理（clean），默认（default）(有时候也称为构建)，和站点（site）。本章，我们将学习Maven如何将目标绑定到生命周期，生命周期如何自定义。你同时也会学得默认生命周期阶段的知识。</para>

    <section>
      <title>清理生命周期 (clean)</title>

      <para>第一个你将感兴趣的生命周期是Maven中最简单的生命周期。运行<command>mvn
      clean</command>将调用清理生命周期，它包含了三个生命周期阶段：</para>

      <itemizedlist>
        <listitem>
          <para><varname>pre-clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>post-clean</varname></para>
        </listitem>
      </itemizedlist>

      <para>在清理生命周期中有意思的阶段是<varname>clean</varname>阶段。Clean插件的clean目标（<varname>clean:clean</varname>）被绑定到清理生命周期中的<varname>clean</varname>阶段。目标<varname>clean:clean</varname>通过删除构建目录删除整个构建的输出。如果你没有自定义构建目录位置，那么构建目录就是定义在超级<acronym>POM</acronym>中的<filename>${basedir}/target</filename>。当你运行<varname>clean:clean</varname>目标的时候你并不是直接运行<command>mvn
      clean:clean</command>，你可以通过执行清理生命周期的<varname>clean</varname>阶段运行该目标。运行<varname>clean</varname>阶段能让Maven有机会执行其它可能被绑定到<varname>pre-clean</varname>阶段的目标。</para>

      <para>例如，假设你想要在<varname>pre-clean</varname>的时候触发一个<varname>antrun:run</varname>目标任务来输出一个通知，或者需要在项目构建目录被删除之前将其归档。简单的运行<varname>clean:clean</varname>目标不会完整的执行该生命周期，但是指定<varname>clean</varname>阶段就能使用<varname>clean</varname>生命周期，并且逐个的经过生命周期阶段，直到到达<varname>clean</varname>阶段。<xref
      linkend="ex-trigger-pre-clean" />展示了一个样例，在它的构建配置中，绑定了<varname>antrun:run</varname>至<varname>pre-clean</varname>阶段，输出一个警告告诉用户项目构件即将被删除。该例中，<varname>antrun:run</varname>目标被用来执行一些随意的Ant命令来检查项目的构件。如果项目的构件将要被删除，它会打印该信息至屏幕。</para>

      <example id="ex-trigger-pre-clean">
        <title>在pre-clean阶段触发一个目标</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;... &lt;plugin&gt;
    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;file-exists&lt;/id&gt;
        &lt;phase&gt;pre-clean&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;run&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;tasks&gt;
            &lt;!-- adds the ant-contrib tasks (if/then/else used below) --&gt;
            &lt;taskdef resource="net/sf/antcontrib/antcontrib.properties" /&gt;
            &lt;available 
              file="${project.build.directory}/${project.build.finalName}.jar"
              property="file.exists" value="true" /&gt;

            &lt;if&gt;
              &lt;not&gt;
                &lt;isset property="file.exists" /&gt;
              &lt;/not&gt;
              &lt;then&gt;
                &lt;echo&gt;No
                  ${project.build.finalName}.${project.packaging} to
                  delete&lt;/echo&gt;
              &lt;/then&gt;
              &lt;else&gt;
                &lt;echo&gt;Deleting
                  ${project.build.finalName}.${project.packaging}&lt;/echo&gt;
              &lt;/else&gt;
            &lt;/if&gt;
          &lt;/tasks&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;ant-contrib&lt;/groupId&gt;
        &lt;artifactId&gt;ant-contrib&lt;/artifactId&gt;
        &lt;version&gt;1.0b2&lt;/version&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/plugin&gt;
  &lt;/plugins&gt;
  &lt;/build&gt; 
&lt;/project&gt;
</programlisting>

        <para>在带有如上构建配置的项目中运行<command>mvn clean</command>会生成如下的输出：</para>
      </example>

      <screen>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building Your Project
[INFO]    task-segment: [clean]
[INFO] ----------------------------------------------------------------------
[INFO] [antrun:run {execution: file-exists}]
[INFO] Executing tasks
     [echo] Deleting your-project-1.0-SNAPSHOT.jar
[INFO] Executed tasks
[INFO] [clean:clean]
[INFO] Deleting directory ~/corp/your-project/target
[INFO] Deleting directory ~/corp/your-project/target/classes
[INFO] Deleting directory ~/corp/your-project/target/test-classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Wed Nov 08 11:46:26 CST 2006
[INFO] Final Memory: 2M/5M
[INFO] ------------------------------------------------------------------------
</screen>

      <para>除了在<varname>pre-clean</varname>阶段配置Maven去运行一个目标，你也可以自定义Clean插件去删除构建输出目录以外的文件。你可以配置该插件去删除那些在<sgmltag>fileSet</sgmltag>中指定的文件。下面的样例配置了Clean插件，使用标准的Ant文件通配符：*和**，删除所有<filename>target-other/</filename>目录中的<filename>.class</filename>文件。</para>

      <para><example>
          <title>自定义Clean插件的行为</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;filesets&gt;
            &lt;fileset&gt;
              &lt;directory&gt;target-other&lt;/directory&gt;
              &lt;includes&gt;
                &lt;include&gt;*.class&lt;/include&gt;
              &lt;/includes&gt;
            &lt;/fileset&gt;
          &lt;/filesets&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
        </example></para>
    </section>

    <section>
      <title>默认生命周期 (default)</title>

      <para>大部分Maven用户将会对默认生命周期十分熟悉。它是一个软件应用构建过程的总体模型。第一个阶段是<varname>validate</varname>，最后一个阶段是<varname>deploy</varname>。这些默认Maven生命周期的阶段如<xref
      linkend="tbl-default-lifecycle" />所示：</para>

      <table id="tbl-default-lifecycle">
        <title>Maven默认生命周期阶段</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>描述</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>validate</entry>

              <entry>验证项目是否正确，以及所有为了完整构建必要的信息是否可用</entry>
            </row>

            <row>
              <entry>generate-sources</entry>

              <entry>生成所有需要包含在编译过程中的源代码</entry>
            </row>

            <row>
              <entry>process-sources</entry>

              <entry>处理源代码，比如过滤一些值</entry>
            </row>

            <row>
              <entry>generate-resources</entry>

              <entry>生成所有需要包含在打包过程中的资源文件</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>复制并处理资源文件至目标目录，准备打包</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>编译项目的源代码</entry>
            </row>

            <row>
              <entry>process-classes</entry>

              <entry>后处理编译生成的文件，例如对Java类进行字节码增强（bytecode enhancement）</entry>
            </row>

            <row>
              <entry>generate-test-sources</entry>

              <entry>生成所有包含在测试编译过程中的测试源码</entry>
            </row>

            <row>
              <entry>process-test-sources</entry>

              <entry>处理测试源码，比如过滤一些值</entry>
            </row>

            <row>
              <entry>generate-test-resources</entry>

              <entry>生成测试需要的资源文件</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>复制并处理测试资源文件至测试目标目录</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>编译测试源码至测试目标目录</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>使用合适的单元测试框架运行测试。这些测试应该不需要代码被打包或发布</entry>
            </row>

            <row>
              <entry>prepare-package</entry>

              <entry>在真正的打包之前，执行一些准备打包必要的操作。这通常会产生一个包的展开的处理过的版本（将会在Maven
              2.1+中实现）</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>将编译好的代码打包成可分发的格式，如<acronym>JAR</acronym>，<acronym>WAR</acronym>，或者<acronym>EAR</acronym></entry>
            </row>

            <row>
              <entry>pre-integration-test</entry>

              <entry>执行一些在集成测试运行之前需要的动作。如建立集成测试需要的环境</entry>
            </row>

            <row>
              <entry>integration-test</entry>

              <entry>如果有必要的话，处理包并发布至集成测试可以运行的环境</entry>
            </row>

            <row>
              <entry>post-integration-test</entry>

              <entry>执行一些在集成测试运行之后需要的动作。如清理集成测试环境。</entry>
            </row>

            <row>
              <entry>verify</entry>

              <entry>执行所有检查，验证包是有效的，符合质量规范</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>安装包至本地仓库，以备本地的其它项目作为依赖使用</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>站点生命周期 (site)</title>

      <para>Maven不仅仅能从一个项目构建软件构件，它还能为一个或者一组项目生成项目文档和报告。项目文档和站点生成有一个专有的生命周期，它包含了四个阶段：</para>

      <orderedlist>
        <listitem>
          <para>pre-site</para>
        </listitem>

        <listitem>
          <para>site</para>
        </listitem>

        <listitem>
          <para>post-site</para>
        </listitem>

        <listitem>
          <para>site-deploy</para>
        </listitem>
      </orderedlist>

      <para>默认绑定到站点生命周期的目标是：</para>

      <orderedlist>
        <listitem>
          <para>site - site:site</para>
        </listitem>

        <listitem>
          <para>site-deploy -site:deploy</para>
        </listitem>
      </orderedlist>

      <para>打包类型通常不更改此生命周期，因为打包类型主要和构件创建有关，和站点生成没有太大的关系。Site插件触发<ulink
      url="http://maven.apache.org/doxia/">Doxia</ulink>执行文档生成，以及执行其它报告生成插件。你可以通过运行如下命令从一个Maven项目生成一个站点：</para>

      <screen>$ <command>mvn site</command>
</screen>

      <para>有关更多的Maven站点生成信息，查看<xref linkend="site-generation" />。</para>
    </section>
  </section>

  <section>
    <title>打包相关生命周期</title>

    <para>绑定到每个阶段的特定目标默认根据项目的打包类型设置。一个打包类型为<varname>jar</varname>的项目和一个打包类型为<varname>war</varname>的项目拥有不同的两组默认目标。<sgmltag>packaging</sgmltag>元素影响构建一个项目需要的步骤。举个打包如何影响构建的例子，考虑有两个项目：一个打包类型是<varname>pom</varname>，另外一个是<varname>jar</varname>。在<varname>package</varname>阶段，打包类型为<varname>pom</varname>的项目会运行<varname>site:attach-descriptor</varname>目标，而打包类型为<varname>jar</varname>的项目会运行<varname>jar:jar</varname>目标。</para>

    <para>下面的小节描述了Maven中内建打包类型的生命周期。可以使用这些小节来找出哪些默认目标映射到了哪些默认生命周期阶段。</para>

    <section>
      <title>JAR</title>

      <para><acronym>JAR</acronym>是默认的打包类型，最常用的，因此也就是生命周期配置中最经常遇到的打包类型。<acronym>JAR</acronym>生命周期默认的目标如<xref
      linkend="tbl-jar-lifecycle" />所示：</para>

      <table id="tbl-jar-lifecycle">
        <title>JAR打包默认的目标</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>POM</title>

      <para><acronym>POM</acronym>是最简单的打包类型。不像一个<acronym>JAR</acronym>，<acronym>SAR</acronym>，或者<acronym>EAR</acronym>，它生成的构件只是它本身。没有代码需要测试或者编译，也没有资源需要处理。打包类型为<acronym>POM</acronym>的项目的默认目标如<xref
      linkend="tbl-pom-lifecycle" />所示：</para>

      <table id="tbl-pom-lifecycle">
        <title>POM打包默认的目标</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>package</entry>

              <entry>site:attach-descriptor</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="sect-plugin-lifecycle">
      <title>Maven Plugin</title>

      <para>该打包类型和<acronym>JAR</acronym>打包类型类似，除了三个例外的目标：<varname>plugin:descriptor</varname>，<varname>plugin:addPluginArtifactMetadata</varname>，和<varname>plugin:updateRegistry</varname>。这些目标生成一个描述文件，对仓库数据执行一些修改。打包类型为maven-plugin的项目的默认目标如<xref
      linkend="tbl-plugin-lifecycle" />所示。</para>

      <table id="tbl-plugin-lifecycle">
        <title>maven-plugin打包默认的目标</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>plugin:descriptor</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar, plugin:addPluginArtifactMetadata</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install, plugin:updateRegistry</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>EJB</title>

      <para><acronym>EJB</acronym>，或者说企业Java
      Bean，是企业级Java中模型驱动开发的常见数据访问机制。Maven提供了对<acronym>EJB</acronym>
      2和3的支持。你必须配置<acronym>EJB</acronym>插件来为<acronym>EJB3</acronym>指定打包类型，否则该插件默认认为<acronym>EJB</acronym>为2.1，并寻找某些<acronym>EJB</acronym>配置文件是否存在。打包类型为<acronym>EJB</acronym>的项目的默认目标如<xref
      linkend="tbl-ejb-lifecycle" />所示。</para>

      <table id="tbl-ejb-lifecycle">
        <title>EJB打包默认的目标</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ejb:ejb</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>WAR</title>

      <para><acronym>WAR</acronym>打包类型和<acronym>JAR</acronym>以及<acronym>EJB</acronym>类似。例外是这里的<varname>package</varname>目标是<varname>war:war</varname>。注意<varname>war:war</varname>插件需要一个<filename>web.xml</filename>配置文件在项目的<filename>src/main/webapp/WEB-INF</filename>目录中。打包类型为<acronym><acronym>WAR</acronym></acronym>的项目的默认目标如<xref
      linkend="tbl-war-lifecycle" />所示。</para>

      <table id="tbl-war-lifecycle">
        <title>WAR打包默认的目标</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>war:war</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>EAR</title>

      <para><acronym>EAR</acronym>可能是最简单的Java
      EE结构体，它主要包含一个部署描述符<filename>application.xml</filename>文件，一些资源和一些模块。<acronym>EAR</acronym>插件有个名为<varname>generate-application-xml</varname>的目标，它根据<acronym>EAR</acronym>项目<acronym>POM</acronym>的配置生成<filename>application.xml</filename>。打包类型为<acronym><acronym><acronym>EAR</acronym></acronym></acronym>的项目的默认目标如<xref
      linkend="tbl-ear-lifecycle" />所示。</para>

      <table id="tbl-ear-lifecycle">
        <title>EAR打包默认的目标</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>ear:generate-application-xml</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ear:ear</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>其它打包类型</title>

      <para>以上并非是一个Maven中所有可用打包类型的完整列表。有许多打包格式在外部的项目和插件中可用：<acronym>NAR</acronym>（本地归档）打包类型，用来生成Adobe
      Flash和Flex内容的项目的<acronym>SWF</acronym>和<acronym>SWC</acronym>打包类型，以及很多其它类型。你也可以定义一个自定义的打包类型，定制默认的生命周期目标来适应你自己项目的打包需求。</para>

      <para>为了使用自定义的打包类型，你需要两样东西：一个定义了定制打包类型生命周期的插件，和一个包含该插件的仓库。有些定制打包类型是由中央Maven仓库中可用的插件定义的。这里有一个样例项目，它引用了Israfil
      Flex插件，使用自定打包类型<acronym>SWF</acronym>从Adobe Flex生成输出。</para>

      <para><example>
          <title>为Adobe Flex (SWF)定制打包类型</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;packaging&gt;swf&lt;/packaging&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;net.israfil.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;maven-flex2-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.4-SNAPSHOT&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
        &lt;configuration&gt;
          &lt;debug&gt;true&lt;/debug&gt;
          &lt;flexHome&gt;${flex.home}&lt;/flexHome&gt;
          &lt;useNetwork&gt;true&lt;/useNetwork&gt;
          &lt;main&gt;org/sonatype/mavenbook/Main.mxml&lt;/main&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>在<xref
      linkend="sect-plugins-lifecycle" />中，我们向你展示了如何使用自定义的生命周期创建你自己的打包类型。该样例应该能让你了解到，引用一个定制的打包类型你需要做些什么。你需要做的只是引用那个提供定制打包类型的插件。Israfil
      Flex插件是托管在Google Code的第三方Maven插件，要了解更多的关于此插件的信息，以及如何使用Maven编译Adobe
      Flex，访问<ulink
      url="http://code.google.com/p/israfil-mojo">http://code.google.com/p/israfil-mojo</ulink>。该插件为<acronym>SWF</acronym>打包类型提供了如下的生命周期。</para>

      <table>
        <title>SWF打包的默认生命周期</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>生命周期阶段</entry>

              <entry>目标</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>compile</entry>

              <entry>flex2:compile-swc</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section>
    <title>常见生命周期目标</title>

    <para>Many of the packaging lifecycles have similar goals. If you look at
    the goals bound to the <acronym>WAR</acronym> and <acronym>JAR</acronym>
    lifecycles, you'll see that they differ only in the
    <varname>package</varname> phase. The <varname>package</varname> phase of
    the <acronym>WAR</acronym> lifecycle calls <varname>war:war</varname> and
    the <varname>package</varname> phase of the <acronym>JAR</acronym>
    lifecycle calls <varname>jar:jar</varname>. Most of the lifecycles you
    will come into contact share some common lifecycle goals for managing
    resources, running tests, and compiling source code. In this section,
    we'll explore some of these common lifecycle goals in detail.</para>

    <section>
      <title>Process Resources</title>

      <para>Most lifecycles bind the <varname>resources:resources</varname>
      goal to the <varname>process-resources</varname> phase. The
      <varname>process-resources</varname> phase "processes" resources and
      copies them to the output directory. If you haven't customized the
      default directory locations defined in the Super <acronym>POM</acronym>,
      this means that Maven will copy the files from
      <filename>${basedir}/src/main/resources</filename> to
      <filename>${basedir}/target/classes</filename> or the directory defined
      in <filename>${project.build.outputDirectory}</filename>. In addition to
      copying the resources to the output directory, Maven can also apply a
      filter to the resources that allows you to replace tokens within
      resource file. Just like variables are referenced in a
      <acronym>POM</acronym> using <varname>${...}</varname> notation, you can
      reference variables in your project's resources using the same syntax.
      Coupled with build profiles, such a facility can be used to produce
      build artifacts which target different deployment platforms. This is
      something that is common in environments which need to produce output
      for development, testing, staging, and production platforms from the
      same project. For more information about build profiles, see <xref
      linkend="profiles" />.</para>

      <para>To illustrate resource filtering, assume that you have a project
      with an <acronym>XML</acronym> file in
      <filename>src/main/resources/META-INF/service.xml</filename>. You want
      to externalize some configuration variables to a properties file. In
      other words, you might want to reference a <acronym>JDBC</acronym>
      <acronym>URL</acronym>, username, and password for your database, and
      you don't want to put these values directly into the
      <filename>service.xml</filename> file. Instead, you would like to use a
      properties file to capture all of the configuration points for your
      program. Doing this will allow you to consolidate all configuration into
      a single properties file and make it easier to change configuration
      values when you need to target a new deployment environment. First, take
      a look at the contents of <filename>service.xml</filename> in
      <filename>src/main/resources/META-INF</filename>.</para>

      <para><example>
          <title>Using Properties in Project Resources</title>

          <programlisting language="xml">&lt;service&gt;
  &lt;!-- This URL was set by project version ${project.version} --&gt;
  &lt;url&gt;${jdbc.url}&lt;/url&gt;
  &lt;user&gt;${jdbc.username}&lt;/user&gt;
  &lt;password&gt;${jdbc.password}&lt;/password&gt;
&lt;/service&gt;
</programlisting>
        </example></para>

      <para>This <acronym>XML</acronym> file uses the same property reference
      syntax you can use in the <acronym>POM</acronym>. In fact, the first
      variable referenced is the <varname>project</varname> variable which is
      also an implicit variable made available in the <acronym>POM</acronym>.
      The <varname>project</varname> variable provides access to
      <acronym>POM</acronym> information. The next three variable references
      are <varname>jdbc.url</varname>, <varname>jdbc.username</varname>, and
      <varname>jdbc.password</varname>. These custom variables are defined in
      a properties file
      <filename>src/main/filters/default.properties</filename>.</para>

      <example>
        <title>default.properties in src/main/filters</title>

        <programlisting>jdbc.url=jdbc:hsqldb:mem:mydb
jdbc.username=sa
jdbc.password=
</programlisting>
      </example>

      <para>To configure resource filtering with this
      <filename>default.properties</filename> file, we need to specify two
      things in a project's <acronym>POM</acronym>: a list of properties files
      in the <sgmltag>filters</sgmltag> element of the build configuration,
      and a flag to Maven that the resources directory is to be filtered. The
      default Maven behavior is to skip filtering and just copy the resources
      to the output directory; you'll need to explicitly configure resource
      filter, or Maven will skip the step altogether. This default ensures
      that Maven's resource filtering feature doesn't surprise you out of
      nowhere and clobbering any <varname>${...}</varname> references you
      didn't want it to replace.</para>

      <para><example>
          <title>Filter Resources (Replacing Properties)</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;filters&gt;
    &lt;filter&gt;src/main/filters/default.properties&lt;/filter&gt;
  &lt;/filters&gt;
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;
</programlisting>
        </example></para>

      <para>As with all directories in Maven, the resources directory does not
      need to be in <filename>src/main/resources</filename>. This is just the
      default value defined in the Super <acronym>POM</acronym>. You should
      also note that you don't need to consolidate all of your resources into
      a single directory. You can always separate resources into separate
      directories under <filename>src/main</filename>. Assume that you have
      project which contains hundreds of <acronym>XML</acronym> documents and
      hundreds of images. Instead of mixing the resources in the
      <filename>src/main/resources</filename> directory, you might want to
      create two directories <filename>src/main/xml</filename> and
      <filename>src/main/images</filename> to hold this content. To add
      directories to the list of resource directories, you would add the
      following <sgmltag>resource</sgmltag> elements to your build
      configuration.</para>

      <example>
        <title>Configuring Additional Resource Directories</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/xml&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/images&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <para>When you are building a project that produces a console
      application or a command-line tool, you'll often find yourself writing
      simple shell scripts that need to reference the <acronym>JAR</acronym>
      produced by a build. When you are using the assembly plugin to produce a
      distribution for an application as a <acronym>ZIP</acronym> or
      <acronym>TAR</acronym>, you might place all of you scripts in a
      directory like <filename>src/main/command</filename>. In the following
      <acronym>POM</acronym> resource configuration, you'll see how we can use
      resource filtering and a reference to the project variable to capture
      the final output name of the <acronym>JAR</acronym>. For more
      information about the Maven Assembly plugin, see <xref
      linkend="assemblies" />.</para>

      <para><example id="ex-filter-script">
          <title>Filtering Script Resources</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple-cmd&lt;/artifactId&gt;
  &lt;version&gt;2.3.1&lt;/version&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
      &lt;directory&gt;${basedir}/src/main/command&lt;/directory&gt;
      &lt;includes&gt;
        &lt;include&gt;run.bat&lt;/include&gt;
        &lt;include&gt;run.sh&lt;/include&gt;
      &lt;/includes&gt;
      &lt;targetPath&gt;${basedir}&lt;/targetPath&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
        </example></para>

      <para>If you run <filename>mvn process-resources</filename> in this
      project, you will end up with two files, <filename>run.sh</filename> and
      <filename>run.bat</filename>, in <varname>${basedir}</varname>. We've
      singled out these two files in a <sgmltag>resource</sgmltag> element,
      configuring filtering, and set the <sgmltag>targetPath</sgmltag> to be
      <varname>${basedir}</varname>. In a second <sgmltag>resource</sgmltag>
      element, we've configured the default resources path to be copied to the
      default output directory without any filtering. <xref
      linkend="ex-filter-script" /> shows you how to declare two resource
      directories and supply them with different filtering and target
      directory preferences. The project from <xref
      linkend="ex-filter-script" /> would contain a
      <filename>run.bat</filename> file in
      <filename>src/main/command</filename> with the following content:</para>

      <programlisting>@echo off
java -jar ${project.build.finalName}.jar %*
</programlisting>

      <para>After running <command>mvn process-resources</command>, a file
      named <filename>run.bat</filename> would appear in
      <varname>${basedir}</varname> with the following content:</para>

      <programlisting>@echo off
java -jar simple-cmd-2.3.1.jar %*
</programlisting>

      <para>The ability to customize filtering for specific subsets of
      resources is another reason why complex projects with many different
      kinds of resources often find it advantageous to separate resources into
      multiple directories. The alternative to storing different kinds of
      resources with different filtering requirements in different directories
      is to use a more complex set of include and exclude patterns to match
      all resource files which match a certain pattern.</para>
    </section>

    <section>
      <title>Compile</title>

      <para>Most lifecycles bind the Compiler plugin's
      <varname>compile</varname> goal to the <varname>compile</varname> phase.
      This phase calls out to <varname>compile:compile</varname> which is
      configured to compile all of the source code and copy the bytecode to
      the build output directory. If you haven't customized the values defined
      in the Super <acronym>POM</acronym>, <varname>compile:compile</varname>
      is going to compile everything from <filename>src/main/java</filename>
      to <filename>target/classes</filename>. The Compiler plugin calls out to
      <filename>javac</filename> and uses default source and target settings
      of 1.3 and 1.1. In other words, the compiler plugin assumes that your
      Java source conforms to Java 1.3 and that you are targeting a Java 1.1
      JVM. If you would like to change these settings, you'll need to supply
      the target and source configuration to the Compiler plugin in your
      project's POM as shown in <xref
      linkend="ex-compilesrc-target" />.</para>

      <para><example id="ex-compilesrc-target">
          <title>Setting the Source and Target Versions for the Compiler
          Plugin</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Notice we are configuring the Compiler plugin, and not the
      specific <varname>compile:compile</varname> goal. If we were going to
      configure the source and target for just the
      <varname>compile:compile</varname> goal, we would place the
      <sgmltag>configuration</sgmltag> element below an
      <sgmltag>execution</sgmltag> element for the
      <varname>compile:compile</varname> goal. We've configured the target and
      source for the plugin because <varname>compile:compile</varname> isn't
      the only goal we're interested in configuring. The Compiler plugin is
      reused when Maven compiles tests using the
      <varname>compile:testCompile</varname> goal, and configuring target and
      source at the plugin level allows us to define it once for all goals in
      a plugin.</para>

      <para>If you need to customize the location of the source code, you can
      do so by changing the build configuration. If you wanted to store your
      project's source code in <filename>src/java</filename> instead of
      <filename>src/main/java</filename> and if you wanted build output to go
      to <filename>classes</filename> instead of
      <filename>target/classes</filename>, you could always override the
      default <sgmltag>sourceDirectory</sgmltag> defined by the Super
      <acronym>POM</acronym>.</para>

      <example>
        <title>Overriding the Default Source Directory</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;sourceDirectory&gt;src/java&lt;/sourceDirectory&gt;
  &lt;outputDirectory&gt;classes&lt;/outputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <warning>
        <para>While it might seem necessary to bend Maven to your own idea of
        project directory structure, we can't emphasize enough that you should
        sacrifice your own ideas of directory structure in favor of the Maven
        defaults. This isn't because we're trying to brainwash you into
        accepting the Maven Way, but it will be easier for people to
        understand your project if it adheres to the most basic conventions.
        Just forget about this. Don't do it.</para>
      </warning>
    </section>

    <section>
      <title>Process Test Resources</title>

      <para>The <varname>process-test-resources</varname> phase is almost
      indistinguishable from the <varname>process-resources</varname> phase.
      There are some trivial differences in the <acronym>POM</acronym>, but
      most everything the same. You can filter test resources just as you
      filter regular resources. The default location for test resources is
      defined in the Super <acronym>POM</acronym> as
      <filename>src/test/resources</filename>, and the default output
      directory for test resources is <filename>target/test-classes</filename>
      as defined in
      <varname>${project.build.testOutputDirectory}</varname>.</para>
    </section>

    <section>
      <title>Test Compile</title>

      <para>The <varname>test-compile</varname> phase is almost identical to
      the <varname>compile</varname> phase. The only difference is that
      <varname>test-compile</varname> is going to invoke
      <varname>compile:testCompile</varname> to compile source from the test
      source directory to the test build output directory. If you haven't
      customized the default directories from the Super
      <acronym>POM</acronym>, <varname>compile:testCompile</varname> is going
      to compile the source in <filename>src/test/java</filename> to the
      <filename>target/test-classes</filename> directory.</para>

      <para>As with the source code directory, if you want to customize the
      location of the test source code and the output of test compilation, you
      can do so by overriding the <varname>testSourceDirectory</varname> and
      the testOutputDirectory. If you wanted to store test source in
      <filename>src-test/</filename> instead of
      <filename>src/test/java</filename> and you wanted to save test bytecode
      to <filename>classes-test/</filename> instead of
      <filename>target/test-classes</filename>, you would use the following
      configuration.</para>

      <example>
        <title>Overriding the Location of Test Source and Output</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;testSourceDirectory&gt;src-test&lt;/testSourceDirectory&gt;
  &lt;testOutputDirectory&gt;classes-test&lt;/testOutputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>
    </section>

    <section>
      <title>Test</title>

      <para>Most lifecycles bind the test goal of the Surefire plugin to the
      test phase. The Surefire plugin is Maven's unit testing plugin, the
      default behavior of Surefire is to look for all classes ending in *Test
      in the test source directory and to run them as <ulink
      url="http://www.junit.org">JUnit</ulink> tests. The Surefire plugin can
      also be configured to run <ulink
      url="http://www.testng.org">TestNG</ulink> unit tests.</para>

      <para>After running <command>mvn test</command>, you should also notice
      that the Surefire produces a number of reports in
      <filename>target/surefire-reports</filename>. This reports directory
      will have two files for each test executed by the Surefire plugin: an
      <acronym>XML</acronym> document containing execution information for the
      test, and a text file containing the output of the unit test. If there
      is a problem during the test phase and a unit test has failed, you can
      use the output of Maven and the contents of this directory to track down
      the cause of a test failure. This <filename>surefire-reports/</filename>
      directory is also used during site generation to create an easy to read
      summary of all the unit tests in a project.</para>

      <para>If you are working on a project that has some failing unit tests,
      but you want the project to produce output, you'll need to configure the
      Surefire plugin to continue a build even if it encounters a failure. The
      default behavior is to stop a build whenever a unit test failure is
      encountered. To override this behavior, you'll need to set the
      <varname>testFailureIgnore</varname> configuration property on the
      Surefire plugin to true.</para>

      <example>
        <title>Configuring Surefire to Ignore Test Failures</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
     &lt;configuration&gt;
       &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
     &lt;/configuration&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/build&gt;</programlisting>
      </example>

      <para>If you would like to skip tests altogether, you can do so by
      executing the following command:</para>

      <screen>$ mvn install -Dmaven.test.skip=true</screen>

      <para>The <varname>maven.test.skip</varname> variable controls both the
      Compiler and the Surefire plugin, if you pass in
      <varname>maven.test.skip</varname> you've told Maven to ignore tests
      altogether.</para>
    </section>

    <section>
      <title>Install</title>

      <para>The <varname>install</varname> goal of the Install plugin is
      almost always bound to the <varname>install</varname> lifecycle phase.
      This <varname>install:install</varname> goal simply installs a project's
      main artifact to the local repository. If you have a project with a
      <sgmltag>groupId</sgmltag> of <package>org.sonatype.mavenbook</package>,
      an <sgmltag>artifactId</sgmltag> of <varname>simple-test</varname>, and
      a <sgmltag>version</sgmltag> of 1.0.2, the
      <varname>install:install</varname> goal is going to copy the
      <acronym>JAR</acronym> file from
      <filename>target/simple-test-1.0.2.jar</filename> to
      <filename>~/.m2/repository/org/sonatype/mavenbook/simple-test/1.0.2/simple-test-1.0.2.jar</filename>.
      If the project has <acronym>POM</acronym> packaging, this goal will copy
      the <acronym>POM</acronym> to the local repository.</para>
    </section>

    <section>
      <title>Deploy</title>

      <para>The <varname>deploy</varname> goal of the Deploy plugin is usually
      bound to the <varname>deploy</varname> lifecycle phase. This phase is
      used to deploy an artifact to a remote Maven repository, this is usually
      required to update a remote repository when you are performing a
      release. The deployment procedure can be as simple as copying a file to
      another directory or as complex as transferring a file over
      <acronym>SCP</acronym> using a public key. Deployment settings usually
      involve credentials to a remote repository, and, as such, deployment
      settings are usually not stored in a <filename>pom.xml</filename>.
      Instead, deployment settings are more frequently found in an individual
      user's <filename>~/.m2/settings.xml</filename>. For now, all you need to
      know is that the <varname>deploy:deploy</varname> goal is bound to the
      <varname>deploy</varname> phase and it takes care of transporting an
      artifact to a published repository and updating any repository
      information which might be affected by such a deployment.</para>
    </section>
  </section>
</chapter>
