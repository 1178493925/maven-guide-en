<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="profiles">
  <title>构建Profile</title>

  <section id="profiles-what">
    <title>Profile是用来做什么的?</title>

    <para>Profile能让你为一个特殊的环境自定义一个特殊的构建；profile使得不同构建环境间的可移植成为可能。</para>

    <para>不同的构建环境是什么意思？两个构建环境的例子是产品环境和开发环境。当你在开发环境中工作时，你的系统可能被配置成读取运行在你本机的开发数据库实例，而在产品环境中，你的系统被配置成从产品数据库读取数据。Maven能让你定义任意数量的构建环境（构建profile），这些定义可以覆盖任何<filename>pom.xml</filename>中的配置。你可以配置你的应用程序，在“开发”profile中，读取本地的开发数据库实例，在“产品”profile中，访问产品数据库。Profile也可以通过环境和平台被激活，你可以自定义一个构建，它根据不同的操作系统或者不同的<acronym>JDK</acronym>版本表现不同。在我们讨论使用和配置Maven
    profile之前，我们需要定义构建可移植性的概念。</para>

    <section>
      <title>什么是构建可移植性</title>

      <para>一个构建的“可移植性”是指将一个项目在不同的环境中构建的难易度。一个不用做任何自定义配置或者属性文件配置就能工作的构建，比一个需要很多配置才能工作的构建，具有更高的可移植性。构建可移植性最高的项目往往是一些开源项目如Apache
      Commons或者Apache
      Velocity，它们带有Maven构建，不需要或者需要很少的自定义配置。简言之，可移植性最高的项目往往“开箱可用”，而可移植性最低的构建则需要你跳过一个个难缠的框框，配置平台相关的路径以定位构建工具。在我们展示如何实现构建移植性之前，先浏览下我们讨论的不同种类的构建可移植性。</para>

      <section>
        <title>不可移植构建</title>

        <para>缺少可移植性正式所有构建工具试图防止的——然后，任何工具都能配置成不可移植（即使Maven）。一个不可移植的项目只有在一组特定的环境和标准（比如，你的本地机器）下能构建。除非你自己一个人工作，没有任何计划将你的应用部署到其它机器上，否则最好要完全避免不可移植性。一个不可移植的构建只能在单独的机器上运行，是“一次性的”。Maven设计提供了使用profile自定义构建的能力，阻止不可移植的构建。</para>

        <para>当一个新的开发人员得到不可移植项目的源码的时候，如果不重写大部分的构建脚本，他就不能构建这个项目。</para>
      </section>

      <section>
        <title>环境可移植性</title>

        <para>如果一个构建有一种机制，能针对不同的环境有定制的行为和配置，那么我们就说该构建具有环境可移植性。例如，一个项目在测试环境中包含一个对于测试数据库的引用，而在产品环境中则引用了产品数据库，那么该项目的构建是环境可移植的。这很有可能是因为该构建针对不同的环境有不同的属性组。当你转移到一个不同的环境中，该环境未被定义也没有为其创建profile，那么项目将不能工作。因此，该项目也只是在一定义的环境中可移植。</para>

        <para>当你一个新的开发人员得到环境可移植项目的源码，他们必须在一定以的环境中运行此构建，否则就需要创建自定义的环境才能构建项目。</para>
      </section>

      <section>
        <title>组织（内部）可移植性</title>

        <para>这一层可移植性的中心是一个项目可能需要访问一些内部资源如源码控制系统或者内部维护的Maven仓库。大公司的项目可能依赖于一个只对内部开发人员可用的数据库，而一个开源项目可能需要一个特定级别的证书来发布web站点，以及将构建的产品发布到公共仓库。</para>

        <para>如果你试图在内部网络外部（例如，在公司的防火墙外面）从零开始构建一个内部项目，构建会失败。它失败的原因可能是一些必须的自定义插件不可用，或者项目的依赖找不到，因为你没有适当的证书从一个自定义的远程仓库获取依赖。这样的项目只有在一个组织内部的环境中拥有可移植性。</para>
      </section>

      <section>
        <title>广泛（全局）可移植性</title>

        <para>任何人都可以下载具有广发可移植性项目的源码，不用为特定的环境自定义构建就能编译，安装。这是最高级别的可移植性；构建这样的项目不需要做任何额外的工作。该级别的可移植性对开源项目尤为重要，因为开源项目的潜在贡献者需要能很方便的下载源码进行构建。</para>

        <para>任何一个开发者都可以下载具有广泛可移植性项目的源码。</para>
      </section>
    </section>

    <section>
      <title>选择一个适当级别的可移植性</title>

      <para>很显然，你需要避免创建出最坏的情况：不可移植构建。你可以不幸需要在这样的一个组织工作或学习：其核心应用的构建是不可移植的。在这样的组织下，没有特定的人员或机器的帮助，你就不可能部署一个应用。如果不和那个维护该不可移植构建的人协调，很难引入新的项目依赖或变化。当个人或小组需要控制项目如何以及何时构建部署的时候，不可移植构建就会由于一些政治环境因素高速增长。“我们该如何构建该系统？哦，我们需要找到Jack，让他帮我们构建，没有其他人能将其部署到产品环境中”这是一种非常危险的情形，该情形比你想象的普遍得多。如果你为这样的一个组织工作，Maven和Maven
      profile能帮你脱离困境。</para>

      <para>与之完全相反的可移植性范围是广泛可移植性构建。总的来说广泛可移植性构建是最难达到的构建系统。这样的构建严格要求你依赖的项目和工具是免费分发的，在公共环境中可用。很多商业软件包可能被排除在这种可移植性最高的构建外面，因为只有在接受某个许可证后你才能下载它们。广泛可移植性也限制它的依赖能以Maven构件的形式分发。例如，如果你依赖于Oracle
      JDBC驱动，你的用户就需要手工下载安装它们；这就不是广泛可移植性因为你必须为那些有兴趣构建你应用的人发布一组关于创建环境的指令。而另一方面，你可以使用一个在公共Maven仓库中可用的JDBC驱动如MySQL或者HSQLDB。</para>

      <para>如之前叙述的那样，开源项目从拥有最广泛的可移植性构建获益。广泛可移植性构建降低了为开源项目做贡献的低效性。在一个开源项目（如Maven）中，有两个单独的组：最终用户和开发者。当一个项目的最终用户决定为项目贡献一个补丁，它们就需要从使用构建输出过渡到运行一个构建。它们首先需要成为开发者，而如果很难学会如何构建一个项目，这就成为了最终用户花时间为项目做贡献的妨碍因素。在广泛可移植项目中，最终用户不需要遵循一组神秘的构建指令来开始成为开发者。他们可以源码，修改源码，构建，然后提交贡献，这个过程不需要问谁要求帮助建立构建环境。当为开源项目贡献源码的成本更低的时候，你就会看到源码贡献的增长，特别是一些不经意的贡献可能对项目的成功和项目的失败造成很大的影响。在一组广泛的开源项目中使用Maven的一个附加作用就是它使得开发者为不同的开源项目贡献源码变得更加容易。</para>
    </section>
  </section>

  <section>
    <title>通过Maven Profiles实现可移植性</title>

    <para>A profile in Maven is an alternative set of configuration values
    which set or override default values. Using a profile, you can customize a
    build for different environments. Profiles are configured in the
    <filename>pom.xml</filename> and are given an identifier. Then you can run
    Maven with a command-line flag that tells Maven to execute goals in a
    specific profile. The following <filename>pom.xml</filename> uses a
    <literal>production</literal> profile to override the default settings of
    the Compiler plugin.</para>

    <example>
      <title>Using a Maven Profile to Override Production Compiler
      Settings</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt;<co id="coDef-profiles-compile-1"
          linkends="coRef-profiles-compile-1" />
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;<co id="coDef-profiles-compile-2"
          linkends="coRef-profiles-compile-2" />
      &lt;build&gt;<co id="coDef-profiles-compile-3"
          linkends="coDef-profiles-compile-3" />
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;debug&gt;false&lt;/debug&gt;<co
          id="coDef-profiles-compile-4" linkends="coDef-profiles-compile-4" />
              &lt;optimize&gt;true&lt;/optimize&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>In this example, we've added a profile named
    <literal>production</literal> that overrides the default configuration of
    the Maven Compiler plugin, let's examine the syntax of this profile in
    detail.</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-compile-1"
               id="coRef-profiles-compile-1">
        <para>The <sgmltag>profiles</sgmltag> element is in the
        <filename>pom.xml</filename>, it contains one or more
        <sgmltag>profile</sgmltag> elements. Since profiles override the
        default settings in a <filename>pom.xml</filename>, the
        <sgmltag>profiles</sgmltag> element is usually listed as the last
        element in a <filename>pom.xml</filename>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-2"
               id="coRef-profiles-compile-2">
        <para>Each profile has to have an <sgmltag>id</sgmltag> element. This
        <sgmltag>id</sgmltag> element contains the name which is used to
        invoke this profile from the command-line. A profile is invoked by
        passing the <command>-P&lt;profile_id&gt;</command> command-line
        argument to Maven.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-3"
               id="coRef-profiles-compile-3">
        <para>A <sgmltag>profile</sgmltag> element can contain many of the
        elements which can appear under the <sgmltag>project</sgmltag> element
        of a POM XML Document. In this example, we're overriding the behavior
        of the Compiler plugin and we have to override the plugin
        configuration which is normally enclosed in a <sgmltag>build</sgmltag>
        and a <sgmltag>plugins</sgmltag> element.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-4"
               id="coRef-profiles-compile-4">
        <para>We're overriding the configuration of the Maven Compiler plugin.
        We're making sure that the bytecode produced by the production profile
        doesn't contain debug information and that the bytecode has gone
        through the compiler's optimization routines.</para>
      </callout>
    </calloutlist>

    <para>To execute <command>mvn install</command> under the
    <literal>production</literal> profile, you need to pass the
    <command>-Pproduction</command> argument on the command-line. To verify
    that the <literal>production</literal> profile overrides the default
    Compiler plugin configuration, execute Maven with debug output enabled
    (<command>-X</command>) as follows:</para>

    <screen>~/examples/profile $ <command>mvn clean install -Pproduction -X</command>
... (omitting debugging output) ...
[DEBUG] Configuring mojo 'o.a.m.plugins:maven-compiler-plugin:2.0.2:testCompile'
[DEBUG]   (f) basedir = ~\examples\profile
[DEBUG]   (f) buildDirectory = ~\examples\profile\target
...
[DEBUG]   (f) compilerId = javac
[DEBUG]   (f) <emphasis>debug = false</emphasis>
[DEBUG]   (f) failOnError = true
[DEBUG]   (f) fork = false
[DEBUG]   (f) <emphasis>optimize = true</emphasis>
[DEBUG]   (f) outputDirectory = \
          ~\svnw\sonatype\examples\profile\target\test-classes
[DEBUG]   (f) outputFileName = simple-1.0-SNAPSHOT
[DEBUG]   (f) showDeprecation = false
[DEBUG]   (f) showWarnings = false
[DEBUG]   (f) staleMillis = 0
[DEBUG]   (f) verbose = false
[DEBUG] -- end configuration --
... (omitting debugging output) ...
</screen>

    <para>This excerpt from the debug output of Maven shows the configuration
    of the Compiler plugin under the production profile. As shown in the
    output, <varname>debug</varname> is set to false and
    <varname>optimize</varname> is set to true.</para>

    <section>
      <title>覆盖一个项目对象模型</title>

      <para>While the previous example showed you how to override the default
      configuration properties of a single Maven plugin, you still don't know
      exactly what a Maven profile is allowed to override. The short-answer to
      that question is that a Maven profile can override almost everything
      that you would have in a <filename>pom.xml</filename>. The Maven
      <acronym>POM</acronym> contains an element under project called
      <sgmltag>profiles</sgmltag> containing a project's alternate
      configurations, and under this element are profile elements which define
      each profile. Each profile must have an <sgmltag>id</sgmltag>, and other
      than that, it can contain almost any of the elements one would expect to
      see under project. The following <acronym>XML</acronym> document shows
      all of the elements, a profile is allowed to override.</para>

      <para><example>
          <title>Elements Allowed in a Profile</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;build&gt;
        &lt;defaultGoal&gt;...&lt;/defaultGoal&gt;
        &lt;finalName&gt;...&lt;/finalName&gt;
        &lt;resources&gt;...&lt;/resources&gt;
        &lt;testResources&gt;...&lt;/testResources&gt;
        &lt;plugins&gt;...&lt;/plugins&gt;
      &lt;/build&gt;
      &lt;reporting&gt;...&lt;/reporting&gt;
      &lt;modules&gt;...&lt;/modules&gt;
      &lt;dependencies&gt;...&lt;/dependencies&gt;
      &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;
      &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;
      &lt;repositories&gt;...&lt;/repositories&gt;
      &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;
      &lt;properties&gt;...&lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>A profile can override an element shown with ellipses. A profile
      can override the final name of a project's artifact in a profile, the
      dependencies, and the behavior of a project's build via plugin
      configuration. A profile can also override the configuration of
      distribution settings depending on the profile; for example, if you need
      to publish an artifact to a staging server in a staging profile, you
      would create a staging profile which overrides the
      <sgmltag>distributionManagement</sgmltag> element in a profile.</para>
    </section>
  </section>

  <section>
    <title>激活Profile</title>

    <para>In the previous section we showed you how to create a profile that
    overrides default behavior for a specific target environment. In the
    previous build the default build was designed for development and the
    <literal>production</literal> profile exists to provide configuration for
    a production environment. What happens when you need to provide
    customizations based on variables like operating systems or
    <acronym>JDK</acronym> version? Maven provides a way to "activate" a
    profile for different environmental parameters, this is called profile
    activation.</para>

    <para>Take the following example, assume that we have a Java library that
    has a specific feature only available in the Java 6 release: the Scripting
    Engine as defined in <ulink
    url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>. You've
    separated the portion of the library that deals with the scripting library
    into a separate Maven project, and you want people running Java 5 to be
    able to build the project without attempting to build the Java 6 specific
    library extension. You can do this by using a Maven profile that adds the
    script extension module to the build only when the build is running within
    a Java 6 <acronym>JDK</acronym>. First, let's take a look at our project's
    directory layout and how we want developers to build the system.</para>

    <para>When someone runs <command>mvn install</command> with a Java 6
    <acronym>JDK</acronym>, you want the build to include the
    <literal>simple-script</literal> project's build, when they are running in
    Java 5, you would like to skip the <literal>simple-script</literal>
    project build. If you failed to skip the <literal>simple-script</literal>
    project build in Java 5, your build would fail because Java 5 does not
    have the <classname>ScriptEngine</classname> on the classpath. Let's take
    a look at the library project's <filename>pom.xml</filename>:</para>

    <example>
      <title>Dynamic Inclusion of Submodules Using Profile Activation</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jdk16&lt;/id&gt;
      &lt;activation&gt;<co id="coDef-profiles-active-1"
          linkends="coRef-profiles-active-1" />
        &lt;jdk&gt;1.6&lt;/jdk&gt;
      &lt;/activation&gt;
      &lt;modules&gt;<co id="coDef-profiles-active-2" lang=""
          linkends="coRef-profiles-active-2" />
        &lt;module&gt;simple-script&lt;/module&gt;
      &lt;/modules&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>If you run <command>mvn install</command> under Java 1.6, you will
    see Maven descending into the <filename>simple-script</filename>
    subdirectory to build the <literal>simple-script</literal> project. If you
    are running <command>mvn install</command> in Java 1.5, the build will not
    try to build the <literal>simple-script</literal> submodule. Exploring
    this activation configuration in more detail:</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-active-1" id="coRef-profiles-active-1">
        <para>The <sgmltag>activation</sgmltag> element lists the conditions
        for profile activation. In this example, we've specified that this
        profile will be activated by Java versions that begin with "1.6". This
        would include "1.6.0_03", "1.6.0_02", or any other string that began
        with "1.6". Activation parameters are not limited to Java version, for
        a full list of activation parameters, see <xref
        linkend="profile-activation-config"
        xrefstyle="select:title" />.</para>
      </callout>

      <callout arch="" arearefs="coDef-profiles-active-2"
               id="coRef-profiles-active-2">
        <para>In this profile we are adding the module
        <literal>simple-script</literal>. Adding this module will cause Maven
        to look in the <filename>simple-script/</filename> subdirectory for a
        <filename>pom.xml</filename>.</para>
      </callout>
    </calloutlist>

    <section id="profile-activation-config">
      <title>激活配置</title>

      <para>Activations can contain one of more selectors including JDK
      versions, Operating System parameters, files, and properties. A profile
      is activated when all activation criteria has been satisfied. For
      example, a profile could list an Operating System family of Windows, and
      a JDK version of 1.4, this profile will only be activated when the build
      is executed on a Windows machine running Java 1.4. If the profile is
      active then all elements override the corresponding project-level
      elements as if the profile were included with the <command>-P</command>
      command-line argument. The following example, lists a profile which is
      activated by a very specific combination of operating system parameters,
      properties, and a JDK version.</para>

      <para><example>
          <title>Profile Activation Parameters: JDK Version, OS Parameters,
          and Properties</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;dev&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;<co
              id="coDef-profiles-active2-1"
              linkends="coRef-profiles-active2-1" />
        &lt;jdk&gt;1.5&lt;/jdk&gt;<co id="coDef-profiles-active2-2"
              linkends="coRef-profiles-active2-2" />
        &lt;os&gt;
          &lt;name&gt;Windows XP&lt;/name&gt;<co id="coDef-profiles-active2-3"
              linkends="coRef-profiles-active2-3" />
          &lt;family&gt;Windows&lt;/family&gt;
          &lt;arch&gt;x86&lt;/arch&gt;
          &lt;version&gt;5.1.2600&lt;/version&gt;
        &lt;/os&gt;
        &lt;property&gt;
          &lt;name&gt;mavenVersion&lt;/name&gt;<co
              id="coDef-profiles-active2-4"
              linkends="coRef-profiles-active2-4" />
          &lt;value&gt;2.0.5&lt;/value&gt;
        &lt;/property&gt;
        &lt;file&gt;
          &lt;exists&gt;file2.properties&lt;/exists&gt;<co
              id="coDef-profiles-active2-5"
              linkends="coRef-profiles-active2-5" />
          &lt;missing&gt;file1.properties&lt;/missing&gt;
        &lt;/file&gt;
      &lt;/activation&gt;
      ...
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>This previous example defines a very narrow set of activation
      parameters. Let's examine each activation criterion in detail:</para>

      <calloutlist>
        <callout arearefs="coDef-profiles-active2-1"
                 id="coRef-profiles-active2-1">
          <para>The <sgmltag>activeByDefault</sgmltag> element controls
          whether this profile is considered active by default.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-2"
                 id="coRef-profiles-active2-2">
          <para>This profile will only be active for JDK versions that begin
          with "1.5". This includes "1.5.0_01", "1.5.1".</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-3"
                 id="coRef-profiles-active2-3">
          <para>This profile targets a very specific version of Windows XP,
          version 5.1.2600 on a 32-bit platform. If your project uses the
          native plugin to build a C program, you might find yourself writing
          projects for specific platforms.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-4"
                 id="coRef-profiles-active2-4">
          <para>The <sgmltag>property</sgmltag> element tells Maven to
          activate this profile if the property
          <varname>mavenVersion</varname> is set to the value
          <literal>2.0.5</literal>. <varname>mavenVersion</varname> is an
          implicit property that is available to all Maven builds.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-5"
                 id="coRef-profiles-active2-5">
          <para>The <sgmltag>file</sgmltag> element allows us to activate a
          profile based on the presence (or absence) of files. The
          <literal>dev</literal> profile will be activated if a file named
          <filename>file2.properties</filename> exists in the base directory
          of the project. The <literal>dev</literal> profile will only be
          activated if there is no file named
          <filename>file1.properties</filename> file in the base directory of
          the project.</para>
        </callout>
      </calloutlist>
    </section>

    <section>
      <title>通过属性缺失激活</title>

      <para>You can activate a profile based on the value of a property like
      <varname>environment.type</varname>. You can activate a
      <literal>development</literal> profile if
      <varname>environment.type</varname> equals <literal>dev</literal>, or a
      <literal>production</literal> profile if
      <varname>environment.type</varname> equals <literal>prod</literal>. You
      can also activate a profile in the absence of a property. The following
      configuration activates a profile if the property
      <varname>environment.type</varname> is not present during Maven
      execution.</para>

      <para><example>
          <title>Activating Profiles in the Absence of a Property</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;!environment.type&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Note the exclamation point prefixing the property name. The
      exclamation point is often referred to as the "bang" character and
      signifies "not". This profile is activated when no
      <varname>${environment.type}</varname> property is set.</para>
    </section>
  </section>

  <section>
    <title>外部Profile</title>

    <para>If you start making extensive use of Maven profiles, you may want to
    separate your profiles from your POM in a separate file named
    <filename>profiles.xml</filename>. You can mix and match profiles defined
    in the <filename>pom.xml</filename> with profiles defined in the external
    <filename>profiles.xml</filename> file. Just place the
    <sgmltag>profiles</sgmltag> element into <filename>profiles.xml</filename>
    in <varname>${basedir}</varname> and run Maven as you normally would. This
    <filename>profiles.xml</filename> file would look something like the
    following example:</para>

    <example>
      <title>Placing Profiles in a profiles.xml File</title>

      <programlisting language="xml"> &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;debug&gt;true&lt;/debug&gt;
              &lt;optimize&gt;false&lt;/optimize&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;debug&gt;false&lt;/debug&gt;
              &lt;optimize&gt;true&lt;/optimize&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;</programlisting>
    </example>

    <para>You might find that your profiles have grown so large that you are
    having trouble managing the <filename>pom.xml</filename>, or you might
    just find separating the <filename>pom.xml</filename> from the
    <filename>profiles.xml</filename> file a cleaner approach to putting
    everything into a single file. You can invoke profiles stored in
    <filename>profiles.xml</filename> the same way you would invoke them if
    they were defined in the <filename>pom.xml</filename>.</para>
  </section>

  <section>
    <title>Settings Profile</title>

    <para>Project profiles are useful when a specific project needs to
    customize a build setting for a specific environment, but why would you
    want to override a build setting for every project in Maven? How do you do
    something like add an internal repository which is consulted on every
    Maven build? You can do this with a settings profile. Where project
    profiles are concerned with overriding the configuration of a specific
    project, settings profiles can be applied to any and all projects you
    build with Maven. You can place settings profiles in two locations: a user
    specific settings profile defined in
    <filename>~/.m2/settings.xml</filename> or a global settings profile
    defined in <filename>${M2_HOME}/conf/settings.xml</filename>. Here is an
    example of a settings profile defined in
    <filename>~/.m2/settings.xml</filename> which might set some user-specific
    configuration properties for all builds. The following
    <filename>settings.xml</filename> file is defined for user
    <literal>tobrien</literal>:</para>

    <example>
      <title>Defining User-specific Settings Profiles
      (~/.m2/settings.xml)</title>

      <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;dev&lt;/id&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;executions&gt;
           &lt;execution&gt;
              &lt;goals&gt;
                 &lt;goal&gt;sign&lt;/goal&gt;
              &lt;/goals&gt;
           &lt;/execution&gt;
        &lt;/executions&gt;
        &lt;configuration&gt;
           &lt;keystore&gt;/home/tobrien/java/keystore&lt;/keystore&gt;
           &lt;alias&gt;tobrien&lt;/alias&gt;
           &lt;storepass&gt;s3cr3tp@ssw0rd&lt;/storepass&gt;
           &lt;signedjar&gt;
         ${project.build.directory}/signed/${project.build.finalName}.jar
           &lt;/signedjar&gt;
           &lt;verify&gt;true&lt;/verify&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;</programlisting>
    </example>

    <para>The previous example is a plausible use of a user-specific settings
    profile. This example sets user-specific settings like the password and
    alias to use when signing a JAR file during a release. These are
    configuration parameters you wouldn't want to store in a project's shared
    <filename>pom.xml</filename> or a <filename>profiles.xml</filename> file
    because they involve some secrets that should not be public.</para>

    <para>The downside of settings profiles is that they tend to interfere
    with project portability. If the previous example were an open source
    project, a new developer would not be able to sign a JAR until they had
    manually configured a settings profile and talked to one of the existing
    developers. In this case, the security requirements of signing a JAR are
    in conflict with the larger goal of achieving a universally portable
    project build. On most open-source projects, there are tasks that require
    security credentials: publishing an artifact to a remote repository,
    publishing a project's web site, or signing a JAR file. For these tasks,
    the highest level of portability we can hope for is organizational
    portability. These higher security tasks usually require some manual setup
    and configuration of a profile.</para>

    <para>Instead of explicitly specifying the name of the profile with the
    <command>-P</command> command-line argument. You can define a list of
    active profiles which are activated for every project you run. For
    example, if you wanted to activate the <literal>dev</literal> profile
    defined in <filename>settings.xml</filename> for every project you run,
    you would add the following section to your
    <filename>~/.m2/settings.xml</filename> file:</para>

    <para><example>
        <title>Defining Active Settings Profiles</title>

        <programlisting language="xml">&lt;settings&gt;
  ...
  &lt;activeProfiles&gt;
    &lt;activeProfile&gt;dev&lt;/activeProfile&gt;
  &lt;/activeProfiles&gt;
&lt;/settings&gt;
</programlisting>
      </example></para>

    <para>This will activate settings profiles only, not project profiles with
    matching <sgmltag>id</sgmltag> elements. For example, if you had a project
    with a profile defined in its <filename>pom.xml</filename> with an
    <sgmltag>id</sgmltag> of <literal>dev</literal>, it would not be affected
    by the <sgmltag>activeProfile</sgmltag> set in your
    <filename>settings.xml</filename>. This <sgmltag>activeProfile</sgmltag>
    setting only affects profiles defined in your
    <filename>settings.xml</filename> file.</para>

    <section>
      <title>全局Settings Profile</title>

      <para>Just like settings profiles, you can also define a set of global
      profiles in <filename>${M2_HOME}/conf/settings.xml</filename>. Profiles
      defined in this configuration file are available across all users using
      a specific installation of Maven. The ability to define a global
      settings profile is useful if you are creating a customized distribution
      of Maven for a specific organization and you want to ensure that every
      user of Maven has access to a set of build profiles that ensure in-house
      portability. If you need to add custom plugin repositories or define a
      custom set of plugins that are only used by your organization, you could
      distribute a copy of Maven to your users that has these settings "baked
      in". The configuration of global settings profiles is the same as the
      configuration of User-specific settings profiles.</para>
    </section>
  </section>

  <section>
    <title>列出活动的Profile</title>

    <para>Maven profiles can be defined in either
    <filename>pom.xml</filename>, <filename>profiles.xml</filename>,
    <filename>~/.m2/settings.xml</filename>, or
    <filename>${M2_HOME}/conf/settings.xml</filename>. With these four levels,
    there's no good way of keeping track of profiles available to a particular
    project without remembering which profiles are defined in these four
    files. To make it easier to keep track of which profiles are available,
    and where they have been defined, the Maven Help plugin defines a goal,
    <literal>active-profiles</literal>, which lists all the active profiles
    and where they have been defined. You can run the
    <literal>active-profiles</literal> goal, as follows:</para>

    <screen>$ <command>mvn help:active-profiles</command>
Active Profiles for Project 'My Project':

The following profiles are active:

 - my-settings-profile (source: settings.xml)
 - my-external-profile (source: profiles.xml)
 - my-internal-profile (source: pom.xml)</screen>
  </section>

  <section>
    <title>提示和技巧</title>

    <para>Profiles can encourage build portability. If your build needs subtle
    customizations to work on different platforms or if you need your build to
    produce different results for different target platforms, project profiles
    increase build portability. Settings profiles generally decrease build
    portability by adding extra-project information that must be communicated
    from developer to developer. The following sections provide some
    guidelines and some ideas for applying Maven profiles to your
    project.</para>

    <section>
      <title>常见的环境</title>

      <para>One of the core motivations for Maven project profiles was to
      provide for environment-specific configuration settings. In a
      development environment, you might want to produce bytecode with debug
      information and you might want to configure your system to use a
      development database instance. In a production environment you might
      want to produce a signed JAR and configure the system to use a
      production database. In this chapter, we defined a number of
      environments with identifiers like <literal>dev</literal> and
      <literal>prod</literal>. A simpler way to do this would be to define
      profiles that are activated by environment properties and to use these
      common environment properties across all of your projects. For example,
      if every project had a <literal>development</literal> profile activated
      by a property named <varname>environment.type</varname> having a value
      of <literal>dev</literal>, and if those same projects had a
      <literal>production</literal> profile activated by a property named
      <varname>environment.type</varname> having a value of
      <literal>prod</literal>, you could create a default profile in your
      <filename>settings.xml</filename> that always set
      <varname>environment.type</varname> to <literal>dev</literal> on your
      development machine. This way, each project defines a
      <literal>dev</literal> profile activated by the same environment
      variable. Let's see how this is done, the following
      <filename>settings.xml</filename> defines a profile in
      <filename>~/.m2/settings.xml</filename> which sets the
      <varname>environment.type</varname> property to
      <literal>dev</literal>.</para>

      <para><example>
          <title>~/.m2/settings.xml defines a default profile setting
          environment.type</title>

          <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;dev&lt;/environment.type&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
        </example></para>

      <para>This means that every time you run Maven on your machine, this
      profile will be activated and the property
      <varname>environment.type</varname> will have the value
      <literal>dev</literal>. You can then use this property to activate
      profiles defined in a project's <filename>pom.xml</filename> as follows.
      Let's take a look at how a project's <filename>pom.xml</filename> would
      define a profile activated by <varname>environment.type</varname> having
      the value <literal>dev</literal>.</para>

      <para><example id="ex-profile-envtype-pom">
          <title>Project Profile Activated by environment.type equalling
          'dev'</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;dev&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;
          jdbc:mysql://localhost:3306/app_dev
        &lt;/database.url&gt;
        &lt;database.user&gt;development_user&lt;/database.user&gt;
        &lt;database.password&gt;development_password&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;prod&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;jdbc:mysql://master01:3306,slave01:3306/app_prod&lt;/database.url&gt;
        &lt;database.user&gt;prod_user&lt;/database.user&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>This project defines some properties like
      <varname>database.url</varname> and <varname>database.user</varname>
      which might be used to configure another Maven plugin configured in the
      <filename>pom.xml</filename>. There are plugins available that can
      manipulate the database, run SQL, and plugins like the Maven Hibernate3
      plugin which can generate annotated model objects for use in persistence
      frameworks. A few of these plugins, can be configured in a
      <filename>pom.xml</filename> using these properties. These properties
      could also be used to filter resources. In this example, because we've
      defined a profile in <filename>~/.m2/settings.xml</filename> which sets
      <varname>environment.type</varname> to <literal>dev</literal>, the
      development profile will always be activated when we run Maven on our
      development machine. Alternatively, if we wanted to override this
      default, we could set a property on the command-line. If we need to
      activate the production profile, we could always run Maven with:</para>

      <screen>~/examples/profiles $ <command>mvn install -Denvironment.type=prod</command></screen>

      <para>Setting a property on the command-line would override the default
      property set in <filename>~/.m2/settings.xml</filename>. We could have
      just defined a profile with an <sgmltag>id</sgmltag> of "dev" and
      invoked it directly with the <command>-P</command> command-line
      argument, but using this <varname>environment.type</varname> property
      allows us to code other project <filename>pom.xml</filename> files to
      this standard. Every project in your codebase could have a profile which
      is activated by the same <varname>environment.type</varname> property
      set in every user's <filename>~/.m2/settings.xml</filename>. In this
      way, developers can share common configuration for development without
      defining this configuration in non-portable
      <filename>settings.xml</filename> files.</para>
    </section>

    <section>
      <title>保护机密</title>

      <para>This best practice builds upon the previous section. In <xref
      linkend="ex-profile-envtype-pom" xrefstyle="select:title" />, the
      production profile does not contain the
      <varname>database.password</varname> property. I've done this on purpose
      to illustrate the concept of putting secrets in you user-specific
      <filename>settings.xml</filename>. If you were developing an application
      at a large organization which values security, it is likely that the
      majority of the development group will not know the password to the
      production database. In an organization that draws a bold line between
      the development group and the operations group, this will be the norm.
      Developers may have access to a development and a staging environment,
      but they might not have (or want to have) access to the production
      database. There are a number of reasons why this makes sense,
      particularly if an organization is dealing with extremely sensitive
      financial, intelligence, or medical information. In this scenario, the
      production environment build may only be carried out by a lead developer
      or by a member of the production operations group. When they run this
      build using the <literal>prod</literal>
      <varname>environment.type</varname>, they will need to define this
      variable in their <filename>settings.xml</filename> as follows:</para>

      <example>
        <title>Storing Secrets in a User-specific Settings Profile</title>

        <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;prod&lt;/environment.type&gt;
        &lt;database.password&gt;m1ss10nimp0ss1bl3&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
      </example>

      <para>This user has defined a default profile which sets the
      <varname>environment.type</varname> to <literal>prod</literal> and which
      also sets the production password. When the project is executed, the
      production profile is activated by the
      <varname>environment.type</varname> property and the
      <varname>database.password</varname> property is populated. This way,
      you can put all of the production-specific configuration into a
      project's <filename>pom.xml</filename> and leave out only the single
      secret necessary to access the production database.</para>

      <note>
        <para>Secrets usually conflict with wide portability, but this makes
        sense. You wouldn't want to share your secrets openly.</para>
      </note>
    </section>

    <section id="sect-platform-classifier">
      <title>平台分类器</title>

      <para>Let's assume that you have a library or a project that produces
      platform-specific customizations. Even though Java is platform-neutral,
      there are times when you might need to write some code that invokes
      platform-specific native code. Another possibility is that you've
      written some C code which is compiled by the Maven Native plugin and you
      want to produce a qualified artifact depending on the build platform.
      You can set a classifier with the Maven Assembly plugin or with the
      Maven Jar plugin. The following <filename>pom.xml</filename> produces a
      qualified artifact using profiles which are activated by Operation
      System parameters. For more information about the Maven Assembly plugin,
      see <xref linkend="assemblies" />.</para>

      <para><example>
          <title>Qualifying Artifacts with Platform Activated Project
          Profiles</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;win&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;linux&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If the Operating System is in the Windows family, this
      <filename>pom.xml</filename> qualifies the JAR artifact with "-win". If
      the Operating System is in the Unix family, the artifact is qualified
      with "-linux". This <filename>pom.xml</filename> successfully adds the
      qualifiers to the artifacts, but it is more verbose than it need to be
      due to the redundant configuration of the Maven Jar plugin in both
      profiles. This example could be rewritten to use variable substitution
      to minimize redundancy as follows:</para>

      <para><example>
          <title>Qualifying Artifacts with Platform Activated Project Profiles
          and Variable Substitution</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;classifier&gt;${envClassifier}&lt;/classifier&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;win&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;linux&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>In this <filename>pom.xml</filename>, each profile doesn't need to
      include a <sgmltag>build</sgmltag> element to configure the Jar plugin.
      Instead, each profile is activated by the Operating System family and
      sets the <varname>envClassifier</varname> property to either
      <literal>win</literal> or <literal>linux</literal>. This
      <varname>envClassifier</varname> is then referenced in the default
      <filename>pom.xml</filename> <sgmltag>build</sgmltag> element to add a
      classifier to the project's JAR artifact. The JAR artifact will be named
      <code>${finalName}-${envClassifier}.jar</code> and included as a
      dependency using the following dependency syntax:</para>

      <para><example>
          <title>Depending on a Qualified Artifact</title>

          <programlisting language="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.mycompany&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
</programlisting>
        </example></para>
    </section>
  </section>

  <section>
    <title>小结</title>

    <para>When used judiciously, profiles can make it very easy to customize a
    build for different platforms. If something in your build needs to define
    a platform-specific path for something like an application server, you can
    put these configuration points in a profile which is activated by an
    operating system parameter. If you have a project which needs to produce
    different artifacts for different environments, you can customize the
    build behavior for different environments and platforms via
    profile-specific plugin behavior. Using profiles, builds can become
    portable, there is no need to rewrite your build logic to support a new
    environment, just override the configuration that needs to change and
    share the configuration points which can be shared.</para>
  </section>
</chapter>
