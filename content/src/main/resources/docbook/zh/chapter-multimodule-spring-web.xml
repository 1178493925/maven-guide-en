<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="multimodule-web-spring">
  <title>多模块企业级项目</title>

  <section id="multimodule-web-spring-intro">
    <title>简介</title>

    <para>本章，我们创建一个多模块项目，它<indexterm class="startofrange" id="enterprise1a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise1b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise1c">
        <primary>enterprise project, multimodule (example)</primary>
      </indexterm>从<xref linkend="multimodule" />和<xref
    linkend="web" />的样例演化成一个使用了Spring Framework和Hibernate创建的，从Yahoo!
    Weather信息源读取数据，包含一个简单web应用和一个命令行工具的项目。<xref
    linkend="customizing" />中开发的<varname>simple-weather</varname>代码将会和<xref
    linkend="web" />中开发的<varname>simple-weather</varname>项目结合。在创建这个多模块项目的过程中，我们将会探索Maven并且讨论用它来创建模块化项目以鼓励重用的不同方式。</para>

    <section>
      <title>下载本章样例</title>

      <para>该样例中开发的多模块项目包含了<xref linkend="customizing" />和<xref
      linkend="web" />中项目的修改的版本，我们不会再使用Maven
      Archetype插件来生成这个多模块项目。我们强烈建议当你在阅读本章内容的时候，下载样例代码作为一个补充参考。本章的样例项目包含在本书的样例代码中，你可以从两个地方下载，<ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink>或者<ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>。解开存档文件至任意目录，然后到<filename>ch07/</filename>目录。在<filename>ch07/</filename>目录你会看到一个名为<filename>simple-parent/</filename>的目录，它包含了本章开发出来的多模块Maven项目。在这个<filename>simple-parent/</filename>项目目录中，你会看到一个<filename>pom.xml</filename>，以及五个子模块目录<filename>simple-model/</filename>，<filename>simple-persist/</filename>，<filename>simple-command/</filename>，<filename>simple-weather/</filename>和<filename>simple-webapp/</filename>。如果你想要在浏览器里看样例代码，访问<ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink>，然后点击<filename>ch07/</filename>目录。</para>
    </section>

    <section>
      <title>多模块企业级项目</title>

      <para>展示一个巨大企业级项目的复杂度远远超出了本书的范围。这样的项目的特征有，多数据库，与外部系统的集成，子项目通过部分来划分。这些项目通常跨越了数千行代码，牵涉了数十或数百软件开发者的努力。虽然这样的完整样例超出了本书的范围，我们仍然可以为你提供一个能让你想起大型企业应用的样例项目。在小结中我们提议了一些在本章描述之外的模块化可能性。</para>

      <para>本章，我们将会看一个多模块Maven项目，它将产生两个应用程序：一个对于Yahoo!
      Weather信息源命令行查询工具，以及查询同样信息源的一个web应用。两个应用都会将查询结果存储到一个嵌入式数据库中。都允许用户从嵌入式数据库中获取历史天气数据。都会重用应用程序逻辑，并且共享一个持久化类库。本章样例基于在<xref
      linkend="customizing" />中介绍的Yahoo! Weather解析代码构建。该项目被划分成如<xref
      linkend="fig-multimodule-web-spring-projects" />所示的五个子项目。</para>

      <figure id="fig-multimodule-web-spring-projects">
        <title>多模块企业级应用的模块关系</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/multimodule-web-spring_projects.png"
                       scalefit="1" width="8in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>在<xref
      linkend="fig-multimodule-web-spring-projects" />中，你能看到simple-parent有五个子模块，它们分别是：</para>

      <variablelist>
        <varlistentry>
          <term>simple-model</term>

          <listitem>
            <para>该模块定义了一个简单的对象模型，对从Yashoo!
            Weather信息源返回的数据建模。该对象模型包含了<classname>Weather</classname>，<classname>Condition</classname>，<classname>Atmosphere</classname>，<classname>Location</classname>，和<classname>Wind</classname>对象。当我们的应用程序解析Yahoo!
            Weather信息源的时候，<varname>simple-weather</varname>中定义的解析器会解析<acronym>XML</acronym>并创建供应用程序使用的<classname>Weather</classname>对象。该项目还包含了使用Hibernate
            3标注符标注的模型对象，它们在<varname>simple-persist</varname>的逻辑中被用来匹配每个模型对象至关系数据库中对应的表。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-weather</term>

          <listitem>
            <para>该模块包含了所有用来从Yahoo!
            Weather数据源获取数据并解析结果<acronym>XML</acronym>的逻辑。从数据源返回的<acronym>XML</acronym>被转换成<varname>simple-model</varname>中定义的模型对象。<varname>simple-weather</varname>有一个对<varname>simple-model</varname>的依赖。<varname>simple-weather</varname>定义了一个<classname>WeatherService</classname>对象，该对象会被<varname>simple-command</varname>和<varname>simple-webapp</varname>项目引用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-persist</term>

          <listitem>
            <para>该模块包含了一些数据访问对象(<acronym>DAO</acronym>)，这些对象将<classname>Weather</classname>对象存储在一个内嵌数据库中。这个多模块项目中的两个应用都会使用<varname>simple-persist</varname>中定义的<acronym>DAO</acronym>来将数据存储至内嵌数据库中。本项目中定义的<acronym>DAO</acronym>能理解并返回<varname>simple-model</varname>定义的模型对象。<varname>simple-persist</varname>有一个对<varname>simple-model</varname>的依赖，它也依赖于模型对象上的Hibernate标注。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-webapp</term>

          <listitem>
            <para>这个web应用项目包含了两个Spring
            <acronym>MVC</acronym>控制器实现，控制器使用了<varname>simple-weather</varname>中定义的<classname>WeatherService</classname>，以及<varname>simple-persist</varname>中定义的<acronym>DAO</acronym>。<varname>simple-webapp</varname>有对于<varname>simple-weather</varname>和<varname>simple-persist</varname>的直接依赖；还有一个对于<varname>simple-model</varname>的传递性依赖。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-command</term>

          <listitem>
            <para>该模块包含了一个用来查询Yahoo!
            Weather信息源的简单命令行工具。它包含了一个带有静态<methodname>main()</methodname>方法的类，与<varname>simple-weather</varname>中定义的<classname>WeatherService</classname>和<varname>simple-persist</varname>中定义的<acronym>DAO</acronym>交互。<varname>simple-command</varname>有对于<varname>simple-weather</varname>和<varname>simple-persist</varname>的直接依赖；还有一个对于<varname>simple-model</varname>的传递性依赖。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>本章设计的项目一方面够简单，以能在一本书中介绍，又够复杂，能提供一组五个子模块。该样例有一个带有五个类的模型项目，带有两个服务类的持久化类库，带有五六个类的天气解析类库，但是一个现实系统可能有一个带有数百对象的模型项目，很多持久化类库，以及跨越多个部门的服务类库。虽然我们试图确保本例中的代码尽可能的直接以能在短时间内理解，但我们也不麻烦的以模块化的方式构建了这个项目。你可能会要看一下本章的样例，然后会认为Maven为我们这个只有五个类的模型项目带来了太多的复杂度。虽然使用Maven确实建议一定程度的模块化，但这里我们不怕麻烦的将样例项目弄得复杂，目的是展示Maven的多模块特性。</para>
    </section>

    <section>
      <title>本例中所用的技术</title>

      <para>本章样例中涉及了一些十分流行，但与Maven没有直接关系的而技术。这些技术是Spring
      Framework和Hibernate。Spring
      Framework是一个反转控制(<acronym>IoC</acronym>)容器，以及一组目的在于简化与各种<acronym>J2EE</acronym>类库交互的框架。使用Spring
      Framework作为应用程序开发的基础框架能让你访问很多有用的抽象接口，它们能简化与持久化框架如Hibernate或者iBatis的交互，以及企业<acronym>API</acronym>如<acronym>JDBC</acronym>，<acronym>JNDI</acronym>，和<acronym>JMS</acronym>。Spring
      Framework在过去一些年变得十分流行，作为对来自Sun微系统的重量级企业标准的替代。Hibernate是一个被广泛使用的对象-关系映射框架，能让你与关系数据库的交互就像它们是Java对象的集合一样。本例关注构建一个简单的web应用和一个命令行应用，它们使用Spring
      Framework为应用暴露了一组可重用的组件，使用Hibernate将天气数据持久化至内嵌数据库。</para>

      <para>我们决定包含对这些框架的参考以展示在使用Maven的时候如何使用这些技术构建项目。虽然本章中我们会大概介绍这些技术，但不是完整的解释这些技术。要了解更多关于Spring
      Framework的信息，请查看该项目的web站点：<ulink
      url="http://www.springframework.org/">http://www.springframework.org/</ulink>。要了解更多关于Hibernate和Hibernate标注的信息，请查看该项目的web站点：<ulink
      url="http://www.hibernate.org">http://www.hibernate.org</ulink>。本章使用了<acronym>HSQLDB</acronym>作为一个内嵌数据库；要了解更多的关于该数据库的信息，访问该项目的web站点：<ulink
      url="http://hsqldb.org/">http://hsqldb.org/</ulink>。</para>
    </section>
  </section>

  <section>
    <title>simple-parent项目</title>

    <para><varname>该simple-parent项目有一个</varname><indexterm
        class="startofrange" id="enterprise2a">
        <primary>simple parent project (example)</primary>

        <secondary>multimodule enterprise</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise2b">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>simple parent project</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise2c">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>simple parent project</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise2d">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>simple parent project</secondary>
      </indexterm> <filename>pom.xml</filename>
    ，它引用了五个子模块：<varname>simple-command</varname>，<varname>simple-model</varname>，<varname>simple-weather</varname>，<varname>simple-persist</varname>，和<varname>simple-webapp</varname>。顶层的<filename>pom.xml</filename>在<xref
    linkend="ex-multimodule-web-spring-parent" />中显示。</para>

    <example id="ex-multimodule-web-spring-parent">
      <title>simple-parent 项目的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
  &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;Chapter 7 Simple Parent Project&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;simple-command&lt;/module&gt;
    &lt;module&gt;simple-model&lt;/module&gt;
    &lt;module&gt;simple-weather&lt;/module&gt;
    &lt;module&gt;simple-persist&lt;/module&gt;
    &lt;module&gt;simple-webapp&lt;/module&gt;
  &lt;/modules&gt;

  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;source&gt;1.5&lt;/source&gt;
            &lt;target&gt;1.5&lt;/target&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/pluginManagement&gt; 
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <para>注意这个父<acronym>POM</acronym>和<xref
    linkend="ex-multimodule-parent-pom" />中定义的父<acronym>POM</acronym>的相似度。这两个<acronym>POM</acronym>唯一真正不同的地方是子模块列表。前面的样例中至列出了两个子模块，而这里的父<acronym>POM</acronym>列出了五个子模块。下面的小节会详细讨论所有这五个子模块。因为我们的样例使用了Java标注，我们将编译器的目标配置成Java
    5 <acronym>JVM</acronym>。</para>
  </section>

  <section>
    <title>simple-model模块</title>

    <para>大多数企业项目需要做的第一件事情是建立对象模型。一个对象模型抓取了系统中一组核心的领域对象。一个银行系统可能会有包括<classname>Account</classname>，<classname>Customer</classname>，<classname>Transaction</classname>
    的对象模型。或者有一个对运动比赛比分建模系统，有一个<classname>Team</classname>和一个<classname>Game</classname>对象。不管它是什么，你都需要将你系统中的概念建模成对象模型。在Maven项目中，将这个对象模型分割成单独的项目以被广泛引用，是一种常用的实践。在我们这个系统中，我们将每个对Yahoo!
    Weather数据源的查询建模成为<classname>Weather</classname>对象，它本身又引用了四个其它的对象。风向，风速等存储<classname>Wind</classname>在对象中。地址信息包括邮编，城市等信息存储在<classname>Location</classname>类中。大气信息如湿度，可见度，气压等存储在<classname>Atmosphere</classname>类中。而对环境，气温，以及观察日期的文本描述存储在<classname>Condition</classname>类中。</para>

    <figure>
      <title>天气数据的简单对象模型</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-spring_object-model.png"
                     scalefit="1" width="5in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>这个简单对象模型的<filename>pom.xml</filename>文件含有一个依赖需要一些解释。我们的对象模型<indexterm>
        <primary>Hibernate annotations</primary>
      </indexterm><indexterm>
        <primary>annotations (Hibernate)</primary>
      </indexterm>用Hibernate标注符标注了。我们用这些标注来映射模型对象至关系数据库中的表。这个依赖是<varname>org.hibernate:hibernate-annotations:3.3.0.ga</varname>。看一下<xref
    linkend="example_simple-model_pom.xml" />中显示的<filename>pom.xml</filename>，然后看接下来几个展示这些标注的例子。</para>

    <example id="example_simple-model_pom.xml">
      <title>simple-model 的 pom.xml</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Object Model&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>在<filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>中，有<filename>Weather.java</filename>，它包含了一个注解的模<classname>Weather</classname>型对象。这个<classname>Weather</classname>对象是一个简单的Java
      bean。这意味着它有私有成员变量如<varname>id</varname>, <varname>location</varname>,
      <varname>condition</varname>, <varname>wind</varname>,
      <varname>atmosphere</varname>, 和
      <varname>date</varname>，通过公共的getter和setter方法暴露，并且遵循这样的模式：如果一个属性名为<literal>name</literal>，那么会有一个公有的无参数方法<methodname>getName()</methodname>，还有一个带有一个参数的setter方法<methodname
      role="keep-together">setName(String
      name)</methodname>。我们只是展示了<varname>id</varname>属性的getter和setter方法，其它属性的getter和setter方法类似，所以这里跳过了，以节省篇幅。请看<xref
      linkend="example_weather_model_object" />。</para>
    </example>

    <example id="example_weather_model_object">
      <title>标注的Weather模型对象</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

import java.util.Date;

@Entity
@NamedQueries({
  @NamedQuery(name="Weather.byLocation", 
              query="from Weather w where w.location = :location")
})
public class Weather {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(cascade=CascadeType.ALL)
    private Location location;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Condition condition;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Wind wind;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Atmosphere atmosphere;

    private Date date;
    
    public Weather() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // All getter and setter methods omitted...
}
</programlisting>
    </example>

    <para>在<classname>Weather</classname>类中，我们使用Hibernate标注以为<varname>simple-persist</varname>项目提供指导。这些标注由Hibernate用来将对象与关系数据库映射。尽管对HIberante标注的完整解释超出了本书的范围，这里<indexterm>
        <primary sortas="Entity annotation (Hibernate)">@Entity annotation
        (Hibernate)</primary>
      </indexterm>是一个为好奇者的简单解释。<classname>@Entity</classname>标注标记一个类为持久化对象。我们省略了这个类的<indexterm>
        <primary sortas="Table annotation (Hibernate)">@Table annotation
        (Hibernate)</primary>
      </indexterm><classname>@Table</classname>标注，因此Hibernate将会使用这个类的名字来映射表名。<indexterm>
        <primary sortas="NamedQueries annotation (Hibernate)">@NamedQueries
        annotation (Hibernate)</primary>
      </indexterm><classname>@NamedQueries</classname>注解定义了一个<varname>simple-persist</varname>中<classname>WeatherDAO</classname>使用的查询。<indexterm>
        <primary sortas="NamedQuery annotation (Hibernate)">@NamedQuery
        annotation (Hibernate)</primary>
      </indexterm><classname>@NamedQuery</classname>注解中的查询语句是用一个叫做<indexterm>
        <primary>HQL (Hibernate Query Language)</primary>
      </indexterm>Hibernate查询语言(<acronym>HQL</acronym>)编写的。每个成员变量的注解定义了这一列的类型，以及该列暗示的表关联关系。</para>

    <variablelist>
      <varlistentry>
        <term role="plain"><varname>Id</varname></term>

        <listitem>
          <para><varname>id</varname>属性用<classname>@Id</classname>进行标注。这标记<varname>id</varname>属性为一个包含数据库表主键的属性。<classname>@GeneratedValue</classname>控制新的主键值如何产生。该例中，我们使用<varname>IDENTITY</varname>
          <classname>GenerationType</classname>，它使用了下层数据库的主键生成设施。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Location</varname></term>

        <listitem>
          <para>每个<classname>Weather</classname>对象实例对应了一个<classname>Location</classname>对象。一个<classname>Location</classname>对象含有一个邮政编码，而<classname>@ManyToOne</classname>确认所有指向同一个<classname>Location</classname>对象的<classname>Weather</classname>对象引用了同样一个实例。<classname>@ManyToOne</classname>的<varname>cascade</varname>属性确保每次我们持久化一个<classname>Weather</classname>对象的时候也会持久化一个<classname>Location</classname>对象。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Condition</varname>,
        <varname>Wind</varname>, <varname>Atmosphere</varname></term>

        <listitem>
          <para>这些对象的每一个都作为<classname>@OneToOne</classname>而且<classname>CascadeType</classname>为<varname>ALL</varname>进行映射。这意味着每次我们保存一个<classname>Weather</classname>对象，我们将会往<varname>Weather</varname>表，<varname>Condition</varname>表，<varname>Wind</varname>表，和<varname>Atmosphere</varname>表，插入一行，</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Date</varname></term>

        <listitem>
          <para><varname>Date</varname>没有被标注，这以为着Hibernate将会使用所有列的默认值来定义该映射。列名将会是<literal>date</literal>，列的类型会是匹配<classname>Date</classname>对象的适当时间。</para>

          <note>
            <para>如果你有一个希望从表映射中忽略的属性，你可以使用<classname>@Transient</classname>标注这个属性。</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>接着，看一下一个二级的模型对象，<classname>Condition</classname>，如<xref
    linkend="example_condition_model_object" />所示。这个类同样也存在于<filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>。</para>

    <example id="example_condition_model_object">
      <title>simple-model 的 Condition 模型对象</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

@Entity
public class Condition {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    private String text;
    private String code;
    private String temp;
    private String date;

    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="weather_id", nullable=false)
    private Weather weather;

    public Condition() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // All getter and setter methods omitted...
}</programlisting>
    </example>

    <para>这个<classname>Condition</classname>类类似于<classname>Weather</classname>类。它被标注为一个<classname>@Entity</classname>，在<varname>id</varname>属性上也有相似的标注。<varname>text</varname>，<varname>code</varname>，<varname>temp</varname>，和<varname>date</varname>属性也都使用默认的列设置，<varname>weather</varname>属性使用了<classname>@OneToOne</classname>进行标注，而另一个标注通过一个名为<varname>weather_id</varname>的外键引用关联的<classname>Weather</classname>对象。</para>
  </section>

  <section>
    <title>simple-weather模块</title>

    <para>我们将要检查的下一个模块是一个<indexterm class="startofrange" id="enterprise4a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>Simple Weather module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise4b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>Simple Weather module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise4c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>Simple Weather module of</secondary>
      </indexterm>“服务”。这个simple-weather模块包含了所有从Yahoo! Weather
    <acronym>RSS</acronym>数据源获取数据并解析的必要逻辑。虽然simple-weather只包含了三个Java类和一个JUnit测试，它还将展现为一个单独的组件，<classname>WeatherService</classname>，同时为简单web应用和简单命令行工具服务。经常一个企业级项目会包含一些<acronym>API</acronym>模块，这写模块包含了重要的业务逻辑，或者与外部系统交互的逻辑。一个银行系统可能有一个模块，从第三方数据提供者获取并解析数据，而一个显示赛事比分的系统可能会与一个提供实时篮球或足球比分的<acronym>XML</acronym>数据源进行交互。在<xref
    linkend="example_simple-weather_module_pom" />中，该模块封装了所有的网络活动，以及与Yahoo!
    Weather交互涉及的<acronym>XML</acronym>解析活动。其它依赖于该模块的项目只要简单的调用<classname>WeatherService</classname>的<methodname
    role="keep-together">retrieveForecast()</methodname>方法，该方法接受一个邮政编码作为参数，返回一个<classname>Weather</classname>对象。</para>

    <example id="example_simple-weather_module_pom">
      <title>simple-weather 模块的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Weather API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <para>这个<varname>simple-weather</varname>
    <acronym>POM</acronym>扩展了<varname>simple-parent</varname>
    <acronym>POM</acronym>，设置打包方式为<varname>jar</varname>，然后添加了下列的依赖：</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term>

        <listitem>
          <para><varname>simple-weather</varname>将Yahoo! Weather
          <acronym>RSS</acronym>数据源解析成一个<classname>Weather</classname>对象。
          它有一个对<varname>simple-model</varname>的直接依赖。.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>log4j:log4j:1.2.14</literal></term>

        <listitem>
          <para><varname>simple-weather</varname>使用Log4J类库来打印日志信息。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>dom4j:dom4j:1.6.1 and
        jaxen:jaxen:1.1.1</literal></term>

        <listitem>
          <para>这两个依赖都用来解析从Yahoo! Weather返回的<acronym>XML</acronym>。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.apache.commons:commons-io:1.3.2
        (scope=test)</literal></term>

        <listitem>
          <para>这个<literal>test</literal>范围的依赖是由<classname>YahooParserTest</classname>使用的。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>接下来是<classname>WeatherService</classname>类，在<xref
    linkend="example_weatherservice_class" />中显示。这个类和<xref
    linkend="multimodule-weather-service" />中的WeatherService类看起来很像。虽然<classname>WeatherService</classname>名字一样，但与本章中的样例还是有细微的差别。这个版本的<methodname>retrieveForecast()</methodname>方法返回一个<classname>Weather</classname>对象，而格式就留给调用<classname>WeatherService</classname>的程序去处理。其它的主要变化是，<classname>YahooRetriever</classname>和<classname>YahooParser</classname>都是<classname>WeatherService</classname>
    bean的bean属性。</para>

    <example id="example_weatherservice_class">
      <title>WeatherService 类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherService {

  private YahooRetriever yahooRetriever;
  private YahooParser yahooParser;

  public WeatherService() {}

  public Weather retrieveForecast(String zip) throws Exception {
    // Retrieve Data
    InputStream dataIn = yahooRetriever.retrieve(zip);

    // Parse DataS
    Weather weather = yahooParser.parse(zip, dataIn);

    return weather;
  }

  public YahooRetriever getYahooRetriever() {
    return yahooRetriever;
  }

  public void setYahooRetriever(YahooRetriever yahooRetriever) {
    this.yahooRetriever = yahooRetriever;
  }

  public YahooParser getYahooParser() {
    return yahooParser;
  }

  public void setYahooParser(YahooParser yahooParser) {
    this.yahooParser = yahooParser;
  }
}
</programlisting>
    </example>

    <para>最后，在这个项目中我们有一个被Spring Framework用来创建<indexterm>
        <primary>ApplicationContext (Spring Framework)</primary>
      </indexterm><classname>ApplicationContext</classname>的<acronym>XML</acronym>文件。首先，一些解释：两个应用程序，web应用和命令行工具，都需要和<classname>WeatherService</classname>类交互，而且它们都使用名字<varname>weatherService</varname>从Spring
    <classname>ApplicationContext</classname>获取此类的一个实例。我们的web应用使用一个与<classname>WeatherService</classname>实例关联的Spring
    <acronym>MVC</acronym>控制器，我们的命令行应用在静态的<methodname>main()</methodname>方法中从<classname>ApplicationContext</classname>载入这个<classname>WeatherService</classname>。为了鼓励重用，我们已经在<filename>src/main/resources</filename>中包含了一个<filename>applicationContext-weather.xml</filename>文件，这样便在classpath中可用。依赖于<varname>simple-weather</varname>模块的模块可以使用Spring
    Framework中的<classname>ClasspathXmlApplicationContext</classname>载入这个Application
    Context。之后它们就能引用名为<varname>weatherService</varname>的<classname>WeatherService</classname>实例。</para>

    <example>
      <title>simple-weather模块的Spring Application Context</title>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    default-lazy-init="true"&gt;

    &lt;bean id="weatherService" 
             class="org.sonatype.mavenbook.weather.WeatherService"&gt;
      &lt;property name="yahooRetriever" ref="yahooRetriever"/&gt;
      &lt;property name="yahooParser" ref="yahooParser"/&gt;
    &lt;/bean&gt;    

    &lt;bean id="yahooRetriever" 
             class="org.sonatype.mavenbook.weather.YahooRetriever"/&gt;    

    &lt;bean id="yahooParser" 
             class="org.sonatype.mavenbook.weather.YahooParser"/&gt;
&lt;/beans&gt;</programlisting>
    </example>

    <para>该文档定义了三个bean：<varname>yahooParser</varname>，<varname>yahooRetriever</varname>，和<varname>weatherService</varname>。<varname>weatherService</varname>
    bean是<classname>WeatherService</classname>的一个实例，这个<acronym>XML</acronym>文档通过引用对应类的命名实例来填充<varname>yahooParser</varname>和<varname>yahooRetriever</varname>属性。将这个<filename>applicationContext-weather.xml</filename>文件看作是定义了这个多模块项目中一个子系统的架构。其它项目如<varname>simple-webapp</varname>和<varname>simple-command</varname>可以引用这个上下文，获取一个已经建立好与<classname>YahooRetriever</classname>和<classname>YahooParser</classname>实例关系的<classname>WeatherService</classname>实例。</para>
  </section>

  <section>
    <title>simple-persist模块</title>

    <para>该模块定义了两个简单的数据访问对象（DAO）。一个DAO<indexterm>
        <primary>DAO (Data Access Objects)</primary>
      </indexterm><indexterm class="startofrange" id="enterprise5a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>Simple Persist module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise5b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>Simple Persist module of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise5c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>Simple Persist module of</secondary>
      </indexterm>是一个提供持久化操作接口的对象。在这个应用中我们使用了对象关系映射（ORM）框架Hibernate，DAO通常在对象旁边定义。在本项目中，我们定义两个DAO对象：<varname
    role="keep-together">WeatherDAO</varname>和<varname>LocationDAO</varname>。<varname>WeatherDAO</varname>类允许我们保存一个<varname>Weather</varname>对象至数据库，根据<literal>id</literal>获取一个<varname>Weather</varname>对象，获取匹配特定<varname>Location</varname>的<varname>Weather</varname>对象。<varname>LocationDAO</varname>有一个方法允许我们根据邮政编码获取<varname>Location</varname>对象。首先，让我们看一下<xref
    linkend="ex-simple-persist-POM" />中的<literal>simple-persist</literal>
    POM。</para>

    <example id="ex-simple-persist-POM">
      <title>simple-persist 的 POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Persistence API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;3.2.5.ga&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
          &lt;artifactId&gt;jta&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
      &lt;version&gt;1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>这个<acronym>POM</acronym>文件引用<varname>simple-parent</varname>作为一个父<acronym>POM</acronym>，它定义了一些依赖。<varname>simple-persist</varname>的<acronym>POM</acronym>中列出的依赖有：</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term>

        <listitem>
          <para>就像<varname>simple-weather</varname>模块一样，这个持久化模块引用了<varname>simple-model</varname>中定义的核心模型对象。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.hibernate:hibernate:3.2.5.ga</literal></term>

        <listitem>
          <para>我们定义了一个对HIbernate版本3.2.5ga的依赖，但注意我们排除Hibernate的一个依赖。这么做是因为<varname>javax.</varname><varname>transaction:</varname><varname>javax</varname><indexterm>
              <primary>dependencies</primary>

              <secondary>javax.transaction:javax (unavailable)</secondary>
            </indexterm><indexterm>
              <primary>javax.transaction:javax dependency
              (unavailable)</primary>
            </indexterm>依赖在公共Maven仓库中不可用。此依赖正好是Sun依赖中的一个，不能免费在中央Maven仓库中提供。为了避免烦人的信息告诉我们去下载非免费的依赖，我们简单的从Hibernate排除这个依赖然后添加一个geronimo-jta_1.1_spec依赖。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.apache.geronimo.specs:geronimo-jta_1.1_spec:1.1</literal></term>

        <listitem>
          <para>就像Servlet和JSP <acronym>API</acronym>，Apache
          Geronimo项目也根据Apache许可证友好的发布了一些认证过的企业级<acronym>API</acronym>。这意味着不管什么时候某个组件告诉你它依赖于<acronym>JDBC</acronym>，<acronym>JNDI</acronym>，和<acronym>JTA</acronym>
          <acronym>API</acronym>，你都可以查一下groupId为<varname>org.apache.geronimo.specs</varname>下的对应类库。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.springframework:spring:2.0.7</literal></term>

        <listitem>
          <para>这里包含了整个Spring Framework作为一个依赖<indexterm>
              <primary>Spring Framework</primary>
            </indexterm>。</para>

          <note>
            <para>只依赖于你正使用的Spring组件是一个很好的实践。Spring
            Framework项目很友好的创建了一些有针对性的构件如<varname>spring-hibernate3</varname>。</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>为什么依赖于Spring呢？当和Hibernate集成的时候，Spring允许我们使用一些帮助类如<classname>HibernateDaoSupport</classname>。作为一个<classname>HibernateDaoSupport</classname>的样例，看一下<xref
    linkend="ex-persist-weatherdao-class" />中的<classname>WeatherDAO</classname>代码。</para>

    <example id="ex-persist-weatherdao-class">
      <title>simple-persist'的WeatherDAO类</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.persist;

import java.util.ArrayList;
import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherDAO extends HibernateDaoSupport<co id="coDef-hibDao-1"
          linkends="coRef-hibDao-2" /> {

    public WeatherDAO() {}

    public void save(Weather weather) {<co id="coDef-hibDao-2"
          linkends="coRef-hibDao-2" />
      getHibernateTemplate().save( weather );
    }

    public Weather load(Integer id) {<co id="coDef-hibDao-3"
          linkends="coRef-hibDao-3" />
      return (Weather) getHibernateTemplate().load( Weather.class, id);
    }

    @SuppressWarnings("unchecked")
    public List&lt;Weather&gt; recentForLocation( final Location location ) {
      return (List&lt;Weather&gt;) getHibernateTemplate().execute(
        new HibernateCallback() {<co id="coDef-hibDao-4"
          linkends="coRef-hibDao-4" />
        public Object doInHibernate(Session session) {
          Query query = getSession().getNamedQuery("Weather.byLocation");
          query.setParameter("location", location);
          return new ArrayList&lt;Weather&gt;( query.list() );
        }
      });
    }
}</programlisting>
    </example>

    <para>就是这样。你已经编写了一个类，它能插入新的行，根据主键选取，以及能查找所有Weather表根据id连接Location表的结果。很显然，我们不能将书停在这里，然后花500页给你解释Hibernate的运作详情，但我们能做一些快速简单的解释：</para>

    <calloutlist>
      <callout arearefs="coDef-hibDao-1" id="coRef-hibDao-1">
        <para>继承<classname>HibernateDaoSupport</classname>的类。这个类会和Hibernate
        <classname>SessionFactory</classname>关联，后者将被用来创建Hibernate
        <classname>Session</classname>对象。在Hibernate中，每个对象都涉及<classname>Session</classname>对象，一个<classname>Session</classname>是访问下层数据库的中介，它也负责管理对<classname>DataSource</classname>的JDBC连接。继承<classname>HibernateDaoSupport</classname>也意味着我们能够使用<methodname>getHibernateTemplate()</methodname>访问<classname>HibernateTemplate</classname>。能使用<classname>HibernateTemplate</classname>完成的操作例子有……</para>
      </callout>

      <callout arearefs="coDef-hibDao-2" id="coRef-hibDao-2">
        <para><methodname>save()</methodname>方法接受一个<classname>Weather</classname>实例然后调用<classname>HibernateTemplate</classname>上的<methodname>save()</methodname>方法。<classname>HibernateTemplate</classname>简化了常见的HIbernate操作的调用，并别将所有数据库特有的异常转换成了运行时异常。这里我们调用<methodname>save()</methodname>，它往<classname>Weather</classname>表中插入一条新的记录。可选的操作有<methodname>update()</methodname>，它更新已存在的一行，或者<methodname>saveOrUpdate()</methodname>，它会根据Weather中的non-null
        id属性是否存在，执行保存或者更新。</para>
      </callout>

      <callout arearefs="coDef-hibDao-3" id="coRef-hibDao-3">
        <para><methodname>load()</methodname>方法，同样，也只是调用<classname>HibernateTemplate</classname>实例的方法。<classname>HibernateTemplate</classname>上的<methodname>load()</methodname>接受一个<classname>Class</classname>对象和一个<classname>Serializable</classname>对象。本例中，<classname>Serializable</classname>对应于要载入的<classname>Weather</classname>对象的<varname>id</varname>的值。</para>
      </callout>

      <callout arearefs="coDef-hibDao-4" id="coRef-hibDao-4">
        <para>最后一个方法<methodname>recentForLocation()</methodname>调用定义在<classname>Weather</classname>模型对象中的<classname>NamedQuery</classname>。如果你的记忆力足够好，你就知道<classname>Weather</classname>模型对象定义了一个命名查询"Weather.byLocation"，查询为"from
        Weather w where w.location =
        :location"。我们通过<classname>HibernateCallback</classname>中的Hibernate
        <classname>Session</classname>对象来载入<classname>NamedQuery</classname>，<classname>HibernateCallback</classname>由<classname>HibernateTemplate</classname>的<methodname>execute()</methodname>方法执行。在这个方法中你能看到我们填充了一个命名参数location，它来自于<methodname>recentForLocation()</methodname>方法的参数。</para>
      </callout>
    </calloutlist>

    <para>现在是时候阐明一些情况了。<classname>HibernateDaoSupport</classname>和<classname>HibernateTemplate</classname>是来自于Spring
    Framework的类。它们由Spring Framework创建，目的是减少编写Hibernate
    <acronym>DAO</acronym>对象的痛苦。为了支持这个<acronym>DAO</acronym>，我们需要在<varname>simple-persist</varname>的Spring
    <classname>ApplicationContext</classname>定义中做一些配置。<xref
    linkend="ex-persist-spring" />中显示的XML文档存储在<filename>src/main/resources</filename>，名为<filename
    role="keep-together">applicationContext-persist.xml</filename>。</para>

    <example id="ex-persist-spring">
      <title>simple-persist 的 Spring Application Context</title>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
    default-lazy-init="true"&gt;

    &lt;bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
        &lt;property name="annotatedClasses"&gt;
            &lt;list&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Atmosphere&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Condition&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Location&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Weather&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Wind&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;
                &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.transaction.factory_class"&gt;
                  org.hibernate.transaction.JDBCTransactionFactory
                &lt;/prop&gt;
                &lt;prop key="hibernate.dialect"&gt;
                  org.hibernate.dialect.HSQLDialect
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.pool_size"&gt;0&lt;/prop&gt;
                &lt;prop key="hibernate.connection.driver_class"&gt;
                  org.hsqldb.jdbcDriver
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.url"&gt;
                  jdbc:hsqldb:data/weather;shutdown=true
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.username"&gt;sa&lt;/prop&gt;
                &lt;prop key="hibernate.connection.password"&gt;&lt;/prop&gt;
                &lt;prop key="hibernate.connection.autocommit"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.jdbc.batch_size"&gt;0&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="locationDAO" 
             class="org.sonatype.mavenbook.weather.persist.LocationDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="weatherDAO" 
             class="org.sonatype.mavenbook.weather.persist.WeatherDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
 &lt;/beans&gt;</programlisting>
    </example>

    <para>在这个application
    context中，我们完成了一些事情。<acronym>DAO</acronym>从<varname>sessionFactory</varname>
    bean获取Hibernate
    <classname>Session</classname>对象。这个bean是一个<classname>AnnotationSessionFactoryBean</classname>的实例，并由一列<varname>annotatedClasses</varname>填充。注意这列标注类就是定义在我们<varname>simple-model</varname>模块中的那些类。接下来，<varname>sessionFactory</varname>通过一组Hibernate配置属性(<varname>hibernateProperties</varname>)配置。该例中，我们的Hibernate属性定义了许多设置：</para>

    <variablelist>
      <varlistentry>
        <term><literal>hibernate.dialect</literal></term>

        <listitem>
          <para>该设置控制如何生成数据库的<acronym>SQL</acronym>。由于我们正在使用<acronym>HSQLDB</acronym>数据库，我们的数据库方言设置成<classname>org.</classname><classname>hibernate.</classname><classname>dialect.</classname><classname>HSQLDialect</classname>。Hibernate有所有主流数据库的方言，如Oracle，MySQL，Postgres和SQL
          Server。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>hibernate.connection.*</literal></term>

        <listitem>
          <para>该例中，我们从Spring配置中配置<acronym>JDBC</acronym>连接属性。我们的应用被配置成运行在<filename
          role="keep-together">./data/weather</filename>目录下的<acronym>HSQLDB</acronym>上。在实际的企业应用中，你更可能会使用如<acronym>JNDI</acronym>的东西以从你的应用程序代码中抽出数据库配置。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>最后，在这个bean定义文件中，两个<varname>simple-persist</varname>
    <acronym>DAO</acronym>对象被创建并给予了对于刚定义的<varname>sessionFactory</varname>
    bean的引用。就像<varname>simple-weather</varname>中的Spring application
    context，这个<filename>applicationContext-persist.xml</filename>文件定义了一个大型企业应用设计中一个子模块的架构。如果你曾经从事过大量持久化类的集合相关的工作，你可能会发现，这些与你应用程序独立的application
    context文件，能帮助你快速的理解所有类的关系。</para>

    <para><varname>simple-persist</varname>中还有最后一块不清楚的地方。本章后面，我们将看到<indexterm>
        <primary>Maven Hibernate3 plugin</primary>
      </indexterm><indexterm>
        <primary>Hibernate3 plugin</primary>
      </indexterm>如何使用Maven Hibernate3插件，根据标注的模型对象来生成数据库schema。为了使它正确工作，Maven
    Hibernate3插件需要读取<acronym>JDBC</acronym>连接配置参数，那一列标注的类，以及<filename>src/main/resources</filename>中名为<filename><indexterm>
        <primary>hibernate.cfg.xml file</primary>
      </indexterm>hibernate.cfg.xml</filename>文件的Hibernate配置。该文件（它重复了一些<filename>applicationContext-persist.xml</filename>中的配置）的目的是能让Maven
    Hibernate3插件能仅仅依靠标注就能生成数据定义语言（<acronym>DDL</acronym>）。如<xref
    linkend="ex-hibernate-cfg" />。</para>

    <example id="ex-hibernate-cfg">
      <title>simple-persist 的 hibernate.cfg.xml</title>

      <programlisting language="xml">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
        
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
        
    &lt;!-- SQL dialect --&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
    
    &lt;!-- Database connection settings --&gt;
    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:data/weather&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="connection.shutdown"&gt;true&lt;/property&gt;
    
    &lt;!-- JDBC connection pool (use the built-in one) --&gt;
    &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;
    
    &lt;!-- Enable Hibernate's automatic session context management --&gt;
    &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;
    
    &lt;!-- Disable the second-level cache  --&gt;
    &lt;property name="cache.provider_class"&gt;
      org.hibernate.cache.NoCacheProvider
    &lt;/property&gt;
    
    &lt;!-- Echo all executed SQL to stdout --&gt;
    &lt;property name="show_sql"&gt;true&lt;/property&gt;
    
    &lt;!-- disable batching so HSQLDB will propagate errors correctly. --&gt;
    &lt;property name="jdbc.batch_size"&gt;0&lt;/property&gt;
    
    &lt;!-- List all the mapping documents we're using --&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Atmosphere"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Condition"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Location"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Weather"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Wind"/&gt;
        
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</programlisting>
    </example>

    <para><xref linkend="ex-persist-spring" />和<xref
    linkend="ex-multimodule-web-spring-parent" />的内容是冗余的。Spring Application
    Context
    <acronym>XML</acronym>是被web引用和命令行应用使用的，而<filename>hibernate.cfg.xml</filename>的存在只是为了支持Maven
    Hibernate3插件。本章的后面，我们将会看到如何使用<filename>hibernate.cfg.xml</filename>和Maven
    Hibernate3插件，根据<varname>simple-model</varname>中定义的标注对象模型，来生成一个数据库schema。<filename>hibernate.cfg.xml</filename>会配置JDBC连接属性并且为Maven
    Hibernate3插件枚举标注模型类的列表。</para>
  </section>

  <section>
    <title>simple-webapp模块</title>

    <para>该web应用中项目<varname>simple-webapp</varname><indexterm
        class="startofrange" id="enterprise6a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>Simple Web Application of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise6b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>Simple Web Application of</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise6c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>Simple Web Application of</secondary>
      </indexterm>中定义。这个简单web应用项目将会定义两个Spring
    <acronym>MVC</acronym>控制器：<classname>WeatherController</classname>和<classname
    role="keep-together">HistoryController</classname>。两者都会引用<varname>simple-weather</varname>和<varname>simple-persist</varname>中定义的组件。Spring容器在应用程序的<filename>web.xml</filename>中配置，该文件引用了<varname
    role="keep-together">simple-weather</varname>中的<filename>applicationContext-weather.xml</filename>文件和<varname>simple-persist</varname>中的<filename>applicationContext-persist.xml</filename>文件。这个简单web应用的组件架构如<xref
    linkend="fig-web-components" />显示。</para>

    <figure id="fig-web-components">
      <title>Spring MVC 控制器引用simple-weather和simple-persist中的组件</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-web-spring.png"
                     scalefit="1" width="6in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para><varname>simple-webapp</varname>的POM如<xref
    linkend="example_pom-for-simple-webapp" />显示。</para>

    <example id="example_pom-for-simple-webapp">
      <title>simple-webapp的POM</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-webapp&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;name&gt;Simple Web Application&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt; <co id="coDef-spring-web-1" os="coRef-spring-web-1" />
      &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
      &lt;artifactId&gt;geronimo-servlet_2.4_spec&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
      &lt;artifactId&gt;velocity&lt;/artifactId&gt;
      &lt;version&gt;1.5&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;finalName&gt;simple-webapp&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt; <co id="coDef-spring-web-2" linkends="coRef-spring-web-2" />
        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
        &lt;dependencies&gt;<co id="coDef-spring-web-3"
          linkends="coRef-spring-web-3" />
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; <co
          id="coDef-spring-web-4" linkends="coRef-spring-web-4" />
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt; <co
          id="coDef-spring-web-5" linkends="coRef-spring-web-5" />
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>随着书本的推进以及样例变得越来越大，你会注意到<filename>pom.xml</filename>开始呈现得有一些笨重，这里我们配置了四个依赖和两个插件。让我们详细查看一下这个POM然后详述其中一些重要的配置点：</para>

    <calloutlist>
      <callout arearefs="coDef-spring-web-1" id="coRef-spring-web-1">
        <para><varname>simple-webapp</varname>项目定义了四个依赖：来自于Apache
        Geronimo的Servlet
        2.4规格说明实现，simple-weather服务类库，simple-persist持久化类库，以及整个Spring Framework
        2.0.7。</para>
      </callout>

      <callout arearefs="coDef-spring-web-2" id="coRef-spring-web-2">
        <para>Maven Jetty插件<indexterm>
            <primary>Maven Jetty plugin</primary>
          </indexterm><indexterm>
            <primary>Jetty plugin</primary>
          </indexterm>以最简单的方式加入到该项目，我们只是添加一个引用了对应<literal>groupId</literal>和<literal>artifactId</literal>的<literal>plugin</literal>元素。配置这个插件如此平常意味着这个插件的开发者做了很好的工作提供了足够的默认值，在大部分情况下不需要被重写。如果你需要重写一些Jetty插件的配置，那么就需要提供<literal>configuration</literal>元素。</para>
      </callout>

      <callout arearefs="coDef-spring-web-3" id="coRef-spring-web-3">
        <para>在我们的build配置中，我们还配置了Maven Hibernate3插件来访问内嵌的HSQLDB实例。要让Maven
        Hibernate3插件能成功的使用JDBC连接该数据库，该插件需要引用classpath中的HSQLDB
        JDBC驱动。为了让这个插件能使用该依赖，我们在<sgmltag>plugin</sgmltag>声明下面添加了一个<sgmltag>dependency</sgmltag>声明。在该例中，我们引用了hsqldb:hsqldb:1.8.0.7。这个Hibernate插件也需要JDBC驱动来创建数据库，所以我们也在它的配置中添加了这个依赖。</para>
      </callout>

      <callout arearefs="coDef-spring-web-4" id="coRef-spring-web-4">
        <para>这个Maven Hibernate插件<indexterm>
            <primary>Maven Hibernate plugin</primary>
          </indexterm><indexterm>
            <primary>Hibernate plugin</primary>
          </indexterm>正是该POM变得有趣的地方。在下一节，我们将会运行<literal>hbm2ddl</literal>目标来生成HSQLDB数据库。在这个中，我们包含了对<literal>hibernate3-maven-plugin</literal>版本2.0的引用，该插件由Codehaus
        Mojo维护。</para>
      </callout>

      <callout arearefs="coDef-spring-web-5" id="coRef-spring-web-5">
        <para>Maven
        Hibernate3插件有不同的方法获取Hibernate映射信息，这些信息适用于Hibernate3插件的不同用例。如果你正在使用Hibernate映射XML文件(<filename>.hbm.xml</filename>)，你会要使用<literal>hbm2java</literal>目标生成模型类，你会将implementation设置成<literal>configuration</literal>。如果你使用Hibernate3插件逆向工程从一个数据库产生<filename>.hbm.xml</filename>文件和模型类，你会需要一个<literal>jdbcconfiguration</literal>的implementation。在本例中，我们使用现存的标注对象模型来生辰给一个数据库。换句话说，我们有我们的Hibernate映射，但我们还没有数据库。在这种用例中，正确的implementation值应该是<literal>annotationconfiguration</literal>。Maven
        Hibernate3插件在后面的一节<xref
        linkend="sect-spring-running-web" />中详细讨论。</para>
      </callout>
    </calloutlist>

    <note>
      <para>一个常见的错误是使<sgmltag>extensions</sgmltag>用配置添加一个插件需要的依赖。这是强烈不推荐的因为extensions会在你的项目中造成classpath污染，以及其它令人讨厌的副作用。此外，extensions行为正在2.1中被重做，最后你都会要改变它。唯一的对<sgmltag>extensions</sgmltag>的正常使用是定义新的wagon实现。</para>
    </note>

    <para>接下来，我们将我们的注意力转移到两个处理所有请求的Spring
    MVC控制器。两个控制器都引用了在<varname>simple-weather</varname>和<varname>simple-persist</varname>中定义的bean。</para>

    <example>
      <title>simple-webapp WeatherController</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;
import org.sonatype.mavenbook.weather.WeatherService;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class WeatherController implements Controller {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {

    String zip = request.getParameter("zip");
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save(weather);
    return new ModelAndView("weather", "weather", weather);
  }

  public WeatherService getWeatherService() {
    return weatherService;
  }

  public void setWeatherService(WeatherService weatherService) {
    this.weatherService = weatherService;
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }
}</programlisting>
    </example>

    <para><varname>WeatherController</varname> implements the Spring MVC
    Controller interface that mandates the presence of a
    <methodname>handleRequest()</methodname> method with the signature shown
    in the example. If you look at the meat of this method, you’ll see that it
    invokes the <methodname>retrieveForecast()</methodname> method on the
    <varname>weatherService</varname> instance variable. Unlike the previous
    chapter, which had a Servlet that instantiated the
    <classname>WeatherService</classname> class, the
    <classname>WeatherController</classname> is a bean with a
    <varname>weatherService</varname> property. The Spring IoC container is
    responsible for wiring the controller to the
    <varname>weatherService</varname> component. Also notice that we’re not
    using the <classname role="keep-together">WeatherFormatter</classname> in
    this Spring controller implementation; instead, we’re passing the
    <classname>Weather</classname> object returned by
    <methodname>retrieveForecast()</methodname> to the constructor of
    <classname>ModelAndView</classname>. This
    <classname>ModelAndView</classname> class is going to be used to render a
    <indexterm>
        <primary>Velocity template</primary>
      </indexterm>Velocity template, and this template will have references to
    a <varname>${weather}</varname> variable. The
    <filename>weather.vm</filename> template is stored in
    <filename>src/main/webapp/WEB-INF/vm</filename> and is shown in <xref
    linkend="ex-weather-vm" />.</para>

    <para>In the <classname>WeatherController</classname>, before we render
    the output of the forecast, we pass the <classname>Weather</classname>
    object returned by the <classname>WeatherService</classname> to the
    <methodname>save()</methodname> method on
    <classname>WeatherDAO</classname>. Here we are saving this
    <classname>Weather</classname> object—using Hibernate—to an HSQLDB
    database. Later, in <classname>HistoryController</classname>, we will see
    how we can retrieve a history of weather forecasts that were saved by the
    <classname>WeatherController</classname>.</para>

    <example>
      <title>weather.vm template rendered by WeatherController</title>

      <programlisting id="ex-weather-vm" language="xml">&lt;b&gt;Current Weather Conditions for:
  ${weather.location.city}, ${weather.location.region}, 
  ${weather.location.country}&lt;/b&gt;&lt;br/&gt;
  
&lt;ul&gt;
  &lt;li&gt;Temperature: ${weather.condition.temp}&lt;/li&gt;
  &lt;li&gt;Condition: ${weather.condition.text}&lt;/li&gt;
  &lt;li&gt;Humidity: ${weather.atmosphere.humidity}&lt;/li&gt;
  &lt;li&gt;Wind Chill: ${weather.wind.chill}&lt;/li&gt;
  &lt;li&gt;Date: ${weather.date}&lt;/li&gt;
&lt;/ul&gt;
</programlisting>
    </example>

    <para>The syntax for this Velocity template is straightforward, variables
    are referenced using <code>${}</code> notation. The expression between the
    curly braces references a property, or a property of a property on the
    <varname>weather</varname> variable which was passed to this template by
    the <classname>WeatherController</classname>.</para>

    <para>The <classname>HistoryController</classname> is used to retrieve
    recent forecasts that have been requested by the
    <classname>WeatherController</classname>. Whenever we retrieve a forecast
    from the <classname>WeatherController</classname>, that controller saves
    the <classname>Weather</classname> object to the database via the
    <classname>WeatherDAO</classname>. <classname>WeatherDAO</classname> then
    uses Hibernate to dissect the <classname>Weather</classname> object into a
    series of rows in a set of related database tables. The
    <classname>HistoryController</classname> is shown in <xref
    linkend="ex-spring-history" />.</para>

    <example id="ex-spring-history">
      <title>simple-web HistoryController</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import java.util.*;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
import org.sonatype.mavenbook.weather.model.*;
import org.sonatype.mavenbook.weather.persist.*;

public class HistoryController implements Controller {

  private LocationDAO locationDAO;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {
    String zip = request.getParameter("zip");
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation( location );

    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put( "location", location );
    model.put( "weathers", weathers );

    return new ModelAndView("history", model);
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }

  public LocationDAO getLocationDAO() {
    return locationDAO;
  }

  public void setLocationDAO(LocationDAO locationDAO) {
    this.locationDAO = locationDAO;
  }
}</programlisting>
    </example>

    <para>The <classname>HistoryController</classname> is wired to two
    <acronym>DAO</acronym> objects defined in
    <varname>simple-persist</varname>. The <acronym>DAO</acronym>s are bean
    properties of the <classname>HistoryController</classname>:
    <classname>WeatherDAO</classname> and <classname>LocationDAO</classname>.
    The goal of the <classname>HistoryController</classname> is to retrieve a
    <classname>List</classname> of <classname>Weather</classname> objects
    which correspond to the <varname>zip</varname> parameter. When the
    <classname>WeatherDAO</classname> saves the <classname>Weather</classname>
    object to the database, it doesn't just store the zip code, it stores a
    <classname>Location</classname> object which is related to the
    <classname>Weather</classname> object in the
    <varname>simple-model</varname>. To retrieve a <classname>List</classname>
    of <classname>Weather</classname> objects, the
    <classname>HistoryController</classname> first retrieves the
    <classname>Location</classname> object that corresponds to the
    <varname>zip</varname> parameter. It does this by invoking the
    <methodname>findByZip()</methodname> method on
    <classname>LocationDAO</classname>.</para>

    <para>Once the <classname>Location</classname> object has been retrieved,
    the <classname>HistoryController</classname> will then attempt to retrieve
    recent <classname>Weather</classname> objects that match the given
    <classname>Location</classname>. Once the
    <classname>List&lt;Weather&gt;</classname> has been retrieved, a
    <classname>HashMap</classname> is created to hold two variables for the
    <filename>history.vm</filename> Velocity template shown in <xref
    linkend="ex-spring-history-velocity" />.</para>

    <example>
      <title>history.vm rendered by the HistoryController</title>

      <programlisting id="ex-spring-history-velocity" language="java">&lt;b&gt;
Weather History for: ${location.city}, ${location.region}, ${location.country}
&lt;/b&gt;
&lt;br/&gt;
  
#foreach( $weather in $weathers )
  &lt;ul&gt;
    &lt;li&gt;Temperature: $weather.condition.temp&lt;/li&gt;
    &lt;li&gt;Condition: $weather.condition.text&lt;/li&gt;
    &lt;li&gt;Humidity: $weather.atmosphere.humidity&lt;/li&gt;
    &lt;li&gt;Wind Chill: $weather.wind.chill&lt;/li&gt;
    &lt;li&gt;Date: $weather.date&lt;/li&gt;
  &lt;/ul&gt;
#end
</programlisting>
    </example>

    <para>The <filename>history.vm</filename> template in
    <filename>src/main/webapp/WEB-INF/vm</filename> references the
    <varname>location</varname> variable to print out information about the
    location of the forecasts retrieved from the
    <classname>WeatherDAO</classname>. This template then uses a Velocity
    control structure, <code>#foreach</code>, to loop through each element in
    the <varname>weathers</varname> variable. Each element in
    <varname>weathers</varname> is assigned to a variable named
    <varname>weather</varname> and the template between <code>#foreach</code>
    and <code>#end</code> is rendered for each forecast.</para>

    <para>You've seen these <classname>Controller</classname> implementations,
    and you've seen that they reference other beans defined in
    <varname>simple-weather</varname> and <varname>simple-persist</varname>,
    they respond to <acronym>HTTP</acronym> requests, and they yield control
    to some mysterious templating system that knows how to render Velocity
    templates. All of this magic is configured in a Spring application context
    in <filename>src/main/webapp/WEB-INF/weather-servlet.xml</filename>. This
    <acronym>XML</acronym> configures the controllers and references other
    Spring-managed beans, it is loaded by a
    <classname>ServletContextListener</classname> which is also configured to
    load the <filename>applicationContext-weather.xml</filename> and
    <filename>applicationContext-persist.xml</filename> from the classpath.
    Let's take a closer look at the <filename>weather-servlet.xml</filename>
    shown in <xref linkend="ex-spring-weather-servlet" />.</para>

    <example>
      <title>Spring Controller configuration weather-servlet.xml</title>

      <programlisting id="ex-spring-weather-servlet" language="xml">&lt;beans&gt;  
     &lt;bean id="weatherController" <co id="coDef-weather-servlet-1"
          linkends="coRef-weather-servlet-1" />
           class="org.sonatype.mavenbook.web.WeatherController"&gt;
       &lt;property name="weatherService" ref="weatherService"/&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
     &lt;/bean&gt;

     &lt;bean id="historyController" 
           class="org.sonatype.mavenbook.web.HistoryController"&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
       &lt;property name="locationDAO" ref="locationDAO"/&gt;
     &lt;/bean&gt;

     &lt;!-- you can have more than one handler defined --&gt;
     &lt;bean id="urlMapping" 
     class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
          &lt;property name="urlMap"&gt;
               &lt;map&gt;
                    &lt;entry key="/weather.x"&gt; <co
          id="coDef-weather-servlet-2" linkends="coRef-weather-servlet-2" />
                         &lt;ref bean="weatherController" /&gt;
                    &lt;/entry&gt;
                    &lt;entry key="/history.x"&gt;
                         &lt;ref bean="historyController" /&gt;
                    &lt;/entry&gt;
               &lt;/map&gt;
          &lt;/property&gt;
     &lt;/bean&gt;


     &lt;bean id="velocityConfig" <co id="coDef-weather-servlet-3"
          linkends="coRef-weather-servlet-3" />
   class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
       &lt;property name="resourceLoaderPath" value="/WEB-INF/vm/"/&gt;
     &lt;/bean&gt;

     &lt;bean id="viewResolver" <co id="coDef-weather-servlet-4"
          linkends="coRef-weather-servlet-4" />
   class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
       &lt;property name="cache" value="true"/&gt;
       &lt;property name="prefix" value=""/&gt;
       &lt;property name="suffix" value=".vm"/&gt;
       &lt;property name="exposeSpringMacroHelpers" value="true"/&gt;
     &lt;/bean&gt;
&lt;/beans&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-weather-servlet-1" id="coRef-weather-servlet-1">
        <para>The <filename>weather-servlet.xml</filename> defines the two
        controllers as Spring-managed beans.
        <varname>weatherController</varname> has two properties which are
        references to <varname>weatherService</varname> and
        <varname>weatherDAO</varname>. <varname>historyController</varname>
        references the beans <varname>weatherDAO</varname> and
        <varname>locationDAO</varname>. When this
        <classname>ApplicationContext</classname> is created, it is created in
        an environment that has access to the
        <classname>ApplicationContext</classname>s defined in both
        <varname>simple-persist</varname> and
        <varname>simple-weather</varname>. In <xref
        linkend="ex-spring-webxml" /> you will see how Spring is configured to
        merge components from multiple Spring configuration files.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-2" id="coRef-weather-servlet-2">
        <para>The <varname>urlMapping</varname> bean defines the
        <acronym>URL</acronym> patterns which invoke the
        <classname>WeatherController</classname> and the
        <classname>HistoryController</classname>. In this example, we are
        using the <classname>SimpleUrlHandlerMapping</classname> and mapping
        <filename>/weather.x</filename> to
        <classname>WeatherController</classname> and
        <filename>/history.x</filename> to
        <classname>HistoryController</classname>.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-3" id="coRef-weather-servlet-3">
        <para>Since we are using the Velocity templating engine, we will need
        to pass in some configuration options. In the
        <varname>velocityConfig</varname> bean, we are telling Velocity to
        look for all templates in the <filename>/WEB-INF/vm</filename>
        directory.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-4" id="coRef-weather-servlet-4">
        <para>Last, the <varname>viewResolver</varname> is configured with the
        class <classname>VelocityViewResolver</classname>. There are a number
        of <classname>ViewResolver</classname> implementations in Spring from
        a standard ViewResolver to render <acronym>JSP</acronym> or
        <acronym>JSTL</acronym> pages to a resolver which can render
        Freemarker templates. In this example, we're configuring the Velocity
        templating engine and setting the default prefix and suffix which will
        be automatically appended to the names of the template passed to
        <classname>ModelAndView</classname>.</para>
      </callout>
    </calloutlist>

    <para>Finally, the <varname>simple-webapp</varname> project was a
    <filename>web.xml</filename> which provides the basic configuration for
    the web application. The <filename>web.xml</filename> file is shown in
    <xref linkend="ex-spring-webxml" />.</para>

    <example>
      <title>web.xml for simple-webapp</title>

      <programlisting id="ex-spring-webxml" language="xml">&lt;web-app id="simple-webapp" version="2.4" 
     xmlns="http://java.sun.com/xml/ns/j2ee" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;
  &lt;display-name&gt;Simple Web Application&lt;/display-name&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-1"
          linkends="coRef-spring-webx-1" />
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
      classpath:applicationContext-weather.xml
      classpath:applicationContext-persist.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-2"
          linkends="coRef-spring-webx-2" />
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;listener&gt; <co id="coDef-spring-webx-3" linkends="coRef-spring-webx-3" />
    &lt;listener-class&gt;
      org.springframework.web.util.Log4jConfigListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;listener&gt;
    &lt;listener-class&gt; <co id="coDef-spring-webx-4"
          linkends="coRef-spring-webx-4" />
     org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;servlet&gt; <co id="coDef-spring-webx-5" linkends="coRef-spring-webx-5" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      org.springframework.web.servlet.DispatcherServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt; <co id="coDef-spring-webx-6"
          linkends="coRef-spring-webx-6" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.x&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-spring-webx-1" id="coRef-spring-webx-1">
        <para>Here's a bit of magic which allows us to reuse the
        <filename>applicationContext-weather.xml</filename> and
        <filename>applicationContext-persist.xml</filename> in this project.
        The <varname>contextConfigLocation</varname> is used by the
        <classname>ContextLoaderListener</classname> to create an
        <classname>ApplicationContext</classname>. When the weather servlet is
        created, the <filename>weather-servlet.xml</filename> from <xref
        linkend="ex-spring-weather-servlet" /> is going to be evaluated with
        the <classname>ApplicationContext</classname> created from this
        <varname>contextConfigLocation</varname>. In this way, you can define
        a set of beans in another project and you can reference these beans
        via the classpath. Since the <varname>simple-persist</varname> and
        <varname>simple-weather</varname> <acronym>JAR</acronym>s are going to
        be in <filename>WEB-INF/lib</filename>, all we do is use the
        <literal>classpath:</literal> prefix to reference these files.
        (Another option would have been to copy these files to
        <filename>/WEB-INF</filename> and reference them with something like
        <filename>/WEB-INF/applicationContext-persist.xml</filename>).</para>
      </callout>

      <callout arearefs="coDef-spring-webx-2" id="coRef-spring-webx-2">
        <para>The <varname>log4jConfigLocation</varname> is used to tell the
        <classname>Log4JConfigListener</classname> where to look for Log4J
        logging configuration. In this example, we tell Log4J to look in
        <filename>/WEB-INF/log4j.properties</filename>.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-3" id="coRef-spring-webx-3">
        <para>This makes sure that the Log4J system is configured when the web
        application starts. It is important to put this
        <classname>Log4JConfigListener</classname> before the<classname>
        ContextLoaderListener</classname>; otherwise, you may miss important
        logging messages which point to a problem preventing application
        startup. If you have a particularly large set of beans managed by
        Spring, and one of them happens to blow up on application startup,
        your application will fail. If you have logging initialized before
        Spring starts, you might have a chance to catch a warning or an error.
        If you don't have logging initialized before Spring starts up, you'll
        have no idea why your application refuses to start.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-4" id="coRef-spring-webx-4">
        <para>The <classname>ContextLoaderListener</classname> is essentially
        the Spring container. When the application starts, this listener will
        build an <classname>ApplicationContext</classname> from the
        <varname>contextConfigLocation</varname> parameter.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-5" id="coRef-spring-webx-5">
        <para>We define a Spring <acronym>MVC</acronym>
        <classname>DispatcherServlet</classname> with a name of
        <varname>weather</varname>. This will cause Spring to look for a
        Spring configuration file in
        <filename>/WEB-INF/weather-servlet.xml</filename>. You can have as
        many <classname>DispatcherServlet</classname>s as you need, a
        <classname>DispatcherServlet</classname> can contain one or more
        Spring <acronym>MVC</acronym> <classname>Controller</classname>
        implementations.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-6" id="coRef-spring-webx-6">
        <para>All requests ending in <filename>.x</filename> will be routed to
        the <varname>weather</varname> servlet. Note that the
        <filename>.x</filename> extension has no particular meaning, it is an
        arbitrary choice and you can use whatever <acronym>URL</acronym>
        pattern you like.</para>
      </callout>
    </calloutlist>
  </section>

  <section id="sect-spring-running-web">
    <title>运行这个Web应用</title>

    <para>To run the web application, you’ll first need to build the database
    <indexterm class="startofrange" id="enterprise7a">
        <primary>multimodule project (example)</primary>

        <secondary>multimodule enterprise project</secondary>

        <tertiary>running Web application</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise7b">
        <primary>Web applications</primary>

        <secondary>multimodule enterprise project example</secondary>

        <tertiary>running Web application</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise7c">
        <primary>enterprise project, multimodule (example)</primary>

        <secondary>running Web application</secondary>
      </indexterm><indexterm>
        <primary>Maven Hibernate3 plugin</primary>

        <secondary>building database using</secondary>
      </indexterm><indexterm>
        <primary>Hibernate3 plugin</primary>

        <secondary>building database using</secondary>
      </indexterm>using the Hibernate3 plugin. To do this, run the following
    from the <varname>simple-webapp</varname> project directory:</para>

    <screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>

    <para>Once you've done this, there should be a
    <filename>${basedir}/data</filename> directory which will contain the
    HSQLDB database. You can then start the web application with:</para>

    <screen>$ <command>mvn jetty:run</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'jetty'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [jetty:run]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing jetty:run
...
[INFO] [jetty:run]
[INFO] Configuring Jetty for project: Chapter 7 Simple Web Application
...
[INFO] Context path = /simple-webapp
[INFO] Tmp directory =  determined at runtime
[INFO] Web defaults = org/mortbay/jetty/webapp/webdefault.xml
[INFO] Web overrides =  none
[INFO] Starting jetty 6.1.7 ...
2008-03-25 10:28:03.639::INFO:  jetty-6.1.7
...
2147 INFO  DispatcherServlet  - FrameworkServlet 'weather': \
           initialization completed in 1654 ms
2008-03-25 10:28:06.341::INFO:  Started SelectChannelConnector@0.0.0.0:8080
[INFO] Started Jetty Server
</screen>

    <para>Once Jetty is started, you can load <ulink
    url="http://localhost:8080/simple-webapp/weather.x?zip=60202">http://localhost:8080/simple-webapp/weather.x?zip=60202</ulink>
    and you should see the weather for Evanston, IL in your web browser.
    Change the ZIP code and you should be able to get your own weather
    report.</para>

    <screen>Current Weather Conditions for: Evanston, IL, US

    * Temperature: 42
    * Condition: Partly Cloudy
    * Humidity: 55
    * Wind Chill: 34
    * Date: Tue Mar 25 10:29:45 CDT 2008
</screen>
  </section>

  <section>
    <title>simple-command模块</title>

    <para>The <varname>simple-command</varname> project is a command-line
    version of the <varname>simple-webapp</varname>. It is a utility that
    relies on the same dependencies: <varname>simple-persist</varname> and
    <varname>simple-weather</varname>. Instead of interacting with this
    application via a web browser, you would run the
    <classname>simple-command</classname> utility from the
    command-line.</para>

    <figure>
      <title>Command line application referencing simple-weather and
      simple-persist</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/multimodule-web-command-spring.png"
                     scalefit="1" width="6in" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>POM for simple-command</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-command&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Simple Command Line Tool&lt;/name&gt;

  &lt;build&gt;
    &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
       &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt;
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;           
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;hsqldb&lt;/groupId&gt;
      &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
      &lt;version&gt;1.8.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>This <acronym>POM</acronym> creates an <acronym>JAR</acronym> file
    which will contain the
    <classname>org.sonatype.mavenbook.weather.Main</classname> class shown in
    <xref linkend="ex-spring-command-main-class" />. In this
    <acronym>POM</acronym> we configure the Maven Assembly plugin to use a
    built-in assembly descriptor named
    <varname>jar-with-dependencies</varname> which creates a single
    <acronym>JAR</acronym> file containing all the bytecode a project needs to
    execute including the bytecode from the project you are building and all
    the dependency bytecode.</para>

    <example id="ex-spring-command-main-class">
      <title>The Main class for simple-command</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.util.List;

import org.apache.log4j.PropertyConfigurator;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.LocationDAO;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;

public class Main {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;
  private LocationDAO locationDAO;

  public static void main(String[] args) throws Exception {
    // Configure Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader().getResource(
        "log4j.properties"));

    // Read the Zip Code from the Command-line (if none supplied, use 60202)
    String zipcode = "60202";
    try {
      zipcode = args[0];
    } catch (Exception e) {
    }

    // Read the Operation from the Command-line (if none supplied use weather)
    String operation = "weather";
    try {
      operation = args[1];
    } catch (Exception e) {
    }

    // Start the program
    Main main = new Main(zipcode);

    ApplicationContext context = 
      new ClassPathXmlApplicationContext(
        new String[] { "classpath:applicationContext-weather.xml",
                       "classpath:applicationContext-persist.xml" });
    main.weatherService = (WeatherService) context.getBean("weatherService");
    main.locationDAO = (LocationDAO) context.getBean("locationDAO");
    main.weatherDAO = (WeatherDAO) context.getBean("weatherDAO");
    if( operation.equals("weather")) {
      main.getWeather();
    } else {
      main.getHistory();
    }
  }

  private String zip;

  public Main(String zip) {
    this.zip = zip;
  }

  public void getWeather() throws Exception {
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save( weather );
    System.out.print(new WeatherFormatter().formatWeather(weather));
  }

  public void getHistory() throws Exception {
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation(location);
    System.out.print(new WeatherFormatter().formatHistory(location, weathers));
  }
}
</programlisting>
    </example>

    <para>The <classname>Main</classname> class has a reference to
    <classname>WeatherDAO</classname>, <classname>LocationDAO</classname>, and
    <classname>WeatherService</classname>. The static
    <methodname>main()</methodname> method in this class:</para>

    <itemizedlist>
      <listitem>
        <para>Reads the Zip Code from the first command line argument</para>
      </listitem>

      <listitem>
        <para>Reads the Operation from the second command line argument. If
        the operation is "weather", the latest weather will be retrieved from
        the web service. If the operation is "history", the program will fetch
        historical weather records from the local database.</para>
      </listitem>

      <listitem>
        <para>Loads a Spring <classname>ApplicationContext</classname> using
        two <acronym>XML</acronym> files loaded from
        <varname>simple-persist</varname> and
        <varname>simple-weather</varname></para>
      </listitem>

      <listitem>
        <para>Creates an instance of <classname>Main</classname></para>
      </listitem>

      <listitem>
        <para>Populates the <varname>weatherService</varname>,
        <varname>weatherDAO</varname>, and <varname>locationDAO</varname> with
        beans from the Spring <classname>ApplicationContext</classname></para>
      </listitem>

      <listitem>
        <para>Runs the appropriate method
        <methodname>getWeather()</methodname> or
        <methodname>getHistory()</methodname> depending on the specified
        operation.</para>
      </listitem>
    </itemizedlist>

    <para>In the web application we use Spring
    <classname>VelocityViewResolver</classname> to render a Velocity template.
    In the stand-alone implementation, we need to write a simple class which
    renders our weather data with a Velocity template. <xref
    linkend="ex-spring-weather-formatter" /> is a listing of the
    <classname>WeatherFormatter</classname>, a class with two methods that
    render the weather report and the weather history.</para>

    <example id="ex-spring-weather-formatter">
      <title>WeatherFormatter renders weather data using a Velocity
      template</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String formatWeather( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("weather.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }

  public String formatHistory( Location location, List&lt;Weather&gt; weathers )  
        throws Exception {
    log.info( "Formatting History Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("history.vm"));
    VelocityContext context = new VelocityContext();
    context.put("location", location );
    context.put("weathers", weathers );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting>
    </example>

    <para>The <filename>weather.vm</filename> template simply prints the zip
    code's city, country, and region as well as the current temperature. The
    <filename>history.vm</filename> template prints the location and then
    iterates through the weather forecast records stored in the local
    database. Both of these templates are in
    <filename>${basedir}/src/main/resources</filename>.</para>

    <example>
      <title>The weather.vm Velocity template</title>

      <programlisting language="java">****************************************
Current Weather Conditions for:
  ${weather.location.city},
  ${weather.location.region},
  ${weather.location.country}
****************************************

 * Temperature: ${weather.condition.temp}
 * Condition: ${weather.condition.text}
 * Humidity: ${weather.atmosphere.humidity}
 * Wind Chill: ${weather.wind.chill}
 * Date: ${weather.date}
</programlisting>
    </example>

    <example>
      <title>The history.vm Velocity template</title>

      <para><programlisting>Weather History for:
${location.city},
${location.region},
${location.country}


#foreach( $weather in $weathers )
****************************************
 * Temperature: $weather.condition.temp
 * Condition: $weather.condition.text
 * Humidity: $weather.atmosphere.humidity
 * Wind Chill: $weather.wind.chill
 * Date: $weather.date
#end</programlisting></para>
    </example>
  </section>

  <section>
    <title>运行这个命令行程序</title>

    <para>The <varname>simple-command</varname> project is configured to
    create a single <acronym>JAR</acronym> containing the bytecode of the
    project and all of the bytecode from the dependencies. To create this
    assembly, run the <varname>assembly</varname> goal of the Maven Assembly
    plugin from the <varname>simple-command</varname> project
    directory:</para>

    <screen>$ <command>mvn assembly:assembly</command>
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [assembly:assembly] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [surefire:test]
...
[INFO] [jar:jar]
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Expanding: .../.m2/repository/.../simple-weather-1-SNAPSHOT.jar into \
                                                        /tmp/archived-file-set.93251505.tmp
[INFO] Expanding: .../.m2/repository/.../simple-model-1-SNAPSHOT.jar into \
                                                        /tmp/archived-file-set.2012480870.tmp
[INFO] Expanding: .../.m2/repository/../hibernate-3.2.5.ga.jar into \
                                                        /tmp/archived-file-set.1296516202.tmp
... skipping 25 lines of dependency unpacking ...
[INFO] Expanding: .../.m2/repository/.../velocity-1.5.jar into /tmp/archived-file-set.379482226.tmp
[INFO] Expanding: .../.m2/repository/.../commons-lang-2.1.jar into \
                                                        /tmp/archived-file-set.1329200163.tmp
[INFO] Expanding: .../.m2/repository/.../oro-2.0.8.jar into /tmp/archived-file-set.1993155327.tmp
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command-jar-with-dependencies.jar
</screen>

    <para>The build progresses through the lifecycle compiling bytecode,
    running tests, and finally building a <acronym>JAR</acronym> for the
    project. Then the <varname>assembly:assembly</varname> goal creates a
    <acronym>JAR</acronym> with dependencies by unpacking all of the
    dependencies to temporary directories and then collecting all of the
    bytecode into a single <acronym>JAR</acronym> in
    <filename>target/</filename> named
    <filename>simple-command-jar-with-dependencies.jar</filename>. This "uber"
    <acronym>JAR</acronym> weighs in at 15 MB.</para>

    <para>Before you run the command-line tool, you will need to invoke the
    <varname>hbm2ddl</varname> goal of the Hibernate3 plugin to create the
    HSQLDB database. Do this by running the following command from the
    <varname>simple-command</varname> directory:</para>

    <para><screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>Once you run this, you should see a <filename>data/</filename>
    directory under <varname>simple-command</varname>. This
    <filename>data/</filename> directory holds the HSQLDB database. To run the
    command-line weather forecaster, run the following from the
    <filename>simple-command/</filename> project directory:</para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202</command>
2321 INFO  YahooRetriever  - Retrieving Weather Data
2489 INFO  YahooParser  - Creating XML Reader
2581 INFO  YahooParser  - Parsing XML Response
2875 INFO  WeatherFormatter  - Formatting Weather Data
****************************************
Current Weather Conditions for:
  Evanston, 
  IL, 
  US
****************************************
  
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: Wed Aug 06 09:35:30 CDT 2008
</screen>

    <para>To run a history query, execute the following command:</para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202 history</command>
2470 INFO  WeatherFormatter  - Formatting History Data
Weather History for: 
Evanston, IL, US
  
****************************************
 * Temperature: 39
 * Condition: Heavy Rain
 * Humidity: 93
 * Wind Chill: 36
 * Date: 2007-12-02 13:45:27.187
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:24:11.725
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:27:28.475 </screen>
  </section>

  <section>
    <title>小结</title>

    <para>We've spent a great deal of time on topics not directly related
    Maven to get this far. We've done this to present a complete and
    meaningful example project which you can use to implement real-world
    systems. We didn't take any short-cuts to produce slick, canned results
    quickly, and we're not going to dazzle you with some Ruby on Rails-esque
    wizardry and lead you to believe that you can create a finished Java
    Enterprise application in "10 easy minutes!" There's too much of this in
    the market, there are too many people trying to sell you the easiest
    framework that requires zero investment of time or attention. What we're
    trying to do in this chapter is present the entire picture, the entire
    ecosystem of a multi-module build. What we've done is present Maven in the
    context of a application which resembles something you could see in the
    wild—not the fast-food, 10 minute screen-cast that slings mud at Apache
    Ant and tries to convince you to adopt Apache Maven.</para>

    <para>If you walk away from this chapter wondering what it has to do with
    Maven, we've succeeded. We present a complex set of projects, using
    popular frameworks, and we tie them together using declarative builds. The
    fact that more than 60% of this chapter was spent explaining Spring and
    Hibernate should tell you that Maven, for the most part, stepped out of
    the way. It worked. It allowed us to focus on the application itself, not
    on the build process. Instead of spending time discussing Maven, and the
    work you would have to do to "build a build" that integrated with Spring
    and Hibernate, we talked almost exclusively about the technologies used in
    this contrived project. If you start to use Maven, and you take the time
    to learn it, you really do start to benefit from the fact that you don't
    have to spend time coding up some procedural build script. You don't have
    to spend your time worrying about mundane aspects of your build.</para>

    <para>You can use the skeleton project introduced in this chapter as the
    foundation for your own, and chances are that when you do, you'll find
    yourself creating more and more modules as you need them. For example, the
    project on which this chapter was based has two distinct model projects,
    two persistence projects which persist to dramatically different
    databases, several web applications, and a Java mobile application. In
    total, the real world system I based this on contains at least 15
    interrelated modules. The point is that, you've seen the most complex
    multi-module example we're going to include in this book, but you should
    also know that this example just scratches the surface of what is possible
    with Maven.</para>

    <section>
      <title>编写接口项目程序</title>

      <para>This chapter explored a multi-module project which was more
      complex than the simple example presented in <xref
      linkend="multimodule" />, yet it was still a simplification of a
      real-world project. In a larger project, you might find yourself
      building a system resembling <xref
      linkend="fig-multimodule-web-spring-projects-complex" />.</para>

      <figure id="fig-multimodule-web-spring-projects-complex">
        <title>Programming to Interface Projects</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/multimodule-web-spring_projects-complex.png"
                       scalefit="1" width="7in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>When we use the term interface project we are referring to a Maven
      project which contains interfaces and constants only. In <xref
      linkend="fig-multimodule-web-spring-projects-complex" /> the interface
      projects would be <varname>persist-api</varname> and
      <varname>parse-api</varname>. If <varname>big-command</varname> and
      <varname>big-webapp</varname> are written to the interfaces defined in
      <varname>persist-api</varname>, then it is very easy to just swap in
      another implementation of the persistence library. This particular
      diagram shows two implementations of the <varname>persist-api</varname>
      project, one which stores data in an <acronym>XML</acronym> database,
      and the other which stores data in a relational database. If you use
      some of the concepts in this chapter, you can see how you could just
      pass in a flag to the program that swaps in a different Spring
      application context <acronym>XML</acronym> file to swap out data sources
      of persistence implementations. Just like the OO design of the
      application itself, it is often wise to separate the interfaces of an
      <acronym>API</acronym> from the implementation of the API into separate
      Maven projects.</para>
    </section>
  </section>
</chapter>