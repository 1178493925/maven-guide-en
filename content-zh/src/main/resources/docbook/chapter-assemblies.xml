<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="assemblies">
  <title>Maven套件</title>

  <section>
    <title>简介</title>

    <para>Maven提供了可以用来创建大多数常见归档类型的插件，这些归档类型中的大部分可以由其它项目作为依赖使用。这样的插件有<acronym>JAR</acronym>,
    <acronym>WAR</acronym>, <acronym>EJB</acronym>, 以及
    <acronym>EAR</acronym>插件。如在<xref
    linkend="lifecycle" />中讨论的那样，这些插件对应于不同的项目打包类型，每种类型的构建过程都有微小的差别。虽然Maven有插件及自定义生命周期来支持标准的打包类型，但还是有些时候你需要创建一个自定义格式的归档文件或目录。这样的归档叫做Maven套件(Assembly)。</para>

    <para>在很多情况下你需要为你的项目构建自定义的归档。最常见的可能就是项目分发。单词“分发(distribution)”意思是，根据项目将会如何被使用，为不同的人（或项目）提供不同的东西。本质上来说，这些归档是为用户提供一种便捷的方式来安装，否则用户就必须使用项目的发布版本。一些情况下，这可能是构建一个带有应用服务器（如Jetty）的web应用。还有一些情况，可能是包裹了项目API文档，源码，和已编译字节码的JAR文件。当你构建项目的最终分发包的时候，Maven套件就十分有用了。以<xref
    linkend="repository-manager" />中介绍的Nexus为例，它是一个大型的包含了很多模块Maven项目的产品，而你从Sonatype下载的最终归档就是一个Maven套件。</para>

    <para>大多数情况下，Assembly插件十分适用于构建项目的分发包。然而，套件不一定就要是分发包；套件的目的是能让用户灵活的构建任意类型的自定义归档文件。本质上说，套件是为了弥补由项目打包类型所提供的标准归档格式的不足。当然，你可以完全写一个Maven插件来帮助生成你的自定义归档格式，同时创建生命周期映射和构件处理配置来告诉Maven如何部署。但大部分情况下，有了Assembly插件，这就完全没有必要了。该插件为创建自定义归档格式提供了普遍的支持，你不需要花很多时间来编写Maven插件代码。</para>
  </section>

  <section id="sect-assembly-basics">
    <title>Assembly基础</title>

    <para>在我们进一步讨论之前，最好先花几分钟来讲一下Assembly插件的两个主要目标：<varname>assembly:assembly</varname>，和<varname>single</varname>
    mojo。我用不同的方式列出这两个目标，是因为这样可以很好的体现它们不同的使用方式。<varname>assembly:assembly</varname>目标被设计成直接从命令行调用，它永远不应该被绑定到生命周期阶段。反之，<varname>single</varname>
    mojo被设计成作为你每日构建的一部分，应该被绑定到项目生命周期的某个阶段。</para>

    <para>有这种区别的主要理由是，<varname>assembly:assembly</varname>目标在Maven术语中是一个聚合mojo；意思是，无论有多少个模块正被构建，该mojo在一个构建中最多被运行一次。它从根项目的中提取配置——通常是顶层<acronym>POM</acronym>或者命令行目录的<acronym>POM</acronym>。而在绑定到生命周期后，一个聚合mojo就会有很多讨厌的副作用。它会强迫<varname>package</varname>生命周期阶段提前运行，从而造成在一次构建中<varname>package</varname>阶段被执行了两次。</para>

    <para>由于<varname>assembly:assembly</varname>目标是一个聚合mojo，在多模块构建中它造成了一些问题，它应当在命令行中作为单独的mojo被调用。永远不要将<varname>assembly:assembly</varname>目标绑定到生命周期阶段中。<varname>assembly:assembly</varname>是Assembly插件最原始的目标，不是被设计成用作项目标准构建过程的一部分的。但很显然，为一个项目生成套件归档合情合理，因此开发了<varname>single</varname>
    mojo。该mojo假设它被绑定到了构建过程的正确部分，因此它能访问它在大型模块Maven项目生命周期中执行需要的项目文件及构件。在一个多模块环境中，它会执行很多次，因为它被绑定到了不同模块的<acronym>POM</acronym>上。不像<varname>assembly:assembly</varname>，<varname>single</varname>从来不会强制在它之前执行另外一个生命周期阶段。</para>

    <para>除了上述的两项，Assembly插件还提供了很多其它目标；然后，讨论这些mojo超出了本章范围，主要是由于它们是为一切奇怪或者过时的用例服务的，基本上不会被用到。只要可能，你都应该坚持在命令行生成套件时使用<varname>assembly:assembly</varname>，在绑定到生命周期阶段生成套件时使用<varname>single</varname>。</para>

    <section>
      <title>预定义的套件描述符</title>

      <para>虽然很多人选择创建他们自己的归档解决方案——称之为套件描述符——但这不是必须的。Assembly插件为一些常用的归档类型提供了内置的描述符，你可以不写
      一行配置就马上使用。以下的套件描述符是由Maven Assembly插件预定义的：</para>

      <variablelist>
        <varlistentry>
          <term><varname>bin</varname></term>

          <listitem>
            <para>假设一个项目构建了一个jar作为它的主构件，<varname>bin</varname>
            描述符用来包裹该主构件和项目的<filename>LICENSE</filename>,
            <filename>README</filename>,
            和<filename>NOTICE</filename>文件。我们可以认为这是一个完全自包含项目的最可能小的二进制分发包。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar-with-dependencies</varname></term>

          <listitem>
            <para><varname>jar-with-dependencies</varname>描述符构建一个带有主项目jar文件和所有项目运行时依赖未解开内容的<acronym>JAR</acronym>归档文件。外加上适当的<varname>Main-Class</varname>
            Manifest条目（在下面的“插件配置”讨论），该描述符可以为你的项目生成一个自包含的，可运行的jar，即使该项目含有依赖。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>project</varname></term>

          <listitem>
            <para><varname>project</varname>描述符会简单的将你文件系统或者版本控制中的项目目录结构整个的归档。当然，target目录会被忽略，目录中的版本控制元数据文件如<filename>.svn</filename>和<filename>CVS</filename>目录也会被忽略。基本上，该描述符的目的是创建一个解开后就立刻能由Maven构建的归档。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>src</varname></term>

          <listitem>
            <para><varname>src</varname>描述符生成一个包含你项目源码，<filename>pom.xml</filename>文件，以及项目根目录中所有<filename>LICENSE</filename>，<filename>README</filename>，和<filename>NOTICE</filename>文件的归档。它类似于<varname>project</varname>描述符，大部分情况下能生成一个可以被Maven构建的归档。然而，由于它假设所有的源文件和资源文件都位于标准的<filename>src</filename>目录下，它就可能遗漏那些非标准的目录和文件，而这些文件往往对构建起着关键作用。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>构建一个套件Building an Assembly</title>

      <para>Assembly插件可以以两种方式运行：你可以直接在命令行调用，或者你可以通过绑定到生命周期阶段将其配置成标准构建过程的一部分。直接调用自有它的用处，主要是为了那些一次性，不属于你项目核心分发包的套件。大部分情况下，你可能以标准项目构建过程一部分的形式生成套件。这么做，不管你的项目被安装还是部署，都能包含你自定义的套件，从而它们也一直是对用户可用的。</para>

      <para>作为一个直接调用Assembly插件的例子，考虑你想要将你的项目复制一份给别人让他们也能从源码构建。你需要同时包含源码，而不仅仅是一个最终的产品。而且你只是偶尔需要这么做，因此往你的<abbrev>POM</abbrev>中添加配置显得没有必要。你可以使用如下的命令：</para>

      <screen>$ <command>mvn -DdescriptorId=project assembly:single</command> 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.zip
...</screen>

      <para>假如你想要从你的项目生成一个可运行的<acronym>JAR</acronym>。如果你的项目完全是自包含的，没有任何依赖，那么使用<acronym>JAR</acronym>插件的archive配置就能做到。但是，大部分项目都有依赖，而且这些依赖需要被引入到可运行<acronym>JAR</acronym>文件中。这种情况下，每次<acronym>JAR</acronym>被安装或部署的时候你都要确认可运行<acronym>JAR</acronym>包含了这些依赖。</para>

      <para>假设该项目的main类是<classname>org.sonatype.mavenbook.App</classname>，如下的<acronym>POM</acronym>配置将创建一个可运行的<acronym>JAR</acronym>：</para>

      <example>
        <title>可运行JAR的套件描述符</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;executable-jar&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Assemblies Executable Jar Example&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-lang&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
 &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;create-executable-jar&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
              &lt;archive&gt;
                &lt;manifest&gt;
                  &lt;mainClass&gt;org.sonatype.mavenbook.App&lt;/mainClass&gt;
                &lt;/manifest&gt;
              &lt;/archive&gt;
           &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>以上配置中有两点我们要注意。首先，我们不再像上次那样使用<sgmltag>descriptorId</sgmltag>参数，这里我们使用<sgmltag>descriptorRefs</sgmltag>配置。这样可以允许在同一次Assembly插件执行过程中使用多个套件类型，同时还能保持不要引入太多额外的配置。第二，<sgmltag>configuration</sgmltag>下的<sgmltag>archive</sgmltag>元素设置最终JAR的<varname>Main-Class</varname>
      manifest属性。该配置在所有创建<acronym>JAR</acronym>文件的插件中都很常见，如由默认打包类型使用的<acronym>JAR</acronym>插件。</para>

      <para>现在，你可以通过执行<command>mvn
      package</command>生成可运行的<acronym>JAR</acronym>文件。之后，我们看一下target目录的内容，验证一下可运行<acronym>JAR</acronym>已经被生成了。最后，为了证明我们真的有可运行<acronym>JAR</acronym>了，那就运行一下吧。</para>

      <screen>$ <command>mvn package</command>
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: /Users/~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: /Users/~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ <command>ls -1 target</command>
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ <command>java -jar \
        target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar </command>
Hello, World!</screen>

      <para>从以上的输出你可以看到，标准的项目构建现在生成了一个新的额外的构件。这个新的构件有一个名为<varname>jar-with-dependencies</varname>的分类器。最后，我们验证了这个新的<acronym>JAR</acronym>是可运行的，运行这个<acronym>JAR</acronym>会产生我们期望的输出“Hello,
      World!”。</para>
    </section>

    <section>
      <title>套件作为依赖</title>

      <para>当你将生成套件作为你标准构建过程的一部分的时候，这些套件归档会被附着到你项目的主构件上。意思是，当它们会随着主构件的安装和部署一起被安装或部署，而且它们会以差不多相同的方式被解析。每个套件构件会被给予同样的基本坐标（<varname>groupId</varname>,
      <varname>artifactId</varname>, 和
      <varname>version</varname>）。但是，由于这些构件是附件，在Maven中意思是，它们是基于主项目构建的某些方面派生出来的。这里是一些例子，<varname>source</varname>套件包含了项目的原始输入，<varname>jar-with-dependencies</varname>套件包含了项目的类及依赖。由于这种派生的性质，附属构件就能精确的规避一个项目，或一个构件的Maven需求。</para>

      <para>由于套件（通常）是附属构件，除了标准的构件坐标，它们还必须拥有一个分类器来和主构件加以区分。默认情况下，该分类器就是套件描述符的定义符。当如上例使用内置的套件描述符的时候，套件描述符的定义符和<sgmltag>descriptorRef</sgmltag>中对应使用的定义符是一样的。</para>

      <para>在你伴随着项目的主构件部署了一个套件后，如何才能在其它项目中使用这个套件呢？答案很简单。回忆一下<xref
      linkend="sect-maven-coordinates" />和<xref
      linkend="sect-more-coordinates" />中讨论的项目依赖，一个项目依赖于另外一个项目的时候，它使用项目坐标四个元素的组合：<varname>groupId</varname>,
      <varname>artifactId</varname>, <varname>version</varname>, 和
      <varname>packaging</varname>。在<xref
      linkend="sect-platform-classifier" />中，同一个项目的构件有针对多个平台的变种，该项目设置了值为<varname>win</varname>或<varname>linux</varname>的<varname>classifier</varname>元素，以为目标平台选择合适的依赖构件。使用项目的坐标加上套件被安装或部署时的分类器，我们就可以将套件设为依赖。如果套件不是一个<acronym>JAR</acronym>归档，我们还需要声明其类型。</para>
    </section>

    <section>
      <title>通过套件依赖组装套件</title>

      <para>起这么一个使人困惑的名字是怎么回事？让我们建立这样一个能解释组装套件(assembling
      assemblies)概念的场景。假设你想要创建一个归档，它包含了一些项目套件。再假设你有一个多模块构建，并且想要部署一个包含很多相关项目套件的套件。在本节的例子中，我们要为一组通常一起被使用的项目创建一个“可构建”的项目目录。为了简便，我们要重用前面讨论的两个<varname>project</varname>和<varname>jar-with-dependencies</varname>内置套件描述符。在这个特定的例子中，假设每个项目在主要的<acronym>JAR</acronym>构件之外还创建<varname>project</varname>套件。假设这个多模块构建中每个项目都使用<varname>project</varname>
      <sgmltag>descriptorRef</sgmltag>绑定到<varname>package</varname>阶段的<varname>single</varname>目标。每个模块都会从顶层的<filename>pom.xml</filename>中继承该配置，其<sgmltag>pluginManagement</sgmltag>元素如<xref
      linkend="ex-top-pom-assembly" />所示：</para>

      <example id="ex-top-pom-assembly">
        <title>在顶层POM中配置项目套件</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-2&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;create-project-bundle&lt;/id&gt;
              &lt;phase&gt;package&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;project&lt;/descriptorRef&gt;
                &lt;/descriptorRefs&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>每个项目的<acronym>POM</acronym>都使用很小的一部分插件声明引用了<xref
      linkend="ex-top-pom-assembly" />中的插件配置，如<xref
      linkend="ex-activating-assembly" />所示：</para>

      <example id="ex-activating-assembly">
        <title>在子项目中激活Assembly插件配置</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</programlisting>
      </example>

      <para>要生成一组项目套件，从顶层目录运行<command>mvn
      install</command>。你会看到Maven使用分类器将套件安装到你的本地仓库。</para>

      <screen>$ <command>mvn install</command>
...
[INFO] Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
                  second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
       ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
                  second-project-1.0-SNAPSHOT-project.tar.gz
...
[INFO] Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
                  second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
       ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
                  second-project-1.0-SNAPSHOT-project.tar.bz2
...
[INFO] Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
                  second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
       ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
                  second-project-1.0-SNAPSHOT-project.zip
...</screen>

      <para>当你运行install的时候，Maven会将每个项目的主构件和每个套件复制到你的本地Maven仓库中。现在本地的所有其它项目都可以使用依赖引用这些构件。如果你最终的目的是创建一个包含多个多模块项目构件的软件包，你可以创建一个项目，它以依赖的形式引入其它项目的套件。这个包裹项目（贴切的命名为project-bundle）负责创建一个最终的包裹套件。这个包裹项目的<acronym>POM</acronym>如<xref
      linkend="ex-bundling-pom" />所示：</para>

      <example id="ex-bundling-pom">
        <title>套件包裹项目的POM</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;project-bundle&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;Assemblies-as-Dependencies Example Project Bundle&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;first-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;second-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;bundle-project-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
      </example>

      <para>该包裹项目的<acronym>POM</acronym>引用了来自于<varname>first-project</varname>和<varname>second-project</varname>的两个套件。这个POM指定了一个值为<varname>project</varname>的分类器和一个值为<varname>zip</varname>的类型，而不是直接引用过了项目的主构件。这告诉Maven去解析<varname>project</varname>套件创建的<acronym>ZIP</acronym>归档。注意包裹项目生成了一个<varname>jar-with-dependencies</varname>套件。<varname>jar-with-dependencies</varname>并不创建一个非常简洁的套件，而是简单的创建一个包含所有依赖拆解内容的<acronym>JAR</acronym>文件。<varname>jar-with-dependencies</varname>实际上做的事情是：告诉Maven拿来所有依赖，将其拆解，然后创建一个包含当前项目所有输出的归档。在这个项目中，它的效果就是创建一个带有<varname>first-project</varname>和<varname>second-project</varname>套件拆解内容的<acronym>JAR</acronym>文件，</para>

      <para>该样例展示了如何不用自定义套件描述符就能联合Maven
      Assembly插件的基本能力。它实现了创建一个包含多模块项目内容的单独归档这样一个目的。这个时候，<varname>jar-with-dependencies</varname>仅仅是一个存储格式，因此我们没必要指定<varname>Main-Class</varname>的manifest属性。我们只要正常的构建<varname>project-bundle</varname>项目就能得到套件。</para>

      <screen>$ <command>mvn package</command>
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
        project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
</screen>

      <para>要验证project-bundle套件是否包含了所有依赖套件的拆解内容，运行<command>jar
      tf</command>：</para>

      <screen>$ <command>java tf \
  target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar</command>
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java</screen>

      <para>阅读本节内容之后，标题应该容易理解了。我们使用了一个包裹项目，它依赖于两个项目的套件，然后我们再根据这两个项目的套件装配出一个最终的套件。</para>
    </section>
  </section>

  <section>
    <title>套件描述符概述</title>

    <para>当<xref
    linkend="sect-assembly-basics" />中介绍的标准套件描述符不够的时候，你就需要自定义你自己的套件描述符。套件描述符是一个定义了套件结构和内容的XML文档。</para>

    <figure>
      <title>套件描述符图解</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/assemblies_descriptor.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>套件描述符包含五个主要的小节，以及两个额外的小节：一个叫做组件描述符，用来指定标准的套件描述符片段，另一个用来指定自定义的文件处理类，以帮助管理套件生产过程。</para>

    <variablelist>
      <varlistentry>
        <term>基本配置</term>

        <listitem>
          <para>该小节包含了所有套件需要的信息，还有一些关于整个归档格式的额外配置选项，如所有归档项使用的基础路径。为了使套件描述符有效，你必须至少指定套件id，至少一种格式，以及至少一个如上所示的其它小节。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>文件信息</term>

        <listitem>
          <para>套件描述符这个片段中的配置应用于文件系统中该项目目录结构中特定的文件。这个片段包含了两个主要部分：<sgmltag>files</sgmltag>和<sgmltag>fileSets</sgmltag>。你可以使用<sgmltag>files</sgmltag>和<sgmltag>fileSets</sgmltag>来控制套件中文件的权限，从套件中包含或者排除文件。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>依赖信息</term>

        <listitem>
          <para>几乎任意大小的所有的项目都依赖于其它项目。在创建分发归档的时候，项目依赖通常被包含在最终产品套件中。该小节管理依赖被包含在最终归档中的方式。该小节允许你依赖是否被拆解，是直接添加到<filename>lib/</filename>目录中，还是映射至新的文件名。该小节也允许你控制套件中依赖的权限，以及哪些依赖被包含在套件中。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>仓库信息</term>

        <listitem>
          <para>有时，将构建一个项目必要的所有构件分隔开来很有用，它们是否是依赖构件，依赖构件的<acronym>POM</acronym>，或者甚至是一个项目本身POM的祖先（你的父<acronym>POM</acronym>，父<acronym>POM</acronym>的父<acronym>POM</acronym>，等等）。该小节允许你通过各种配置选项，在套件中包含一个或者多个构件仓库目录，然而Assembly插件没有能力引入在这些仓库中的插件构件。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>模块信息</term>

        <listitem>
          <para>套件描述符的这一小节允许你在装备自定义归档的时候利用父子关系，以包含你项目模块的源文件，构件，和依赖。这是套件描述符中最复杂的小节，因为它允许你以两种方式操作模块和子模块：以一系列<sgmltag>fileSets</sgmltag>（通过<sgmltag>sources</sgmltag>小节）或者以一系列<sgmltag>dependencySets</sgmltag>（通过<sgmltag>binaries</sgmltag>小节）。</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section>
    <title>套件描述符</title>

    <para>本节作为一个套件描述符的教程，包含了一些开发自定义套件描述符的指南。Assembly插件是Maven世界中最大的插件之一，也是最灵活的插件之一。</para>

    <section>
      <title>套件描述符中的属性引用</title>

      <para>任何在<xref
      linkend="sect-properties" />中讨论的属性都可以在一个套件描述符中引用。在套件描述符被Maven使用之前，它首先会根据<acronym>POM</acronym>及构建环境的信息修改一些对应的值。所有运行时<acronym>POM</acronym>中可修改的值，同样适用于套件描述符，包括<acronym>POM</acronym>属性，<acronym>POM</acronym>元素的值，系统属性，用户定义的属性，以及操作系统环境变量。</para>

      <para>这一插值阶段的例外是<sgmltag>outputDirectory</sgmltag>，<sgmltag>outputDirectoryMapping</sgmltag>，和<sgmltag>outputFileNameMapping</sgmltag>元素。保持它们原始的值是为了能在解析构件特定的——或者组件特定的信息的时候，得到正确的值。</para>

      <!--This last paragraph is not clear.
The reason these are held back in their raw form is to allow artifact- or module-specific information
 to be applied when resolving expressions in these values, on a per-item basis.-->
    </section>

    <section>
      <title>必须的套件信息</title>

      <para>对于每个套件来说，有两个重要的信息是必须的：id，和一个要生成的归档格式的列表。实际情况中，至少还需要其它一小节描述符的内容——因为大部分归档格式如果没有可引入的文件，将一文不值，同时，如果没有一个id和至少一种格式，就不会产生任何归档。id首先被用到归档的文件名中，同时它还是归档构件分类器名称一部分。格式（format）字符串同时也控制archiver-component实例去创建最终的套件归档。所有套件描述符必须包含一个id和至少一个format：</para>

      <example id="ex-required-assembly">
        <title>必须的套件描述符元素</title>

        <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;bundle&lt;/id&gt; 
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>套件id可以是任意不包含空格的字符串。标准的实践是使用破折号（-）来分隔单词。如果你要创建一个拥有有趣的唯一打包结构（interesting
      unique package
      structure）的套件，那么其id就会是interesting-unique-package。同时，套件描述符还支持多种格式，允许你轻松创建.zip,
      .tar.gz,和.tar.bz2等熟悉分发归档。如果你没有找到你需要的归档格式，你也可以创建自定义的格式。自定义格式在<xref
      linkend="sect-componentDescriptors" />中讨论。Assembly插件原生支持多种归档格式，包括：</para>

      <itemizedlist>
        <listitem>
          <para><varname>jar</varname></para>
        </listitem>

        <listitem>
          <para><varname>zip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar</varname></para>
        </listitem>

        <listitem>
          <para><varname>bzip2</varname></para>
        </listitem>

        <listitem>
          <para><varname>gzip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.gz</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.bz2</varname></para>
        </listitem>

        <listitem>
          <para><varname>rar</varname></para>
        </listitem>

        <listitem>
          <para><varname>war</varname></para>
        </listitem>

        <listitem>
          <para><varname>ear</varname></para>
        </listitem>

        <listitem>
          <para><varname>sar</varname></para>
        </listitem>

        <listitem>
          <para><varname>dir</varname></para>
        </listitem>
      </itemizedlist>

      <para>id和format至关重要，因为它们将成为套件归档的坐标的一部分。<xref
      linkend="ex-required-assembly" />中的例子会创建一个打包类型为zip，分类器为bundle的套件构件。</para>
    </section>
  </section>

  <section>
    <title>控制一个套件的内容</title>

    <para>理论上，只有id和format才是一个合法套件描述符必要的元素；然而，对于大多数归档来说，如果输出归档中没有包含一个文件，该归档就会失效。套件描述符中，有五个主要的部分来定义哪些文件被包含到套件中，他们是：files,
    fileSets, dependencySets, repositories,
    和moduleSets。为了最有效的探究这些部分，我们首先讨论最基本的部分：files。然后，我们接着讨论两个最常用的部分：fileSets和dependencySets。在你理解了它们如何工作之后，就能更轻松的理解repositories和moduleSets。</para>

    <section>
      <title><sgmltag>Files</sgmltag> 元素</title>

      <para>files元素是套件描述符中最简单的部分，它被设计成定义那些相对与你项目目录的路径。使用该元素，你就可以完全控制哪些文件被包含到你的套件中，它们如何被命名，以及它们在归档中的位置。</para>

      <example id="ex-assembly-files">
        <title>使用files在一个套件中包含一个JAR文件</title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;files&gt;
    &lt;file&gt;
      &lt;source&gt;target/my-app-1.0.jar&lt;/source&gt;
      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;
      &lt;destName&gt;my-app.jar&lt;/destName&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>假设你要构建一个名为my-app的版本为1.0的项目，<xref
      linkend="ex-assembly-files" />会将你项目的JAR文件包含到套件的lib/目录下，同时除去了文件名的版本部分，使最终的文件名为my-app.jar。该描述符会让这个JAR文件对于所有人可读，对于拥有者可写（这就是0664模式的意思，这里使用了Unix四位十进制数的权限标记）。要了解更多关于fileMode的值的格式的信息，请看维基百科的解释<ulink
      url="http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions">four-digit
      Octal notation</ulink>。</para>

      <para>如果你知道所有需包含的文件的完整列表，你就可以使用file条目构建了一个十分复杂的套件。即使在构建开始之前你不知道这个完整的列表，你也可以使用一个自定义的Maven插件来发现这个列表，然后生成如上例中的套件描述符。files元素能给你提供细粒度的文件控制，包括每个文件的权限，位置及名称，但是在一个大型的归档中，为所有文件罗列file元素就比较繁琐了。因此大部分情况下，你需要使用fileSets针对一组文件进行操作。余下的四个文件包含配置元素，被设计用来帮助你包含整个一组匹配某个特定标准的文件。</para>
    </section>

    <section>
      <title><sgmltag>FileSets</sgmltag> 元素</title>

      <para>与files元素类似，fileSets应用于那些相对于你的项目结构有一个明确位置的文件。然而，和files元素不同的是，fileSets描述一组文件，这组文件由文件模式或者路径模式定义，判断文件在总体目录结构中的位置是否匹配该模式。最简单的fileSet仅仅指定文件所处的位置：</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>这个文件集合仅仅包含src/main/java目录下的内容。它利用了很多该元素的默认设置，这里我简要的介绍一下。</para>

      <para>首先，你会注意到我们没有指定匹配的文件集合应该位于套件中的什么位置。默认情况，目标输出目录（由outputDirectory指定）和源文件目录（在这里，是src/main/java）是一样的。此外，我们没有指定任何包含和排除模式。当它们为空的时候，fileSet假设会包含整个源文件目录，并伴随着一些重要的例外。这一规则的例外主要是为了排除源码控制元数据文件和目录，这一例外由userDefaultExclludes标记控制，其值默认为true。当userDefaultExcludes被开启的时候，所有如.svn/和CVS/的目录都会被排除在套件归档之外。<xref
      linkend="sect-default-excludes" />显示了一个详细的默认排除模式的列表。</para>

      <para>如果想要更多的对于文件集的控制，我们可以进一步显式的指定。<xref
      linkend="ex-explicit-fileSet" />展示了一个指定所有默认值的fileSet元素。</para>

      <example id="ex-explicit-fileSet">
        <title>Including Files with <sgmltag>fileSet</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;**&lt;/include&gt;
      &lt;/include&gt;
      &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
      &lt;directoryMode&gt;0755&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>includes元素使用了一系列include元素，后者包含了路径模式。这些模式可能包含一些通配符，“**”表示匹配一个或者多个目录，“*”表示匹配文件名的任一部分，“？”表示匹配文件名中的任意单个字符。<xref
      linkend="ex-explicit-fileSet" />使用了一个fileMode元素来指定该文件集对于所有人可读，但是只有文件所有者可写。由于fileSet包含了目录，我们还可以指定directoryMode，它的使用方式和fileMode完全一样。一个目录的执行权限控制用户列出目录内容，我们这里想要确保目录对于所有人是可读且可执行的。和文件一样，只有目录所有者才拥有写的权限。</para>

      <para>fileSet元素还提供了一些其它的配置选项。首先，它允许一个excludes子元素，其形式和includes完全一样。这些排除模式能让你从fileSet中排除特定的文件。包含模式优先于排除模式。此外，如果你想要将所包含文件中的表达式替换成属性值，你可以将filtering标记设置成true。表达式可以用${}标记（如${project.groupId}）或者@@标记（这是标准的Ant表达式，如@project.groupId）来表示。你可以使用lineEnding元素来调整文件的换行字元；可用lineEnding值有：</para>

      <variablelist>
        <varlistentry>
          <term>keep</term>

          <listitem>
            <para>保持原始文件的换行字元。（这是默认值。）</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>unix</term>

          <listitem>
            <para>Unix风格的字元</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lf</term>

          <listitem>
            <para>仅仅一个换行符</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dos</term>

          <listitem>
            <para>MS-DOS风格的字元</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>crlf</term>

          <listitem>
            <para>回车后加一个换行符</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>最后，如果你想要确保所有文件匹配模式都被使用到，你可以使用userStrictFiltering元素，并将其值指定为true（默认值为false）。有些时候未使用的模式可能预示着某个中间输出目录缺失文件。使用值为true的useStrictFiltering后，当某个包含模式未满足，Assembly插件就会失败。换句话说，如果你使用一个包含模式来包含构建中的某个文件，但是这个文件不存在，将userStrictFiltering设置成true会使得Maven构建失败。</para>

      <!--TODO: JCasey, I had to take the statement about Ant Expressions out because I couldn't verify it.
I can add this back in later.  I didn't want to talk about it without an example.  - TIM-->
    </section>

    <section id="sect-default-excludes">
      <title><sgmltag>fileSets的默认排除模式</sgmltag></title>

      <para>当你使用默认排除模式的时候，Maven
      Assembly插件不仅仅会忽略SVN和CVS信息。默认情况排除拥由Codehaus中<ulink
      url="http://plexus.codehaus.org/plexus-utils/">plexus-utils</ulink>项目的<ulink
      url="http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java">DirectoryScanner</ulink>类定义。这个排除模式的数组被定义为一个static,
      final的String数组，其名称为DEFAULTEXCLUDES。该变量的内容如<xref
      linkend="ex-default-excludes" />所示。</para>

      <example id="ex-default-excludes">
        <title>Plexus Utils中模式排除模式的定义</title>

        <programlisting language="java">   public static final String[] DEFAULTEXCLUDES = {
        // Miscellaneous typical temporary files
        "**/*~",
        "**/#*#",
        "**/.#*",
        "**/%*%",
        "**/._*",

        // CVS
        "**/CVS",
        "**/CVS/**",
        "**/.cvsignore",

        // SCCS
        "**/SCCS",
        "**/SCCS/**",

        // Visual SourceSafe
        "**/vssver.scc",

        // Subversion
        "**/.svn",
        "**/.svn/**",

        // Arch
        "**/.arch-ids",
        "**/.arch-ids/**",

        //Bazaar
        "**/.bzr",
        "**/.bzr/**",

        //SurroundSCM
        "**/.MySCMServerInfo",

        // Mac
        "**/.DS_Store"
    };</programlisting>
      </example>

      <para>这个默认的模式数组会排除来自于如<ulink
      url="http://www.gnu.org/software/emacs/">GNU
      Emacs</ulink>的编辑器的临时文件，Mac中常见的临时文件，以及一些常见源码控制系统的元数据文件（虽然Visual
      SourceSafe得到的更多的是恶名而非源码控制系统）。如果你需要覆盖这个默认的排除模式，你可以将setDefaultExcludes设置成false，然后在你自己的套件描述符中定义一组排除模式。</para>
    </section>

    <section id="sect-output-algorithm">
      <title><sgmltag>dependencySets</sgmltag> 元素</title>

      <para>套件中最常见的需求之一是包含项目的依赖。files和fileSets只是处理你项目中的文件，而依赖文件不存在于你的项目中。项目依赖的构件需要在构建过程中由Maven解析。依赖构件是抽象的，它们缺少明确的位置，它们使用一组Maven坐标来进行解析。相比较使用file和fileSets需要一个具体的资源路径，我们使用一组Maven坐标和依赖范围来包含或者排除依赖。</para>

      <para>最简单的dependencySet是一个简单空元素：</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet/&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>上述的dependencySet会匹配你项目的所有运行时依赖（运行时范围隐式的包含编译范围依赖），并且它会将这些依赖添加到套件归档的根目录中。如果当前项目的主构件存在，它同时会复制该主构件至套件归档的根目录。</para>

      <note>
        <para>等等？我之前认为dependencySet是用来包含我项目的依赖的，而不是项目的主构件。这一反直觉的副作用是Assembly插件版本2.1的一个bug，但是这个bug被广泛使用了，由于Maven强调向后兼容性，这一反直觉的，错误的行为就必须在2.1和2.2版中保持下来。但是，你可以控制这一行为，只要设置useProjectArtifact为false即可。</para>
      </note>

      <para>虽然没有任何配置的默认依赖集合十分有用，但该元素同时也支持很多配置选项，能让你定制其行为以适应你的环境。例如，第一件你想对依赖集合做的事情可能就是排除当前项目的构件，你会想设置userProjectArtifact为false（再次强调，由于历史原因，该配置的默认值为true）。这让你能够把项目输出和项目依赖分开管理。还有，你可能会将unpack标记为true（默认为false）来拆解依赖构件。当unpack被设置成true时，Assembly插件会组合所有匹配依赖的拆解内容至归档的根目录。</para>

      <para>从这里你就可以看到，你有很多选择来控制依赖集合。下一节我们讨论如何定义依赖集合的输出位置，如何通过范围来包含和排除依赖。最后，我们会扩展依赖集的拆解功能，研究一些拆解依赖的高级选项。</para>

      <section id="sect-output-location">
        <title>自定义依赖输出目录</title>

        <para>有两个配置选项可以用来协调定义依赖文件在套件归档中的位置：outputDirectory和outputFileNameMapping。你可能想要使用依赖构件自身的属性来定义其在套件中的位置。比如说你想要将依赖放到与其groupId对应的目录中。这时候，你可以使用dependencySet的outputDirectory元素，并提供如下的配置：</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;${artifact.groupId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>这会使得所有单独的依赖被放到与其groupId对应的子目录中。</para>

        <para>如果你想要更进一步的自定义，并移除所有依赖的版本号。你可以使用outputFileNameMapping来自定义每个输出文件的文件名，如：</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;${artifact.groupId}&lt;/outputDirectory&gt;
      &lt;outputFileNameMapping&gt;
        ${module.artifactId}.${module.extension}
      &lt;/outputFileNameMapping&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>这个例子中，依赖commons:commons-codec版本1.3最后会成为文件commons/commons-codec.jar。</para>
      </section>

      <section>
        <title>依赖输出位置的属性插值</title>

        <para>正如在套件插值一小节所介绍的那样，outputDirectory和outputFileNameMapping不会和套件描述符的其它内容一样接受插值，这是因为它们的原始值必须使用额外的，构件特定的表达式解析器进行解释。</para>

        <para>对于这两个元素可用的构件表达式只有微小的差别。对两者来说，所有POM中及套件描述符其它部分中可用的${project.*},
        ${pom.*},
        和${*}表达式，这里也能用。对于outputFileNameMapping元素来说，解析表达式的过程如下：</para>

        <orderedlist>
          <listitem>
            <para>如果表达式匹配模式${artifact.*}：</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>基于依赖的Artifact实例进行匹配（解析：groupId, artifactId, version,
                baseVersion, scope, classifier, 和file.*）</para>
              </listitem>

              <listitem>
                <para>基于依赖的ArtifactHander实例进行匹配（解析：expression）</para>
              </listitem>

              <listitem>
                <para>基于和依赖Artifact相关的Project实例进行匹配（解析：主要是POM属性）</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>如果表达式匹配模式${pom.*}或者${project.*}：</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>基于当前构建的项目实例（MavenProject)进行解析。</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>如果表达式匹配模式${dashClassifier?}，而且Artifact实例包含一个非空的classfier，则解析成classifier前置一个破折号（-classfier）。否则，解析成一个空字符串。</para>
          </listitem>

          <listitem>
            <para>尝试基于当前构建的项目实例解析表达式。</para>
          </listitem>

          <listitem>
            <para>尝试基于当前项目的POM属性解析表达式。</para>
          </listitem>

          <listitem>
            <para>尝试基于系统属性解析表达式。</para>
          </listitem>

          <listitem>
            <para>尝试基于操作系统环境变量解析表达式。</para>
          </listitem>
        </orderedlist>

        <para>outputDirectory也以差不多的方式进行插值，区别在于，对于outputDirectory没有可用的${artifact.*}信息，而只有特定构件的${project.*}实例信息。因此，上述罗列的的相关条目（上述处理过程列表中的1a,
        1b和3）就无效了。</para>

        <para>我们怎么知道何时使用outputDirectory，何时使用outputFileNameMapping呢？当依赖被拆解的时候，只有outputDirectory会被用来计算输出路径。当依赖以完整的文件被管理时（不拆解），outputDirectory和outputFileNameMapping两者可以同时使用。在同时的时候，其结果等价于：</para>

        <programlisting language="xml">&lt;archive-root-dir&gt;/&lt;outputDirectory&gt;/&lt;outputFileNameMapping&gt;</programlisting>

        <para>在没有outputDirectory的时候，它便不被使用。当没有outputFileNameMapping的时候，其默认值为：</para>

        <programlisting language="java">${artifact.artifactId}-${artifact.version}${dashClassifier?}.${artifact.extension}</programlisting>
      </section>

      <section>
        <title>Including and Excluding Dependencies by Scope</title>

        <para>In <xref linkend="pom-relationships" />, it was noted that all
        project dependencies have one scope or another. Scope determines when
        in the build process that dependency normally would be used. For
        instance, test-scoped dependencies are not included in the classpath
        during compilation of the main project sources; but they are included
        in the classpath when compiling unit test sources. This is because
        your project’s main source code should not contain any code specific
        to testing, since testing is not a function of the project (it’s a
        function of the project’s build process). Similarly, provided-scoped
        dependencies are assumed to be present in the environment of any
        eventual deployment. However, if a project depends on a particular
        provided dependency, it is likely to require that dependency in order
        to compile. Therefore, provided-scoped dependencies are present in the
        compilation classpath, but not in the dependency set that should be
        bundled with the project’s artifact or assembly.</para>

        <para>Also from <xref linkend="pom-relationships" />, recall that some
        dependency scopes imply others. For instance, the
        <varname>runtime</varname> dependency scope implies the
        <varname>compile</varname> scope, since all compile-time dependencies
        (except for those in the <varname>provided</varname> scope) will be
        required for the code to execute. There are a number of complex
        relationships between the various dependency scopes which control how
        the scope of a direct dependency affects the scope of a transitive
        dependency. In a Maven Assembly descriptor, we can use scopes to apply
        different settings to different sets of dependencies
        accordingly.</para>

        <para>For instance, if we plan to bundle a web application with <ulink
        url="http://www.mortbay.org/jetty-6/">Jetty</ulink> to create a
        completely self-contained application, we’ll need to include all
        provided-scope dependencies somewhere in the jetty directory structure
        we’re including. This ensures those provided dependencies actually are
        present in the runtime environment. Non-provided, runtime dependencies
        will still land in the WEB-INF/lib directory, so these two dependency
        sets must be processed separately. These dependency sets might look
        similar to the following XML.</para>

        <example>
          <title>Defining Dependency Sets Using Scope</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Provided-scoped dependencies are added to the
        <filename>lib/</filename> directory in the assembly root, which is
        assumed to be a libraries directory that will be included in the Jetty
        global runtime classpath. We’re using a subdirectory named for the
        project’s <varname>artifactId</varname> in order to make it easier to
        track the origin of a particular library. Runtime dependencies are
        included in the <filename>WEB-INF/lib</filename> path of the web
        application, which is located within a subdirectory of the standard
        Jetty <filename>webapps/</filename> directory that is named using a
        custom <acronym>POM</acronym> property called
        <varname>webContextName</varname>. What we've done in the previous
        example is separate application-specific dependencies from
        dependencies which will be present in a Servlet contains global
        classpath.</para>

        <para>However, simply separating according to scope may not be enough,
        particularly in the case of a web application. It’s conceivable that
        one or more runtime dependencies will actually be bundles of
        standardized, non-compiled resources for use in the web application.
        For example, consider a set of web application which reuse a common
        set of Javascript, CSS, SWF, and image resources. To make these
        resources easy to standardize, it’s a common practice to bundle them
        up in an archive and deploy them to the Maven repository. At that
        point, they can be referenced as standard Maven dependencies -
        possibly with a dependency type of <varname>zip</varname> - that are
        normally specified with a runtime scope. Remember, these are
        resources, not binary dependencies of the application code itself;
        therefore, it’s not appropriate to blindly include them in the
        <filename>WEB-INF/lib</filename> directory. Instead, these resource
        archives should be separated from binary runtime dependencies, and
        unpacked into the web application document root somewhere. In order to
        achieve this kind of separation, we’ll need to use inclusion and
        exclusion patterns that apply to the coordinates of a specific
        dependency.</para>

        <para>In other words, say you have three or four web application which
        reuse the same resources and you want to create an assembly that puts
        provided dependencies into <filename>lib/</filename>, runtime
        dependencies into
        <filename>webapps/&lt;contextName&gt;/WEB-INF/lib</filename>, and then
        unpacks a specific runtime dependency into your web application's
        document root. You can do this because the Assembly allows you to
        define multiple include and exclude patterns for a given
        <sgmltag>dependencySet</sgmltag> element. Read the next section for
        more development of this idea.</para>
      </section>

      <section>
        <title>Fine Tuning: Dependency Includes and Excludes</title>

        <para>A resource dependency might be as simple as a set of resources
        (CSS, Javascript, and Images) in a project that has an assembly which
        creates a <acronym>ZIP</acronym> archive. Depending on the particulars
        of our web application, we might be able to distinguish resource
        dependencies from binary dependencies solely according to type. Most
        web applications are going to depend on other dependencies of type
        <varname>jar</varname>, and it is possible that we can state with
        certainty that all dependencies of type <varname>zip</varname> are
        resource dependencies. Or, we might have a situation where resources
        are stored in <varname>jar</varname> format, but have a classifier of
        something like <varname>resources</varname>. In either case, we can
        specify an inclusion pattern to target these resource dependencies and
        apply different logic than that used for binary dependencies. We’ll
        specify these tuning patterns using the <sgmltag>includes</sgmltag>
        and <sgmltag>excludes</sgmltag> sections of the
        <sgmltag>dependencySet</sgmltag>.</para>

        <para>Both includes and excludes are list sections, meaning they
        accept the sub-elements <sgmltag>include</sgmltag> and
        <sgmltag>exclude</sgmltag> respectively. Each
        <sgmltag>include</sgmltag> or <sgmltag>exclude</sgmltag> element
        contains a string value, which can contain wildcards. Each string
        value can match dependencies in a few different ways. Generally
        speaking, three identity pattern formats are supported:</para>

        <variablelist>
          <varlistentry>
            <term><varname>groupId:artifactId</varname> - version-less
            key</term>

            <listitem>
              <para>You would use this pattern to match a dependency by only
              the groupId and the artifactId</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]</varname> -
            conflict id</term>

            <listitem>
              <para>The pattern allows you to specify a wider set of
              coordinates to create a more specific include/exclude
              pattern.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]:version</varname>
            - full artifact identity</term>

            <listitem>
              <para>If you need to get really specific, you can specify all
              the coordinates.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>All of these pattern formats support the wildcard character ‘*’,
        which can match any subsection of the identity and is not limited to
        matching single identity parts (sections between ‘:’ characters).
        Also, note that the classifier section above is optional, in that
        patterns matching dependencies that don’t have classifiers do not need
        to account for the classifier section in the pattern.</para>

        <para>In the example given above, where the key distinction is the
        artifact type zip, and none of the dependencies have classifiers, the
        following pattern would match resource dependencies assuming that they
        were of type <varname>zip</varname>:</para>

        <programlisting>*:zip</programlisting>

        <para>The pattern above makes use of the second dependency identity:
        the dependency’s conflict id. Now that we have a pattern that
        distinguishes resource dependencies from binary dependencies, we can
        modify our dependency sets to handle resource archives
        differently:</para>

        <example id="ex-complex-dependencySet">
          <title>Using Dependency Excludes and Includes in
          <sgmltag>dependencySets</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*:zip&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-complex-dependencySet" />, the
        runtime-scoped dependency set from our last example has been updated
        to exclude resource dependencies. Only binary dependencies (non-zip
        dependencies) should be added to the <filename>WEB-INF/lib</filename>
        directory of the web application. Resource dependencies now have their
        own dependency set, which is configured to include these dependencies
        in the resources directory of the web application. The
        <sgmltag>includes</sgmltag> section in the last
        <sgmltag>dependencySet</sgmltag> reverses the exclusion from the
        previous <sgmltag>dependencySet</sgmltag>, so that resource
        dependencies are included using the same identity pattern (i.e.
        <varname>*:zip</varname>). The last <sgmltag>dependencySet</sgmltag>
        refers to the shared resource dependency and it is configured to
        unpack the shared resource dependency in the document root of the web
        application.</para>

        <para><xref linkend="ex-complex-dependencySet" /> was based upon the
        assumption that our shared resources project dependency had a type
        which differed from all of the other dependencies. What if the share
        resource dependency had the same type as all of the other
        dependencies? How could you differentiate the dependency? In this case
        if the shared resource dependency had been bundled as a JAR with the
        classifier <varname>resources</varname>, you can change to the
        identity pattern and match those dependencies instead:</para>

        <programlisting>*:jar:resources</programlisting>

        <para>Instead of matching on artifacts with a type of
        <varname>zip</varname> and no classifier, we’re matching on artifacts
        with a classifier of resources and a type of
        <varname>jar</varname>.</para>

        <para>Just like the <sgmltag>fileSets</sgmltag> section,
        <sgmltag>dependencySets</sgmltag> support the
        <sgmltag>useStrictFiltering</sgmltag> flag. When enabled, any
        specified patterns that don’t match one or more dependencies will
        cause the assembly - and consequently, the build - to fail. This can
        be particularly useful as a safety valve, to make sure your project
        dependencies and assembly descriptors are synchronized and interacting
        as you expect them to. By default, this flag is set to
        <varname>false</varname> for the purposes of backward
        compatibility.</para>
      </section>

      <section>
        <title>Transitive Dependencies, Project Attachments, and Project
        Artifacts</title>

        <para>The <sgmltag>dependencySet</sgmltag> section supports two more
        general mechanisms for tuning the subset of matching artifacts:
        transitive selection options, and options for working with project
        artifacts. Both of these features are a product of the need to support
        legacy configurations that applied a somewhat more liberal definition
        of the word “dependency”. As a prime example, consider the project’s
        own main artifact. Typically, this would not be considered a
        dependency; yet older versions of the Assembly plugin included the
        project artifact in calculations of dependency sets. To provide
        backward compatibility with this “feature”, the 2.2 releases
        (currently at 2.2-beta-2) of the Assembly plugin support a flag in the
        <sgmltag>dependencySet</sgmltag> called
        <sgmltag>useProjectArtifact</sgmltag>, whose default value is
        <varname>true</varname>. By default, dependency sets will attempt to
        include the project artifact itself in calculations about which
        dependency artifacts match and which don’t. If you’d rather deal with
        the project artifact separately, set this flag to
        <varname>false</varname>.</para>

        <tip>
          <para>The authors of this book recommend that you always set
          <sgmltag>useProjectArtifact</sgmltag> to
          <varname>false</varname>.</para>
        </tip>

        <para>As a natural extension to the inclusion of the project artifact,
        the project’s attached artifacts can also be managed within a
        <sgmltag>dependencySet</sgmltag> using the
        <sgmltag>useProjectAttachments</sgmltag> flag (whose default value is
        <varname>false</varname>). Enabling this flag allows patterns that
        specify classifiers and types to match on artifacts that are
        “attached” to the main project artifact; that is, they share the same
        basic
        <varname>groupId</varname>/<varname>artifactId</varname>/<varname>version</varname>
        identity, but differ in <varname>type</varname> and
        <varname>classifier</varname> from the main artifact. This could be
        useful for including JavaDoc or source jars in an assembly.</para>

        <para>Aside from dealing with the project’s own artifacts, it’s also
        possible to fine-tune the dependency set using two
        transitive-resolution flags. The first, called
        <sgmltag>useTransitiveDependencies</sgmltag> (and set to
        <varname>true</varname> by default) simply specifies whether the
        dependency set should consider transitive dependencies at all when
        determining the matching artifact set to be included. As an example of
        how this could be used, consider what happens when your
        <acronym>POM</acronym> has a dependency on another assembly. That
        assembly (most likely) will have a classifier that separates it from
        the main project artifact, making it an attachment. However, one quirk
        of the Maven dependency-resolution process is that the
        transitive-dependency information for the main artifact is still used
        when resolving the assembly artifact. If the assembly bundles its
        project dependencies inside itself, using transitive dependency
        resolution here would effectively duplicate those dependencies. To
        avoid this, we simply set <sgmltag>useTransitiveDependencies</sgmltag>
        to <varname>false</varname> for the dependency set that handles that
        assembly dependency.</para>

        <para>The other transitive-resolution flag is far more subtle. It’s
        called <sgmltag>useTransitiveFiltering</sgmltag>, and has a default
        value of <varname>false</varname>. To understand what this flag does,
        we first need to understand what information is available for any
        given artifact during the resolution process. When an artifact is a
        dependency of a dependency (that is, removed at least one level from
        your own <acronym>POM</acronym>), it has what Maven calls a
        "dependency trail", which is maintained as a list of strings that
        correspond to the full artifact identities
        (<varname>groupId:artifactId:type:[classifier:]version</varname>) of
        all dependencies between your <acronym>POM</acronym> and the artifact
        that owns that dependency trail. If you remember the three types of
        artifact identities available for pattern matching in a dependency
        set, you’ll notice that the entries in the dependency trail - the full
        artifact identity - correspond to the third type. When
        <sgmltag>useTransitiveFiltering</sgmltag> is set to
        <varname>true</varname>, the entries in an artifact’s dependency trail
        can cause the artifact to be included or excluded in the same way its
        own identity can.</para>

        <para>If you’re considering using transitive filtering, be careful! A
        given artifact can be included from multiple places in the
        transitive-dependency graph, but as of Maven 2.0.9, only the first
        inclusion’s trail will be tracked for this type of matching. This can
        lead to subtle problems when collecting the dependencies for your
        project.</para>

        <warning>
          <para>Most assemblies don’t really need this level of control over
          dependency sets; consider carefully whether yours truly does. Hint:
          It probably doesn't.</para>
        </warning>
      </section>

      <section>
        <title>Advanced Unpacking Options</title>

        <para>As we discussed previously, some project dependencies may need
        to be unpacked in order to create a working assembly archive. In the
        examples above, the decision to unpack or not was simple. It didn’t
        take into account what needed to be unpacked, or more importantly,
        what should not be unpacked. To gain more control over the dependency
        unpacking process, we can configure the
        <sgmltag>unpackOptions</sgmltag> element of the
        <sgmltag>dependencySet</sgmltag>. Using this section, we have the
        ability to choose which file patterns to include or exclude from the
        assembly, and whether included files should be filtered to resolve
        expressions using current <acronym>POM</acronym> information. In fact,
        the options available for unpacking dependency sets are fairly similar
        to those available for including files from the project directory
        structure, using the file sets descriptor section.</para>

        <para>To continue our web-application example, suppose some of the
        resource dependencies have been bundled with a file that details their
        distribution license. In the case of our web application, we’ll handle
        third-party license notices by way of a <filename>NOTICES</filename>
        file included in our own bundle, so we don’t want to include the
        license file from the resource dependency. To exclude this file, we
        simply add it to the unpack options inside the dependency set that
        handles resource artifacts:</para>

        <example>
          <title>Excluding Files from a Dependency Unpack</title>

          <programlisting language="xml">&lt;asembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
      &lt;unpackOptions&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/LICENSE*&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/unpackOptions&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Notice that the <sgmltag>exclude</sgmltag> we’re using looks
        very similar to those used in <sgmltag>fileSet</sgmltag> declarations.
        Here, we’re blocking any file starting with the word
        <filename>LICENSE</filename> in any directory within our resource
        artifacts. You can think of the unpack options section as a
        lightweight <sgmltag>fileSet</sgmltag> applied to each dependency
        matched within that dependency set. In other words, it is a
        <sgmltag>fileSet</sgmltag> by way of an unpacked dependency. Just as
        we specified an exclusion pattern for files within resource
        dependencies in order to block certain files, you can also choose
        which restricted set of files to include using the includes section.
        The same code that processes inclusions and exclusions on
        <sgmltag>fileSets</sgmltag> has been reused for processing
        <sgmltag>unpackOptions</sgmltag>.</para>

        <para>In addition to file inclusion and exclusion, the unpack options
        on a dependency set also provides a <sgmltag>filtering</sgmltag> flag,
        whose default value is <varname>false</varname>. Again, this should be
        familiar from our discussion of file sets above. In both cases,
        expressions using either the Maven syntax of
        <varname>${property}</varname> or the Ant syntax of
        <varname>@property@</varname> are supported. Filtering is a
        particularly nice feature to have for dependency sets, though, since
        it effectively allows you to create standardized, versioned resource
        templates that are then customized to each assembly as they are
        included. Once you start mastering the use of filtered, unpacked
        dependencies which store shared resources, you will be able to start
        abstracting repeated resources into common resource projects.</para>
      </section>

      <section>
        <title>Summarizing Dependency Sets</title>

        <para>Finally, it’s worth mentioning that dependency sets support the
        same <sgmltag>fileMode</sgmltag> and <sgmltag>directoryMode</sgmltag>
        configuration options that file sets do, though you should remember
        that the <sgmltag>directoryMode</sgmltag> setting will only be used
        when dependencies are unpacked.</para>
      </section>
    </section>

    <section>
      <title><sgmltag>moduleSets</sgmltag> 部分</title>

      <para>Multi-module builds are generally stitched together using the
      parent and modules sections of interrelated <acronym>POM</acronym>s.
      Typically, parent <acronym>POM</acronym>s specify their children in a
      <sgmltag>modules</sgmltag> section, which under normal circumstances
      causes the child <acronym>POM</acronym>s to be included in the build
      process of the parent. Exactly how this relationship is constructed can
      have important implications for the ways in which the Assembly plugin
      can participate in this process, but we’ll discuss that more later. For
      now, it’s enough to keep in mind this parent-module relationship as we
      discuss the <sgmltag>moduleSets</sgmltag> section.</para>

      <!--TODO: I think we need a simple example of how/why this would be used.-->

      <para>Projects are stitched together into multi-module builds because
      they are part of a larger system. These projects are designed to be used
      together, and single module in a larger build has little practical value
      on its own. In this way, the structure of the project’s build is related
      to the way we expect the project (and its modules) to be used. If
      consider the project from the user's perspective, it makes sense that
      the ideal end goal of that build would be a single, distributable file
      that the user can consume directly with minimum installation hassle.
      Since Maven multi-module builds typically follow a top-down structure,
      where dependency information, plugin configurations, and other
      information trickles down from parent to child, it seems natural that
      the task of rolling all of these modules into a single distribution file
      should fall to the topmost project. This is where the
      <sgmltag>moduleSet</sgmltag> comes into the picture.</para>

      <para>Module sets allow the inclusion of resources that belong to each
      module in the project structure into the final assembly archive. Just
      like you can select a group of files to include in an assembly using a
      <sgmltag>fileSet</sgmltag> and a <sgmltag>dependencySet</sgmltag>, you
      can include a set of files and resources using a
      <sgmltag>moduleSet</sgmltag> to refer to modules in a multi-module
      build. They achieve this by enabling two basic types of module-specific
      inclusion: file-based, and artifact-based. Before we get into the
      specifics and differences between file-based and artifact-based
      inclusion of module resources into an assembly, let’s talk a little
      about selecting which modules to process.</para>

      <section>
        <title>Module Selection</title>

        <para>By now, you should be familiar with
        <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag> patterns as
        they are used throughout the assembly descriptor to filter files and
        dependencies. When you are referring to modules in an assembly
        descriptor, you will also use the
        <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag> patterns to
        define rules which apply to different sets of modules. The difference
        in <sgmltag>moduleSet</sgmltag> <sgmltag>includes</sgmltag> and
        <sgmltag>excludes</sgmltag> is that these rules do not allow for
        wildcard patterns. (As of the 2.2-beta-2 release, this feature has not
        really seen much demand, so it hasn’t been implemented.) Instead, each
        include or exclude value is simply the <varname>groupId</varname> and
        <varname>artifactId</varname> for the module, separated by a colon,
        like this:</para>

        <programlisting>groupId:artifactId</programlisting>

        <para>In addition to <sgmltag>includes</sgmltag> and
        <sgmltag>excludes</sgmltag>, the <sgmltag>moduleSet</sgmltag> also
        supports an additional selection tool: the
        <sgmltag>includeSubModules</sgmltag> flag (whose default value is
        <varname>true</varname>). The parent-child relationship in any
        multi-module build structure is not strictly limited to two tiers of
        projects. In fact, you can include any number of tiers, or layers, in
        your build. Any project that is a module of a module of the current
        project is considered a sub-module. In some cases, you may want to
        deal with each individual module in the build separately (including
        sub-modules). For example, this is often simplest when dealing with
        artifact-based contributions from these modules. To do this, you would
        simply leave the <sgmltag>useSubModules</sgmltag> flag set to the
        default of <varname>true</varname>.</para>

        <para>When you’re trying to include files from each module’s directory
        structure, you may wish to process that module’s directory structure
        only once. If your project directory structure mirrors that of the
        parent-module relationships that are included in the
        <acronym>POM</acronym>s, this approach would allow file patterns like
        **/src/main/java to apply not only to that direct module’s project
        directory, but also to the directories of its own modules as well. In
        this case you don’t want to process sub-modules directly (they will be
        processed as subdirectories within your own project’s modules
        instead), you should set the <sgmltag>useSubModules</sgmltag> flag to
        <varname>false</varname>.</para>

        <para>Once we’ve determined how module selection should proceed for
        the module set in question, we’re ready to choose what to include from
        each module. As mentioned above, this can include files or artifacts
        from the module project.</para>
      </section>

      <section>
        <title>Sources Section</title>

        <para>Suppose you want to include the source of all modules in your
        project's assembly, but you would like to exclude a particular module.
        Maybe you have a project named <varname>secret-sauce</varname> which
        contains secret and sensitive code that you don't want to distribute
        with your project. The simplest way to accomplish this is to use a
        <sgmltag>moduleSet</sgmltag> which includes each project's directory
        in <varname>${module.basedir.name}</varname> and which excludes the
        <varname>secret-sauce</varname> module from the assembly.</para>

        <example id="ex-include-exclude-moduleSet">
          <title>Includes and Excluding Modules with a
          <sgmltag>moduleSet</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includeSubModules&gt;false&lt;/includeSubModules&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;
          com.mycompany.application:secret-sauce
        &lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;sources&gt;
        &lt;outputDirectoryMapping&gt;
          ${module.basedir.name}
        &lt;/outputDirectoryMapping&gt;
        &lt;excludeSubModuleDirectories&gt;
          false
        &lt;/excludeSubModuleDirectories&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;directory&gt;/&lt;/directory&gt;
            &lt;excludes&gt;
              &lt;exclude&gt;**/target&lt;/exclude&gt;
            &lt;/excludes&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
      &lt;/sources&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-include-exclude-moduleSet" />, since we’re
        dealing with each module’s sources it’s simpler to deal only with
        direct modules of the current project, handling sub-modules using
        file-path wildcard patterns in the file set. We set the
        <sgmltag>includeSubModules</sgmltag> element to
        <varname>false</varname> so we don't have to worry about submodules
        showing up in the root directory of the assembly archive. The
        <sgmltag>exclude</sgmltag> element will take care of excluding the
        <varname>secret-sauce</varname> module. We’re not going to include the
        project sources for the secret-sauce module; they’re, well,
        secret.</para>

        <para>Normally, module sources are included in the assembly under a
        subdirectory named after the module’s <varname>artifactId</varname>.
        However, since Maven allows modules that are not in directories named
        after the module project’s <varname>artifactId</varname>, it’s often
        better to use the expression <varname>${module.basedir.name}</varname>
        to preserve the module directory’s actual name
        (<varname>${module.basedir.name}</varname> is the same as calling
        <methodname>MavenProject.getBasedir().getName()</methodname>). It is
        critical to remember that modules are not required to be
        subdirectories of the project that declares them. If your project has
        a particularly strange directory structure, you may need to resort to
        special <sgmltag>moduleSet</sgmltag> declarations that include
        specific project and account for your own project's
        idiosyncracies.</para>

        <warning>
          <para>Try to minimize your own project's idiosyncracies, while Maven
          is flexible, if you find yourself doing too much configuration there
          is likely an easier way.</para>
        </warning>

        <para>Continuing through <xref
        linkend="ex-include-exclude-moduleSet" />, since we’re not processing
        sub-modules explicitly in this module set, we need to make sure
        sub-module directories are not excluded from the source directories we
        consider for each direct module. By setting the
        <sgmltag>excludeSubModuleDirectories</sgmltag> flag to
        <varname>false</varname>, this allows us to apply the same file
        pattern to directory structures within a sub-module of the one we’re
        processing. Finally in <xref
        linkend="ex-include-exclude-moduleSet" />, we’re not interested in any
        output of the build process for this module set. We exclude the
        target/ directory from all modules.</para>

        <para>It’s also worth mentioning that the <sgmltag>sources</sgmltag>
        section supports <sgmltag>fileSet</sgmltag>-like elements directly
        within itself, in addition to supporting nested
        <sgmltag>fileSets</sgmltag>. These configuration elements are used to
        provide backward compatibility to previous versions of the Assembly
        plugin (versions 2.1 and under) that didn’t support multiple distinct
        file sets for the same module without creating a separate module set
        declaration. They are deprecated, and should not be used.</para>
      </section>

      <section>
        <title>Interpolation of <sgmltag>outputDirectoryMapping</sgmltag> in
        <sgmltag>moduleSets</sgmltag></title>

        <para>In <xref linkend="sect-output-location" />, we used the element
        <sgmltag>outputDirectoryMapping</sgmltag> to change the name of the
        directory under which each module’s sources would be included. The
        expressions contained in this element are resolved in exactly the same
        way as the <sgmltag>outputFileNameMapping</sgmltag>, used in
        dependency sets (see the explanation of this algorithm in <xref
        linkend="sect-output-algorithm" />).</para>

        <para>In <xref linkend="ex-include-exclude-moduleSet" />, we used the
        expression <varname>${module.basedir.name}</varname>. You might notice
        that the root of that expression, <varname>module</varname>, is not
        listed in the mapping-resolution algorithm from the dependency sets
        section; this object root is specific to configurations within
        <sgmltag>moduleSets</sgmltag>. It works in exactly the same way as the
        <varname>${artifact.*}</varname> references available in the
        <sgmltag>outputFileNameMapping</sgmltag> element, except it is applied
        to the module’s <classname>MavenProject</classname>,
        <classname>Artifact</classname>, and
        <classname>ArtifactHandler</classname> instances instead of those from
        a dependency artifact.</para>
      </section>

      <section>
        <title>Binaries section</title>

        <para>Just as the <sgmltag>sources</sgmltag> section is primarily
        concerned with including a module in its source form, the
        <sgmltag>binaries</sgmltag> section is primarily concerned with
        including the module’s build output, or its artifacts. Though this
        section functions primarily as a way of specifying
        <sgmltag>dependencySets</sgmltag> that apply to each module in the
        set, there are a few additional features unique to module artifacts
        that are worth exploring: <sgmltag>attachmentClassifier</sgmltag> and
        <sgmltag>includeDependencies</sgmltag>. In addition, the
        <sgmltag>binaries</sgmltag> section contains options similar to the
        <sgmltag>dependencySet</sgmltag> section, that relate to the handling
        of the module artifact itself. These are: <sgmltag>unpack</sgmltag>,
        <sgmltag>outputFileNameMapping</sgmltag>,
        <sgmltag>outputDirectory</sgmltag>, <sgmltag>directoryMode</sgmltag>,
        and <sgmltag>fileMode</sgmltag>. Finally, module binaries can contain
        a <sgmltag>dependencySets</sgmltag> section, to specify how each
        module’s dependencies should be included in the assembly archive.
        First, let’s take a look at how the options mentioned here can be used
        to manage the module’s own artifacts.</para>

        <para>Suppose we want to include the javadoc jars for each of our
        modules inside our assembly. In this case, we don’t care about
        including the module dependencies; we just want the javadoc jar.
        However, since this particular jar is always going to be present as an
        attachment to the main project artifact, we need to specify which
        classifier to use to retrieve it. For simplicity, we won’t cover
        unpacking the module javadoc jars, since this configuration is exactly
        the same as what we used for dependency sets earlier in this chapter.
        The resulting module set might look similar to <xref
        linkend="ex-include-javadoc-moduleset" />.</para>

        <example id="ex-include-javadoc-moduleset">
          <title>Including JavaDoc from Modules in an Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;attachmentClassifier&gt;javadoc&lt;/attachmentClassifier&gt;
        &lt;includeDependencies&gt;false&lt;/includeDependencies&gt;
        &lt;outputDirectory&gt;apidoc-jars&lt;/outputDirectory&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-include-javadoc-moduleset" />, we don’t
        explicitly set the <sgmltag>includeSubModules</sgmltag> flag, since
        it’s <varname>true</varname> by default. However, we definitely want
        to process all modules - even sub-modules - using this module set,
        since we’re not using any sort of file pattern that could match on
        sub-module directory structures within. The
        <sgmltag>attachmentClassifier</sgmltag> grabs the attached artifact
        with the javadoc classifier for each module processed. The
        <sgmltag>includeDependencies</sgmltag> element tells the Assembly
        plugin that we're not interested in any of the module's dependencies,
        just the javadoc attachment. Finally, the
        <sgmltag>outputDirectory</sgmltag> element tells the Assembly plugin
        to put all of the javadoc jars into a directory named
        <filename>apidoc-jars/</filename> off of the assembly root
        directory.</para>

        <para>Although we’re not doing anything too complicated in this
        example, it’s important to understand that the same changes to the
        expression-resolution algorithm discussed for the
        <sgmltag>outputDirectoryMapping</sgmltag> element of the sources
        section also applies here. That is, whatever was available as
        <varname>${artifact.*}</varname> inside a
        <sgmltag>dependencySet</sgmltag>’s
        <sgmltag>outputFileNameMapping</sgmltag> configuration is also
        available here as <varname>${module.*}</varname>. The same applies for
        <sgmltag>outputFileNameMapping</sgmltag> when used directly within a
        <sgmltag>binaries</sgmltag> section.</para>

        <para>Finally, let’s examine an example where we simply want to
        process the module’s artifact and its runtime dependencies. In this
        case, we want to separate the artifact set for each module into
        separate directory structures, according to the module’s
        <varname>artifactId</varname> and <varname>version</varname>. The
        resulting module set is surprisingly simply, and it looks like the
        listing in <xref linkend="ex-the-big-include" />:</para>

        <example id="ex-the-big-include">
          <title>Including Module Artifacts and Dependencies in an
          Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;
          ${module.artifactId}-${module.version}
        &lt;/outputDirectory&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-the-big-include" />, we’re using the empty
        <sgmltag>dependencySet</sgmltag> element here, since that should
        include all runtime dependencies by default, with no configuration.
        With the <sgmltag>outputDirectory</sgmltag> specified at the binaries
        level, all dependencies should be included alongside the module’s own
        artifact in the same directory, so we don’t even need to specify that
        in our dependency set.</para>

        <para>For the most part, module binaries are fairly straightforward.
        In both parts - the main part, concerned with handling the module
        artifact itself, and the dependency sets, concerned with the module’s
        dependencies - the configuration options are very similar to those in
        a dependency set. Of course, the binaries section also provides
        options for controlling whether dependencies are included, and which
        main-project artifact you want to use.</para>

        <para>Like the sources section, the binaries section contains a couple
        of configuration options that are provided solely for backward
        compatibility, and should be considered deprecated. These include the
        includes and excludes sub-sections.</para>
      </section>

      <section>
        <title><sgmltag>moduleSets</sgmltag>, Parent <acronym>POM</acronym>s
        and the <sgmltag>binaries</sgmltag> Section</title>

        <para>Finally, we close the discussion about module handling with a
        strong warning. There are subtle interactions between Maven’s internal
        design as it relates to parent-module relationships and the execution
        of a module-set’s binaries section. When a <acronym>POM</acronym>
        declares a parent, that parent must be resolved in some way or other
        before the <acronym>POM</acronym> in question can be built. If the
        parent is in the Maven repository, there is no problem. However, as of
        Maven 2.0.9 this can cause big problems if that parent is a
        higher-level <acronym>POM</acronym> in the same build, particularly if
        that parent <acronym>POM</acronym> expects to build an assembly using
        its modules’ binaries.</para>

        <para>Maven 2.0.9 sorts projects in a multi-module build according to
        their dependencies, with a given project’s dependencies being built
        ahead of itself. The problem is the parent element is considered a
        dependency, which means the parent project’s build must complete
        before the child project is built. If part of that parent’s build
        process includes the creation of an assembly that uses module
        binaries, those binaries will not exist yet, and therefore cannot be
        included, causing the assembly to fail. This is a complex and subtle
        issue, which severely limits the usefulness of the module binaries
        section of the assembly descriptor. In fact, it has been filed in the
        bug tracker for the Assembly plugin at: <ulink
        url="http://jira.codehaus.org/browse/MASSEMBLY-97">http://jira.codehaus.org/browse/MASSEMBLY-97</ulink>.
        Hopefully, future versions of Maven will find a way to restore this
        functionality, since the parent-first requirement may not be
        completely necessary.</para>
      </section>
    </section>

    <section>
      <title>Repositories Section</title>

      <para>The repositories section represents a slightly more exotic feature
      in the assembly descriptor, since few applications other than Maven can
      take full advantage of a Maven-repository directory structure. For this
      reason, and because many of its features closely resemble those in the
      <sgmltag>dependencySets</sgmltag> section, we won’t spend too much time
      on the repositories section of the assembly descriptor. In most cases,
      users who understand dependency sets should have no trouble constructing
      repositories via the Assembly plugin. We're not going to motivate the
      <sgmltag>repositories</sgmltag> section; we're not going to go through a
      the business of setting up a use case and walking you through the
      process. We're just going to bring up a few caveats for those of you who
      find the need to use the <sgmltag>repostiories</sgmltag> section.</para>

      <!--TODO: We probably need to motivate why you would ever want to do this.  Right now, this section
doesn't make sense to new users.-->

      <para>Having said that, there are a two features particular to the
      repositories section that deserve some mention. The first is the
      <sgmltag>includeMetadata</sgmltag> flag. When set to
      <varname>true</varname> it includes metadata such as the list of real
      versions that correspond to <varname>-SNAPSHOT</varname> virtual
      versions, and by default it’s set to <varname>false</varname>. At
      present, the only metadata included when this flag is
      <varname>true</varname> is the information downloaded from Maven’s
      central repository.</para>

      <para>The second feature is called
      <sgmltag>groupVersionAlignments</sgmltag>. Again, this section is a list
      of individual <sgmltag>groupVersionAlignment</sgmltag> configurations,
      whose purpose is to normalize all included artifacts for a particular
      <varname>groupId</varname> to use a single <varname>version</varname>.
      Each alignment entry consists of two mandatory elements -
      <varname>id</varname> and <varname>version</varname> - along with an
      optional section called <sgmltag>excludes</sgmltag> that supplies a list
      of <varname>artifactId</varname> string values which are to be excluded
      from this realignment. Unfortunately, this realignment doesn’t seem to
      modify the <acronym>POM</acronym>s involved in the repository, neither
      those related to realigned artifacts nor those that depend on realigned
      artifacts, so it’s difficult to imagine what the practical application
      for this sort of realignment would be.</para>

      <para>In general, it’s simplest to apply the same principles you would
      use in dependency sets to repositories when adding them to your assembly
      descriptor. While the repositories section does support the above extra
      options, they are mainly provided for backward compatibility, and will
      probably be deprecated in future releases.</para>
    </section>

    <section>
      <title>Managing the Assembly’s Root Directory</title>

      <para>Now that we’ve made it through the main body of the assembly
      descriptor, we can close the discussion of content-related descriptor
      sections with something lighter: root-directory naming and
      site-directory handling.</para>

      <para>Some may consider it a stylistic concern, but it’s often important
      to have control over the name of the root directory for your assembly,
      or whether the root directory is there at all. Fortunately, two
      configuration options in the root of the assembly descriptor make
      managing the archive root directory simple:
      <sgmltag>includeBaseDirectory</sgmltag> and
      <sgmltag>baseDirectory</sgmltag>. In cases like executable jar files,
      you probably don’t want a root directory at all. To skip it, simply set
      the <sgmltag>includeBaseDirectory</sgmltag> flag to
      <varname>false</varname> (it’s <varname>true</varname> by default). This
      will result in an archive that, when unpacked, may create more than one
      directory in the unpack target directory. While this is considered bad
      form for archives that are meant to be unpacked before use, it’s not so
      bad for archives that are consumable as-is.</para>

      <para>In other cases, you may want to guarantee the name of the archive
      root directory regardless of the <acronym>POM</acronym>’s version or
      other information. By default, the <sgmltag>baseDirectory</sgmltag>
      element has a value equal to
      <varname>${project.artifactId}-${project.version}</varname>. However, we
      can easily set this element to any value that consists of literal
      strings and expressions which can be interpolated from the current
      <acronym>POM</acronym>, such as
      <varname>${project.groupId}-${project.artifactId}</varname>. This could
      be very good news for your documentation team! (We all have those,
      right?)</para>

      <para>Another configuration available is the
      <sgmltag>includeSiteDirectory</sgmltag> flag, whose default value is
      <varname>false</varname>. If your project build has also constructed a
      website document root using the site lifecycle or the Site plugin goals,
      that output can be included by setting this flag to
      <varname>true</varname>. However, this feature is a bit limited, since
      it only includes the <sgmltag>outputDirectory</sgmltag> from the
      reporting section of the current <acronym>POM</acronym> (by default,
      <filename>target/site</filename>) and doesn’t take into consideration
      any site directories that may be available in module projects. Use it if
      you want, but a good <sgmltag>fileSet</sgmltag> specification or
      <sgmltag>moduleSet</sgmltag> specification with sources configured could
      serve equally well, if not better. This is yet another example of legacy
      configuration currently supported by the Assembly plugin for the purpose
      of backward compatibility. Your mileage may vary. If you really want to
      include a site that is aggregated from many modules, you'll want to
      consider using a <sgmltag>fileSet</sgmltag> or
      <sgmltag>moduleSet</sgmltag> instead of setting
      <sgmltag>includeSiteDirectory</sgmltag> to
      <varname>true</varname>.</para>
    </section>

    <section id="sect-componentDescriptors">
      <title><sgmltag>componentDescriptors</sgmltag> and
      <sgmltag>containerDescriptorHandlers</sgmltag></title>

      <para>To round out our exploration of the assembly descriptor, we should
      touch briefly on two other sections:
      <sgmltag>containerDescriptorHandlers</sgmltag> and
      <sgmltag>componentDescriptors</sgmltag>. The
      <sgmltag>containerDescriptorHandlers</sgmltag> section refers to custom
      components that you use to extend the capabilities of the Assembly
      plugin. Specifically, these custom components allow you to define and
      handle special files which may need to be merged from the multiple
      constituents used to create your assembly. A good example of this might
      be a custom container-descriptor handler that merged
      <filename>web.xml</filename> files from constituent war or war-fragment
      files included in your assembly, in order to create the single
      web-application descriptor required for you to use the resulting
      assembly archive as a war file.</para>

      <para>The <sgmltag>componentDescriptors</sgmltag> section allows you to
      reference external assembly-descriptor fragments and include them in the
      current descriptor. Component references can be any of the
      following:</para>

      <orderedlist>
        <listitem>
          <para>Relative file paths:
          <filename>src/main/assembly/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>Artifact references:
          <varname>groupId:artifactId:version[:type[:classifier]]</varname></para>
        </listitem>

        <listitem>
          <para>Classpath resources:
          <filename>/assemblies/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>URLs: <ulink
          url="http://www.sonatype.com/component.xml">http://www.sonatype.com/component.xml</ulink></para>
        </listitem>
      </orderedlist>

      <para>Incidentally, when resolving a component descriptor, the Assembly
      plugin tries those different strategies in that exact order. The first
      one to succeed is used.</para>

      <para>Component descriptors can contain many of the same
      content-oriented sections available in the assembly descriptor itself,
      with the exception of <sgmltag>moduleSets</sgmltag>, which is considered
      so specific to each project that it’s not a good candidate for reuse.
      Also included in a component descriptor is the
      <sgmltag>containerDescriptorHandlers</sgmltag> section, which we briefly
      discussed above. Component descriptors cannot contain formats, assembly
      id’s, or any configuration related to the base directory of the assembly
      archive, all of which are also considered unique to a particular
      assembly descriptor. While it may make sense to allow sharing of the
      formats section, this has not been implemented as of the 2.2-beta-2
      Assembly-plugin release.</para>
    </section>
  </section>

  <section>
    <title>Best Practices</title>

    <para>The Assembly plugin provides enough flexibility to solve many
    problems in a number of different ways. If you have a unique requirement
    for your project, there's a good chance that you can use the methods
    documented in this chapter to achieve almost any assembly structure. This
    section of the chapter details some common best practices which, if
    adhered to, will make your experiences with the assembly plugin more
    productive and less painful.</para>

    <section>
      <title>Standard, Reusable Assembly Descriptors</title>

      <para>Up to now, we’ve been talking mainly about one-off solutions for
      building a particular type of assembly. But what do you do if you have
      dozens of projects that all need a particular type of assembly? In
      short, how can we reuse the effort we’ve invested to get our assemblies
      just the way we like them across more than one project without copying
      and pasting our assembly descriptor?</para>

      <para>The simplest answer is to create a standardized, versioned
      artifact out of the assembly descriptor, and deploy it. Once that’s
      done, you can specify that the Assembly plugin section of your project’s
      <acronym>POM</acronym> include the assembly-descriptor artifact as a
      plugin-level dependency, which will prompt Maven to resolve and include
      that artifact in the plugin’s classpath. At that point, you can use the
      assembly descriptor via the <sgmltag>descriptorRefs</sgmltag>
      configuration section in the Assembly plugin declaration. To illustrate,
      consider this example assembly descriptor:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;war-fragment&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
 &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/webapp&lt;/directory&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;**/web.xml&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Included in your project, this descriptor would be a useful way to
      bundle the project contents so that it could be unpacked directly into
      an existing web application in order to add to it (for adding an
      extending feature, say). However, if your team builds more than one of
      these web-fragment projects, it will likely want to reuse this
      descriptor rather than duplicating it. To deploy this descriptor as its
      own artifact, we’re going to put it in its own project, under the
      <filename>src/main/resources/assemblies</filename> directory.</para>

      <para>The project structure for this assembly-descriptor artifact will
      look similar to the following:</para>

      <programlisting>|-- pom.xml
`-- src
    `-- main
        `-- resources
            `-- assemblies
                `-- web-fragment.xml
</programlisting>

      <para>Notice the path of our <varname>web-fragment</varname> descriptor
      file. By default, Maven includes the files from the
      <filename>src/main/resources</filename> directory structure in the final
      jar, which means our assembly descriptor will be included with no extra
      configuration on our part. Also, notice the
      <filename>assemblies/</filename> path prefix, the Assembly plugin
      expects this path prefix on all descriptors provided in the plugin
      classpath. It’s important that we put our descriptor in the appropriate
      relative location, so it will be picked up by the Assembly plugin as it
      executes.</para>

      <para>Remember, this project is separate from your actual
      <varname>web-fragment</varname> project now; the assembly descriptor has
      become its own artifact with its own version and, possibly, its own
      release cycle. Once you install this new project using Maven, you’ll be
      able to reference it in your <varname>web-fragment</varname> projects.
      For clarity, the build process should look something like this:</para>

      <screen>$ <command>mvn install</command>
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/web-fragment-descriptor-1.0-SNAPSHOT.jar 
       to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
          web-fragment-descriptor/1.0-SNAPSHOT/web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)</screen>

      <para>Since there are no sources for the
      <varname>web-fragment-descriptor</varname> project, the resulting jar
      artifact will include nothing but our <varname>web-fragment</varname>
      assembly descriptor. Now, let’s use this new descriptor artifact:</para>

      <programlisting language="xml">&lt;project&gt;
  (...)
  &lt;artifactId&gt;my-web-fragment&lt;/artifactId&gt;
  (...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
            &lt;artifactId&gt;web-fragment-descriptor&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;assemble&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;web-fragment&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      (...)
    &lt;/plugins&gt;
  &lt;/build&gt;
  (...)
&lt;/project&gt;
</programlisting>

      <para>Two things are special about this Assembly plugin
      configuration:</para>

      <itemizedlist>
        <listitem>
          <para>We have to include a plugin-level dependency declaration on
          our new <varname>web-fragment-descriptor</varname> artifact in order
          to have access to the assembly descriptor via the plugin’s
          classpath.</para>
        </listitem>

        <listitem>
          <para>Since we’re using a classpath reference instead of a file in
          the local project directory structure, we must use the
          <sgmltag>descriptorRefs</sgmltag> section instead of the
          <sgmltag>descriptor</sgmltag> section. Also, notice that, while the
          assembly descriptor is actually in the
          <filename>assemblies/web-fragment.xml</filename> location within the
          plugin’s classpath, we reference it without the
          <filename>assemblies/</filename> prefix. This is because the
          Assembly plugin assumes that built-in assembly descriptors will
          always reside in the classpath under this path prefix.</para>
        </listitem>
      </itemizedlist>

      <para>Now, you’re free to reuse the <acronym>POM</acronym> configuration
      above in as many projects as you like, with the assurance that all of
      their web-fragment assemblies will turn out the same. As you need to
      make adjustments to the assembly format - maybe to include other
      resources, or to fine-tune the dependency and file sets - you can simply
      increment the version of the assembly descriptor’s project, and release
      it again. <acronym>POM</acronym>s referencing the assembly-descriptor
      artifact can then adopt this new version of the descriptor as they are
      able.</para>

      <para>One final point about assembly-descriptor reuse: you may want to
      consider sharing the plugin configuration itself as well as publishing
      the descriptor as an artifact. This is a fairly simple step; you simply
      add the configuration listed above to the
      <sgmltag>pluginManagement</sgmltag> section of your parent
      <acronym>POM</acronym>, then reference the managed plugin configuration
      from your module <acronym>POM</acronym> like this:</para>

      <programlisting language="xml">(...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
(...)</programlisting>

      <para>If you’ve added the rest of the plugin’s configuration - listed in
      the previous example - to the <sgmltag>pluginManagement</sgmltag>
      section of the project’s parent POM, then each project inheriting from
      that parent <acronym>POM</acronym> can add a minimal entry like the one
      above and take advantage of an advanced assembly format in their own
      builds.</para>
    </section>

    <section>
      <title>Distribution (Aggregating) Assemblies</title>

      <para>As mentioned above, the Assembly plugin provides multiple ways of
      creating many archive formats. Distribution archives are typically very
      good examples of this, since they often combine modules from a
      multi-module build, along with their dependencies and possibly, other
      files and artifacts besides these. The distribution aims to include all
      these different sources into a single archive that the user can
      download, unpack, and run with convenience. However, we also examined
      some of the potential drawbacks of using the
      <sgmltag>moduleSets</sgmltag> section of the assembly descriptor -
      namely, that the parent-child relationships between
      <acronym>POM</acronym>s in a build can prevent the availability of
      module artifacts in some cases.</para>

      <para>Specifically, if module <acronym>POM</acronym>s reference as their
      parent the <acronym>POM</acronym> that contains the Assembly-plugin
      configuration, that parent project will be built ahead of the module
      projects when the multi-module build executes. The parent’s assembly
      expects to find artifacts in place for its modules, but these module
      projects are waiting on the parent itself to finish building, a gridlock
      situation is reached and the parent build cannot succeed (since it’s
      unable to find artifacts for its module projects). In other words, the
      child project depends on the parent project which in turn depends on the
      child project.</para>

      <para>As an example, consider the assembly descriptor below, designed to
      be used from the top-level project of a multi-module hierarchy:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;distribution&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
    &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;format&gt;tar.bz2&lt;/format&gt;
  &lt;/formats&gt;
  
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-addons&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Given a parent project - called app-parent - with three modules
      called <varname>app-core</varname>, <varname>app-web</varname>, and
      <varname>app-addons</varname>, notice what happens when we try to
      execute this multi-module build:</para>

      <screen>$ <command>mvn package</command>
[INFO] Reactor build order: 
[INFO]   app-parent &lt;----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]    task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) does not have \
  an artifact with a file. Please ensure the package phase is run before the assembly is \
  generated.
...</screen>

      <para>The parent project - <varname>app-parent</varname> - builds first.
      This is because each of the other projects lists that
      <acronym>POM</acronym> as its parent, which causes it to be forced to
      the front of the build order. The <varname>app-web</varname> module,
      which is the first module to be processed in the assembly descriptor,
      hasn’t been built yet. Therefore, it has no artifact associated with it,
      and the assembly cannot succeed.</para>

      <para>One workaround for this is to remove the executions section of the
      Assembly-plugin declaration, that binds the plugin to the
      <varname>package</varname> lifecycle phase in the parent
      <acronym>POM</acronym>, keeping the configuration section intact. Then,
      execute Maven with two command-line tasks: the first,
      <varname>package</varname>, to build the multi-module project graph, and
      a second, <varname>assembly:assembly</varname>, as a direct invocation
      of the assembly plugin to consume the artifacts built on the previous
      run, and create the distribution assembly. The command line for such a
      build might look like this:</para>

      <screen>$ <command>mvn package assembly:assembly</command></screen>

      <para>However, this approach has several drawbacks. First, it makes the
      distribution-assembly process more of a manual task that can increase
      the complexity and potential for error in the overall build process
      significantly. Additionally, it could mean that attached artifacts -
      which are associated in memory as the project build executes - are not
      reachable on the second pass without resorting to file-system
      references.</para>

      <para>Instead of using a <sgmltag>moduleSet</sgmltag> to collect the
      artifacts from your multi-module build, it often makes more sense to
      employ a low-tech approach: using a dedicated distribution project
      module and inter-project dependencies. In this approach, you create a
      new module in your build whose sole purpose is to assemble the
      distribution. This module <acronym>POM</acronym> contains dependency
      references to all the other modules in the project hierarchy, and it
      configures the Assembly plugin to be bound the
      <varname>package</varname> phase of its build lifecycle. The assembly
      descriptor itself uses the <sgmltag>dependencySets</sgmltag> section
      instead of the <sgmltag>moduleSets</sgmltag> section to collect module
      artifacts and determine where to include them in the resulting assembly
      archive. This approach escapes the pitfalls associated with the
      parent-child relationship discussed above, and has the additional
      advantage of using a simpler configuration section within the assembly
      descriptor itself to do the job.</para>

      <para>To do this, we can create a new project structure that’s very
      similar to the one used for the module-set approach above, with the
      addition of a new distribution project, we might end up with five
      <acronym>POM</acronym>s in total: <varname>app-parent</varname>,
      <varname>app-core</varname>, <varname>app-web</varname>,
      <varname>app-addons</varname>, and <varname>app-distribution</varname>.
      The new <varname>app-distribution</varname> <acronym>POM</acronym> looks
      similar to the following:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;app-parent&lt;/artifactId&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;app-distribution&lt;/artifactId&gt;
  &lt;name&gt;app-distribution&lt;/name&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-web&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;war&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-addons&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Not necessary since it's brought in via app-web.
    &lt;dependency&gt; [2]
      &lt;artifactId&gt;app-core&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Notice that we have to include dependencies for the other modules
      in the project structure, since we don’t have a modules section to rely
      on in this <acronym>POM</acronym>. Also, notice that we’re not using an
      explicit dependency on <varname>app-core</varname>. Since it’s also a
      dependency of <varname>app-web</varname>, we don’t need to process it
      (or, avoid processing it) twice.</para>

      <para>Next, when we move the <filename>distro.xml</filename> assembly
      descriptor into the <varname>app-distribution</varname> project, we must
      also change it to use a <sgmltag>dependencySets</sgmltag> section, like
      this:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*-web&lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt;
      &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;
</programlisting>

      <para>This time, if we run the build from the top-level project
      directory, we get better news:</para>

      <screen>$ <command>mvn package</command>
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------</screen>

      <para>As you can see, the dependency-set approach is much more stable
      and - at least until Maven’s internal project-sorting logic catches up
      with the Assembly plugin’s capabilities, - involves less opportunity to
      get things wrong when running a build.</para>
    </section>
  </section>

  <section>
    <title>Summary</title>

    <para>As we’ve seen in this chapter, the Maven Assembly plugin offers
    quite a bit of potential for creating custom archive formats. While the
    details of these assembly archives can be complex, they certainly don’t
    have to be in all cases - as we saw with built-in assembly descriptors.
    Even if your aim is to include your project’s dependencies and selected
    project files in some unique, archived directory structure, writing a
    custom assembly descriptor doesn’t have to be an arduous task.</para>

    <para>Assemblies are useful for a wide array of applications, but are most
    commonly used as application distributions of various sorts. And, while
    there are many different ways to use the Assembly plugin, using
    standardized assembly-descriptor artifacts and avoiding
    <sgmltag>moduleSets</sgmltag> when creating distributions containing
    binaries are two sure ways to avoid problems.</para>
  </section>
</chapter>
